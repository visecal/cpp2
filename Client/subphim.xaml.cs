using FFmpeg.AutoGen;
using FFMpegCore;
using FFMpegCore.Enums;
using System.Collections.Specialized;
using Google.Apis.Drive.v3;
using Microsoft.VisualBasic.Devices;
using Microsoft.Win32;
using NAudio.Wave;
using NAudio.Wave.SampleProviders;
using Newtonsoft.Json;
using OpenCvSharp;
using OpenCvSharp.WpfExtensions;
using subphimv1.Audio;
using subphimv1.Controls;
using subphimv1.Converters;
using subphimv1.Filmstrip;
using subphimv1.Models;
using subphimv1.Services;
using subphimv1.Services.Whisper;
using subphimv1.Subphim;
using subphimv1.UserView;
using subphimv1.Waveform;
using subphimv1.Playback;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Shapes;
using System.Windows.Threading;
using Unosquare.FFME.Common;
using static subphimv1.Models.ProjectState;
using static subphimv1.Services.ApiService;
using static System.Net.Mime.MediaTypeNames;
using Keyboard = System.Windows.Input.Keyboard;
using MediaElement = Unosquare.FFME.MediaElement;
using Mouse = System.Windows.Input.Mouse;
using Path = System.IO.Path;





namespace subphimv1
{

    public enum VoiceoverExportMode
    {
        Default,
        Ducking
    }
    public enum SnapshotMode
    {
        None,          
        OcrOnly,       
        OcrAndTranslate 
    }
    public enum SmartCutMode
    {
        None,
        StaticReview,
        ParallelDynamic,
        DynamicVideo
    }
    public class SizeToRectConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture) { if (values.Length == 2 && values[0] is double width && values[1] is double height) { if (width > 0 && height > 0) { return new System.Windows.Rect(0, 0, width, height); } } return DependencyProperty.UnsetValue; }
        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture) { throw new NotImplementedException(); }
    }
    public partial class MainWindow : System.Windows.Window, System.ComponentModel.INotifyPropertyChanged
    {

        private readonly SmartCutService _smartCutService = new SmartCutService();
        private readonly TrackLayoutManager _trackLayoutManager = new TrackLayoutManager();
        private readonly DispatcherTimer _scrollRenderDebounce = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(16) };
        private bool _isSmartCutPopupOpen;
        private bool _isVideoFlipEnabled = false;
        private DispatcherTimer _snapshotResultTimer;
        private static readonly Regex OcrLineFilterRegex = new Regex(@"^[\s_]+\r?\n", RegexOptions.Compiled);
        private bool _scrollDirty = false;
        private bool _imeCompositionActive = false;
        private bool _imeCompositionJustCommitted = false;
        private VoiceoverExportMode _selectedVoiceoverMode = VoiceoverExportMode.Default;
        private List<TimelineClipViewModel> _clipsSortedByStart = new List<TimelineClipViewModel>();
        private int _consecutiveSeekSettleFailures = 0;
        private bool _isBatchProcessingPopupOpen;
        public bool IsBatchProcessingPopupOpen
        {
            get => _isBatchProcessingPopupOpen;
            set { if (_isBatchProcessingPopupOpen != value) { _isBatchProcessingPopupOpen = value; OnPropertyChanged(); } }
        }

        private string _batchInputFolderPath;
        public string BatchInputFolderPath
        {
            get => _batchInputFolderPath;
            set { if (_batchInputFolderPath != value) { _batchInputFolderPath = value; OnPropertyChanged(); } }
        }

        private string _batchOutputFolderPath;
        public string BatchOutputFolderPath
        {
            get => _batchOutputFolderPath;
            set { if (_batchOutputFolderPath != value) { _batchOutputFolderPath = value; OnPropertyChanged(); } }
        }

        private string _batchProcessingLog;
        public string BatchProcessingLog
        {
            get => _batchProcessingLog;
            set { if (_batchProcessingLog != value) { _batchProcessingLog = value; OnPropertyChanged(); } }
        }
        private string _batchSrtInputFolderPath;
        public string BatchSrtInputFolderPath
        {
            get => _batchSrtInputFolderPath;
            set { if (_batchSrtInputFolderPath != value) { _batchSrtInputFolderPath = value; OnPropertyChanged(); } }
        }

        private string _batchSrtOutputFolderPath;
        public string BatchSrtOutputFolderPath
        {
            get => _batchSrtOutputFolderPath;
            set { if (_batchSrtOutputFolderPath != value) { _batchSrtOutputFolderPath = value; OnPropertyChanged(); } }
        }

        private string _batchSrtProcessingLog;
        public string BatchSrtProcessingLog
        {
            get => _batchSrtProcessingLog;
            set { if (_batchSrtProcessingLog != value) { _batchSrtProcessingLog = value; OnPropertyChanged(); } }
        }

        private CancellationTokenSource _batchCts;
        private CancellationTokenSource _batchSrtCts;
        private bool _isUpdatingBatchCheckboxes = false;
        private bool _isRecoveringFromFreeze = false;
        private const int MAX_CONSECUTIVE_SEEK_FAILURES_BEFORE_RELOAD = 2;

        private sealed class TimelineClipStartComparer : IComparer<TimelineClipViewModel>
        {
            public static readonly TimelineClipStartComparer Instance = new TimelineClipStartComparer();
            public int Compare(TimelineClipViewModel a, TimelineClipViewModel b)
                => a.StartTime.CompareTo(b.StartTime);
        }
        public bool IsSmartCutPopupOpen
        {
            get => _isSmartCutPopupOpen;
            set
            {
                if (_isSmartCutPopupOpen != value)
                {
                    _isSmartCutPopupOpen = value;
                    OnPropertyChanged(nameof(IsSmartCutPopupOpen));
                }
            }
        }
        private List<(SrtSubtitleLine Line, TimeSpan FinalStart, TimeSpan FinalEnd)> _smartCutSubtitleTimeline;
        private SmartCutMode _currentSmartCutMode = SmartCutMode.None;
        private double _smartCutDynamicSpeed = 0.6;
        private const int TTS_CHUNK_TRIGGER_BYTES = 45000;
        private const int TTS_CHUNK_TARGET_BYTES = 10000;
        private readonly DispatcherTimer _zoomRenderDebounce = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(60) };
        private readonly HashSet<TimelineClipViewModel> _preparedFilmstrip = new();
        private readonly HashSet<TimelineClipViewModel> _preparedWaveform = new();
        private ImageAdorner _imageAdorner;
        private MediaAsset _activeTransformingImageAsset;
        private double _playheadDragStartAbsX;
        private TimeSpan _playheadDragStartTime;
        private readonly Dictionary<MediaAsset, FrameworkElement> _activeImageOverlays = new Dictionary<MediaAsset, FrameworkElement>();
        private readonly ConcurrentDictionary<TimelineClipViewModel, CancellationTokenSource> _filmstripTasks = new();
        private readonly ConcurrentDictionary<string, FilmstripService> _filmstripServiceInstances = new();
        private VideoPlaybackOptimizer _videoOptimizer;
        private const double FILMSTRIP_TILE_WIDTH = 80.0;
        private const int FILMSTRIP_TARGET_HEIGHT = 60;
        private const int FILMSTRIP_MAX_FRAMES_PER_CLIP = 400;
        private const double FILMSTRIP_REGEN_ZOOM_EPS = 0.15;
        private readonly Dictionary<TimelineClipViewModel, (double ZoomPps, int Count)> _filmstripLayout
            = new();
        private const int HARDSUB_IMAGE_BATCH_SIZE = 200;
        private SnapshotMode _currentSnapshotMode = SnapshotMode.None;
        private bool IsSnapshotModeActive => _currentSnapshotMode != SnapshotMode.None;
        private bool _isWasPlayingBeforeSnapshot = false;
        private Border _snapshotOverlayBorder = null;
        private Rectangle _snapshotSelectionRect = null;
        private System.Windows.Point _snapshotStartPoint;
        private bool _isSnapshotSelecting = false;
        private async Task<List<SrtSubtitleLine>> PrepareSrtViewFromImagesNonBlockingAsync(
    List<string> imageFiles,
    string srtFilePath,
    CancellationToken cancellationToken,
    int initialTrackIndex,
    TimeSpan? timeOffset = null,
    int startIndex = 1)
        {
            if (imageFiles == null || imageFiles.Count == 0)
                return new List<SrtSubtitleLine>();
            if (timeOffset == null)
            {
                await Dispatcher.InvokeAsync(() =>
                {
                    SrtSubtitleLinesView.Clear();
                    _currentSrtFilePath = srtFilePath;
                }, DispatcherPriority.Background);
            }
            var effectiveOffset = timeOffset ?? TimeSpan.Zero;
            var newLines = await Task.Run(() =>
            {
                return SrtFileUtils.CreateSrtLinesFromImageFiles(
                    imageFiles,
                    effectiveOffset,
                    startIndex);
            }, cancellationToken).ConfigureAwait(false);

            if (cancellationToken.IsCancellationRequested)
                return newLines ?? new List<SrtSubtitleLine>();

            if (newLines == null || newLines.Count == 0)
                return new List<SrtSubtitleLine>();
            var projectTemplate = GetTemplateAsStyleState();

            int total = newLines.Count;
            int index = 0;

            while (index < total)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var batch = newLines
                    .Skip(index)
                    .Take(HARDSUB_IMAGE_BATCH_SIZE)
                    .ToList();
                index += batch.Count;

                await Dispatcher.InvokeAsync(() =>
                {
                    _isUpdatingUiFromCode = true;
                    try
                    {
                        foreach (var srtLine in batch)
                        {
                            srtLine.TrackIndex = initialTrackIndex;
                            if (projectTemplate != null)
                            {
                                if (srtLine.Style == null)
                                    srtLine.Style = projectTemplate.Clone();

                                srtLine.Style.Width = null;
                                srtLine.Style.FixedTextBoxWidth = 0;
                            }
                            SrtSubtitleLinesView.Add(srtLine);
                            _currentProject.Subtitles.Add(srtLine);
                            TimelineClips.Add(new TimelineClipViewModel(srtLine));
                        }
                    }
                    finally
                    {
                        _isUpdatingUiFromCode = false;
                    }
                }, DispatcherPriority.Background);
                await Task.Yield();
            }
            await Dispatcher.InvokeAsync(() =>
            {
                RecalculateTrackAssignments();
                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();
            }, DispatcherPriority.Background);

            if (!string.IsNullOrWhiteSpace(srtFilePath))
            {
                try
                {
                    SrtFileUtils.SaveToFile(srtFilePath, newLines);
                }
                catch (Exception ex)
                {
                }
            }

            return newLines;
        }
        private readonly DispatcherTimer _performanceMonitor;
        private TimelineAudioEngine _audioEngine;
        private TimeSpan _previousPlayhead = TimeSpan.Zero;
        private TimelineClipViewModel _pendingOpenClip;
        private bool _pendingWasPlaying;
        private bool _isSwitchingVideoSource;
        private readonly TimelineRulerVisual _timelineRulerVisual;
        private readonly VisualHost _rulerHost;
        private DispatcherTimer _rulerRedrawTimer;
        private bool _isRulerRedrawPending = false;
        private bool _isAwaitingSeekCompletion = false;
        private volatile bool _isUserDraggingPlayhead = false;
        private int _seekGracePeriodCounter = 0;
        private readonly System.Diagnostics.Stopwatch _renderStopwatch = new System.Diagnostics.Stopwatch();
        private bool _isSwitchingSourceDueToPlayback = false;
        private bool _isModifyingVideoClip = false;
        private TimeSpan _preModificationEndTime;
        private StyleState _copiedStyleState = null;
        private bool _isDraggingPositionMarker = false;
        private bool _isMarqueeSelecting = false;
        private System.Windows.Point _marqueeStartPoint;
        private bool _suppressAudioDuringResize = false;
        private double _playerPanelScale = 1.0 / 1.1;
        private const double PLAYER_ZOOM_SPEED = 1.1;
        private const double PLAYER_ZOOM_MIN = 0.2;
        private List<StyleState> _stylePresets;
        private string _lastExportPath = "";
        private CancellationTokenSource _videoOpenCts;
        private bool _videoReady;
        private MediaAsset _activeVideo;
        private bool _isAdornerRotating = false;
        private double _finalAdornerAngle = 0;
        private RotateTransform _activeRotateTransform = null;
        private FrameworkElement _rotatingVisual = null;
        private readonly TimeSpan _clipEpsilon = TimeSpan.FromMilliseconds(80);
        private DateTime _lastScrubSeekAt = DateTime.MinValue;
        private static readonly TimeSpan _minScrubInterval = TimeSpan.FromMilliseconds(40);
        private bool _isOverlayVisible = false;
        private bool _isEdgeResizeActive = false;
        private double _edgeLeftPx;
        private double _edgeRightPx;
        private double _resizeCanvasWidth;
        private int _auxUiDepth = 0;

        private bool IsAuxUiActive => _auxUiDepth > 0;
        private void EnterAuxUi() { _auxUiDepth++; }
        private void ExitAuxUi() { if (_auxUiDepth > 0) _auxUiDepth--; }
        #region Timeline Playback
        private bool _isTextInEditMode = false;
        private const double RESIZE_EDGE_SLOP = 8.0;
        private TimeSpan _actualContentDuration;
        private FontFamily _originalFontFamilyBeforePreview;
        private const bool ScalePaddingLikeWpf = false;
        private enum PlayerMode { Timeline, Preview }
        private bool _isFramePreviewMode = false;
        private bool _framePreviewInitialized = false;
        private string _framePreviewSourcePath = null;
        private TimelineClipViewModel _framePreviewActiveVideoClip = null;
        private double _framePreviewFps = 30.0; 
        private TimeSpan _framePreviewFrameDuration = TimeSpan.FromSeconds(1.0 / 30.0);
        private bool _wasPlayingBeforeFramePreview = false;
        private TimelineClipViewModel _activeVideoClip;
        private TimeSpan _playhead = TimeSpan.Zero;
        private bool _isTimelinePlaying = false;
        private static string BuildAtempoChain(double speed)
        {
            double s = Math.Clamp(speed, 0.25, 4.0);

            if (Math.Abs(s - 1.0) < 1e-6)
                return string.Empty;
            const double MinStrict = 0.500001;
            const double MaxStep = 2.0;
            var steps = new List<double>();
            static string fmt(double v) => v.ToString("0.###############", CultureInfo.InvariantCulture);
            if (s > 1.0)
            {
                while (s > MaxStep + 1e-9)
                {
                    steps.Add(MaxStep);
                    s /= MaxStep;
                }
                if (s <= 0.5 + 1e-12)
                {
                    double f = Math.Sqrt(Math.Max(s, 0.25));
                    if (f <= MinStrict) f = MinStrict;
                    steps.Add(f);
                    steps.Add(s / f);
                }
                else
                {
                    steps.Add(s);
                }
            }
            else
            {
                if (s >= MinStrict)
                {
                    steps.Add(s);
                }
                else
                {
                    double logBase = Math.Log(0.5);
                    int m = (int)Math.Floor(Math.Log(s) / logBase) + 1;
                    if (m < 2) m = 2;
                    double f = Math.Pow(s, 1.0 / m);
                    while (f <= MinStrict)
                    {
                        m++;
                        f = Math.Pow(s, 1.0 / m);
                        if (m > 12) break;
                    }
                    for (int i = 0; i < m - 1; i++)
                        steps.Add(f);
                    double prod = 1.0;
                    for (int i = 0; i < steps.Count; i++) prod *= steps[i];
                    double last = s / prod;
                    if (last <= MinStrict)
                    {
                        if (steps.Count >= 1)
                        {
                            double prev = steps[^1];
                            double g = Math.Sqrt(prev * last);
                            if (g <= MinStrict) g = MinStrict + 1e-6;
                            steps[^1] = g;
                            last = s / (prod * (g / prev));
                        }
                    }

                    steps.Add(last);
                }
            }
            for (int i = steps.Count - 1; i >= 0; i--)
                if (Math.Abs(steps[i] - 1.0) < 1e-6) steps.RemoveAt(i);
            for (int i = 0; i < steps.Count; i++)
            {
                if (steps[i] <= 0.5) steps[i] = MinStrict;
                if (steps[i] > 2.0) steps[i] = 2.0;
            }
            if (steps.Count == 0) return string.Empty;
            return string.Join(",", steps.Select(v => $"atempo={fmt(v)}"));
        }

        private static float DbToGain(double db) => (float)Math.Pow(10.0, db / 20.0);
        private Task _playbackTask;
        private CancellationTokenSource _playbackCts;
        private TimeSpan? _pendingSeekForNewSource = null;
        private bool _wasPlayingBeforeSeek = false;
        #endregion
        #region Custom Prompt Fields
        private Dictionary<string, string> _customPrompts = new Dictionary<string, string>();
        public ObservableCollection<string> CustomPromptNames { get; set; }

        private bool _isCustomPromptEnabled;
        public bool IsCustomPromptEnabled
        {
            get => _isCustomPromptEnabled;
            set { if (_isCustomPromptEnabled != value) { _isCustomPromptEnabled = value; OnPropertyChanged(); } }
        }

        private string _selectedCustomPromptName;
        public string SelectedCustomPromptName
        {
            get => _selectedCustomPromptName;
            set
            {
                if (_selectedCustomPromptName != value)
                {
                    _selectedCustomPromptName = value;
                    OnPropertyChanged();
                    if (_customPrompts.TryGetValue(_selectedCustomPromptName ?? "", out var promptText))
                    {
                        CurrentCustomPromptText = promptText;
                    }
                }
            }
        }

        private string _currentCustomPromptText;
        public string CurrentCustomPromptText
        {
            get => _currentCustomPromptText;
            set { if (_currentCustomPromptText != value) { _currentCustomPromptText = value; OnPropertyChanged(); } }
        }

        private bool _isSavePromptPopupOpen;
        public bool IsSavePromptPopupOpen
        {
            get => _isSavePromptPopupOpen;
            set { if (_isSavePromptPopupOpen != value) { _isSavePromptPopupOpen = value; OnPropertyChanged(); } }
        }

        private string _newPromptName;
        public string NewPromptName
        {
            get => _newPromptName;
            set { if (_newPromptName != value) { _newPromptName = value; OnPropertyChanged(); } }
        }
        #endregion
        #region INotifyPropertyChanged Implementation
        private bool _isBatchSubtitleMode = false;
        public bool IsBatchSubtitleMode { get => _isBatchSubtitleMode; set { if (_isBatchSubtitleMode != value) { _isBatchSubtitleMode = value; OnPropertyChanged(nameof(IsBatchSubtitleMode)); UpdateSubtitleButtonVisibility(); } } }
        private List<TimelineClipViewModel> _clipsForBatchSubtitle;
        private subphimv1.Services.UndoRedoService<EditorSnapshot> _undoRedoService = new subphimv1.Services.UndoRedoService<EditorSnapshot>();
        private bool _isSuppressingTimelineUpdate = false;
        private TimeSpan _resizeInitialStartTime;
        private TimeSpan _resizeInitialEndTime;
        private TimeSpan _playheadBeforeResize = TimeSpan.Zero;
        private double _pixelsPerSecond = 50.0;
        private enum DragMode { None, MoveClip, AdjustVolume, ResizeClip }
        private DragMode _currentDragMode = DragMode.None;
        private Thumb _draggedResizeHandle = null;
        private System.Windows.Point _dragStartPointInCanvas;
        private bool _isPreparingToDragClip = false;
        private System.Windows.Point _dragStartPointInGrid;
        private double _dragClipInitialX;
        private double _dragClipInitialY;
        private System.Windows.Point _dragStartPoint;
        private List<TimelineAudioClipViewModel> _timelineAudioClipsVM = new List<TimelineAudioClipViewModel>();
        private StyleState _globalSubtitleStyle = new StyleState();
        private SrtSubtitleLine _selectedSubtitle;
        public SrtSubtitleLine SelectedSubtitle { get => _selectedSubtitle; set { if (_selectedSubtitle != value) { _selectedSubtitle = value; OnPropertyChanged(nameof(SelectedSubtitle)); } } }
        private MediaAsset _activeMediaAsset;
        public MediaAsset ActiveMediaAsset { get => _activeMediaAsset; set { if (_activeMediaAsset != value) { if (_activeMediaAsset != null) { _activeMediaAsset.IsSelected = false; } _activeMediaAsset = value; if (_activeMediaAsset != null) { _activeMediaAsset.IsSelected = true; } OnPropertyChanged(nameof(ActiveMediaAsset)); } } }
        private AdornerLayer _adornerLayer;
        private readonly Dictionary<SrtSubtitleLine, FrameworkElement> _activeVisuals = new Dictionary<SrtSubtitleLine, FrameworkElement>();
        private SubtitleAdorner _subtitleAdorner;
        private VideoAdorner _videoAdorner;
        private MediaAsset _activeTransformingVideoAsset;
        private bool _isAdornerDragging = false;
        private double _renderLatchSavedVolume = 1.0;
        private ProjectState _currentProject;
        public ProjectState CurrentProject { get => _currentProject; set { if (_currentProject != value) { _currentProject = value; OnPropertyChanged(nameof(CurrentProject)); } } }
        private bool _isUpdatingUiFromCode = false;
        private double _projectReferenceVideoHeight = 720.0;
        private double WPF_FONT_SIZE_CORRECTION_FACTOR = 0.9;
        private const double DEFAULT_FONT_SIZE_PERCENT_OF_HEIGHT = 0.07;
        public AudioTrackModel MainAudioTrack { get => _mainAudioTrack; }
        public ObservableCollection<TimelineClipViewModel> TimelineClips { get; set; }
        #region Multi-select Audio Sync Logic
        private bool _isApplyingBulkAudioChange = false;

        private void AttachHandlersForClipVM(TimelineClipViewModel vm)
        {
            if (vm == null) return;
            vm.PropertyChanged += ClipVM_PropertyChanged_ForAudioSync;
        }

        private void DetachHandlersForClipVM(TimelineClipViewModel vm)
        {
            if (vm == null) return;
            vm.PropertyChanged -= ClipVM_PropertyChanged_ForAudioSync;
        }

        private void TimelineClips_CollectionChanged_ForAudioSync(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            if (e?.NewItems != null)
            {
                foreach (var item in e.NewItems)
                {
                    if (item is TimelineClipViewModel vm)
                    {
                        AttachHandlersForClipVM(vm);
                    }
                }
            }
            if (e?.OldItems != null)
            {
                foreach (var item in e.OldItems)
                {
                    if (item is TimelineClipViewModel vm)
                    {
                        DetachHandlersForClipVM(vm);
                    }
                }
            }
        }
        private void ClipVM_PropertyChanged_ForAudioSync(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName != nameof(TimelineClipViewModel.VolumeDb) || _isApplyingBulkAudioChange) return;
            if (_isSuppressingTimelineUpdate) return; // Don't handle property changes during undo/redo

            if (sender is not TimelineClipViewModel sourceVm) return;
            if (sourceVm.ClipType != TimelineClipType.Audio && sourceVm.ClipType != TimelineClipType.Video) return;
            UpdateVolumeForPlayingClip(sourceVm, sourceVm.VolumeDb);
            if (!sourceVm.IsSelected) return;

            ApplyVolumeToSelectedClips(sourceVm.VolumeDb, sourceVm);
        }
        private void SelectedAudioClip_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (_isApplyingBulkAudioChange) return;
            if (_isSuppressingTimelineUpdate) return; // Don't handle property changes during undo/redo
            if (sender is not TimelineAudioClip changedClip) return;
            bool isVolume = (e.PropertyName == nameof(TimelineAudioClip.VolumeDb));
            bool isSpeed = (e.PropertyName == nameof(TimelineAudioClip.Speed) || e.PropertyName == nameof(MediaAsset.Speed));
            bool isPitch = (e.PropertyName == nameof(TimelineAudioClip.PitchCorrection));
            bool isFade = (e.PropertyName == nameof(TimelineAudioClip.FadeInDuration)
                          || e.PropertyName == nameof(TimelineAudioClip.FadeOutDuration));
            if (!isSpeed && !isPitch && !isFade && !isVolume) return;

            try
            {
                _isApplyingBulkAudioChange = true;
                double? newSpeed = changedClip.Speed;
                bool? newPitch = changedClip.PitchCorrection;
                double? newFadeIn = changedClip.FadeInDuration;
                double? newFadeOut = changedClip.FadeOutDuration;
                double? newVolume = changedClip.VolumeDb;
                var selectedAudioVMs = TimelineClips
                    .Where(vm => vm.IsSelected && vm.ClipType == TimelineClipType.Audio)
                    .ToList();
                foreach (var vm in selectedAudioVMs)
                {
                    if (vm.SourceData is TimelineAudioClip tac)
                    {
                        if (isSpeed && newSpeed.HasValue) tac.Speed = newSpeed.Value;
                        if (isPitch && newPitch.HasValue) tac.PitchCorrection = newPitch.Value;
                        if (isFade && newFadeIn.HasValue) tac.FadeInDuration = newFadeIn.Value;
                        if (isFade && newFadeOut.HasValue) tac.FadeOutDuration = newFadeOut.Value;
                        if (isVolume && newVolume.HasValue && Math.Abs(tac.VolumeDb - newVolume.Value) > 1e-9) tac.VolumeDb = newVolume.Value;
                    }
                    else if (vm.SourceData is MediaAsset ma && ma.Type == AssetType.Audio)
                    {
                        if (isSpeed && newSpeed.HasValue) ma.Speed = newSpeed.Value;
                        if (isVolume && newVolume.HasValue && Math.Abs(ma.VolumeDb - newVolume.Value) > 1e-9) ma.VolumeDb = newVolume.Value;
                    }
                }
                foreach (var vm in selectedAudioVMs)
                {
                    if (isSpeed || isPitch) _audioEngine?.UpdateClipProperties(vm);

                    vm.RefreshPropertiesFromSource();

                    if (isSpeed)
                    {
                        if (vm.SourceData is TimelineAudioClip tac2)
                            vm.Width = Math.Max(1.0, tac2.EffectiveDuration.TotalSeconds * _pixelsPerSecond);
                        else if (vm.SourceData is MediaAsset ma2)
                            vm.Width = Math.Max(1.0, ma2.EffectiveDuration.TotalSeconds * _pixelsPerSecond);
                    }

                    // [FIX] Sync volume slider changes to waveform thumb on all selected audio clips
                    if (isVolume)
                    {
                        vm.InvalidateWaveform();
                    }
                }
            }
            finally
            {
                _isApplyingBulkAudioChange = false;
            }
            if (isSpeed)
            {
                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();
            }
            _undoRedoService?.AddState(CaptureEditorSnapshot());
            SaveProjectCurrent();
        }

        private void ApplyVolumeToSelectedClips(double targetDb, TimelineClipViewModel sourceVm)
        {
            if (_isApplyingBulkAudioChange) return;

            try
            {
                _isApplyingBulkAudioChange = true;

                var selectedAudioCapableVMs = TimelineClips
                    .Where(c => c.IsSelected && (c.ClipType == TimelineClipType.Audio || c.ClipType == TimelineClipType.Video))
                    .ToList();
                foreach (var vm in selectedAudioCapableVMs)
                {
                    if (Math.Abs(vm.VolumeDb - targetDb) > 1e-9)
                    {
                        vm.VolumeDb = targetDb;
                    }
                }
            }
            finally
            {
                _isApplyingBulkAudioChange = false;
            }
        }
        private void UpdateVolumeForPlayingClip(TimelineClipViewModel clipVM, double volumeDb)
        {
            try
            {
                if (clipVM.ClipType == TimelineClipType.Audio && _audioEngine != null)
                {
                    _audioEngine?.UpdateClipProperties(clipVM);
                }
                else if (clipVM.ClipType == TimelineClipType.Video)
                {
                    bool isActiveVideo = false;

                    if (_activeVideoClip == clipVM)
                    {
                        isActiveVideo = true;
                    }
                    else if (clipVM.SourceData is MediaAsset ma && _activeVideo == ma)
                    {
                        isActiveVideo = true;
                    }
                    if (isActiveVideo && _newPlaybackController != null && _useNewPlaybackSystem)
                    {
                        _newPlaybackController.SetVolumeDb(volumeDb);
                    }
                }
            }
            catch (Exception ex){}
        }
        #endregion
        private Border _blurPreview;
        private SubtitleAdorner _blurAdorner;
        public bool IsBlurPopupOpen { get; set; }

        public ObservableCollection<TimelineClipViewModel> VisibleTimelineClips { get; set; }
        private const double TIMELINE_TRACK_HEIGHT = 80;
        private const double TIMELINE_AUDIO_TRACK_HEIGHT = 50;
        private const double TIMELINE_TRACK_SPACING = 8;
        private bool _isDraggingTimelineClip = false;
        private TimelineClipViewModel _draggedTimelineClip = null;
        private System.Windows.Point _dragClipStartPoint;
        private TimelineClipViewModel _selectedTimelineClip;
        public TimelineClipViewModel SelectedTimelineClip { get => _selectedTimelineClip; set { if (_selectedTimelineClip != value) { _selectedTimelineClip = value; OnPropertyChanged(nameof(SelectedTimelineClip)); } } }
        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName)); }
        #endregion
        #region TTS Fields & Properties

        private MediaElement _ttsAudioPlayer;
        private DispatcherTimer _ttsProgressTimer;
        private bool _isTtsPlaying = false;
        private bool _isTtsSliderDragging = false;
        private string _currentTtsAudioPath = null;
        private bool _ttsVoicesLoaded = false;
        private bool _ttsModelsLoaded = false;
        private List<TtsLanguage> _allTtsLanguages;
        private List<TtsLanguage> _capCutLanguages;
        private List<TtsVoice> _defaultChirp3dVoices;
        private List<TtsModel> _ttsModels;

        // Lưu các dòng subtitle được chọn từ timeline để tạo TTS
        private List<SrtSubtitleLine> _pendingTimelineSubtitlesForTts = null;
        private readonly Dictionary<string, string> _ttsModelDisplayNames = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            { "Chirp3HD", "TTS VIP" },
            { "Chirp-HD", "Chirp-HD" },
            { "Neural2", "Neural2" },
            { "Standard", "Standard" },
            { "Studio", "Studio" },
            { "WaveNet", "WaveNet" }
        };
        #endregion
        #region Fields & Properties
        private string _currentRotationDisplay;
        public string CurrentRotationDisplay
        {
            get => _currentRotationDisplay;
            set
            {
                if (_currentRotationDisplay != value)
                {
                    _currentRotationDisplay = value;
                    OnPropertyChanged();
                }
            }
        }
        private List<(TimeSpan Start, TimeSpan End)> _exportCachedBlurIntervals = null;
        public ObservableCollection<MediaAsset> SubtitleAssets { get; set; }
        public ObservableCollection<MediaAsset> VideoImageAssets { get; set; }
        public ObservableCollection<MediaAsset> AudioAssets { get; set; }
        public ObservableCollection<TimelineAudioClip> TimelineAudioClips { get; set; }
        private TimelineAudioClip _selectedAudioClip;
        public TimelineAudioClip SelectedAudioClip { get => _selectedAudioClip; set { if (_selectedAudioClip != value) { if (_selectedAudioClip != null) { _selectedAudioClip.PropertyChanged -= SelectedAudioClip_PropertyChanged; } _selectedAudioClip = value; if (_selectedAudioClip != null) { _selectedAudioClip.PropertyChanged += SelectedAudioClip_PropertyChanged; } OnPropertyChanged(nameof(SelectedAudioClip)); } } }
        private bool _isAutoProcessing = false;
        private bool _wasPlayingBeforeDrag = false;
        // --- Configuration ---
        private string _googleDriveFolderId = "";
        private string _pathVSF = "";
        private string _ocrTextFolderName = "TXTImages";
        private string _cmdVsfArgs = "";
        private string _customVsfOutputBaseDir = "";
        private string _customSubtitleOutputDir = "";
        private VsfVideoOpenMethod _selectedVsfOpenMethod = VsfVideoOpenMethod.FFmpeg;
        private VsfProcessingMode _selectedVsfProcessingMode = VsfProcessingMode.CleanAndCreateTxtImages;
        private string _vsfNumThreadsSearch = "-1";
        private string _vsfNumThreadsClean = "-1";
        private bool _useCuda = true;
        private bool _isSpeechToTextMode = false;
        private readonly string _settingsFilePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "LauncherAIO", "Settings.ini");
        // --- Services & Helpers ---
        private VsfService _vsfService;
        private WhisperService _whisperService;
        private WhisperNetService _whisperNetService;
        private CancellationTokenSource _masterCts;
        private string _currentAioSessionId;
        // --- Video Player & Crop State ---
        private TimeSpan _totalTimelineDuration;
        private string _currentVideoPath = null;
        private double _finalCropTop, _finalCropBottom, _finalCropLeft, _finalCropRight;
        private double _topPercent = 0.7;
        private double _bottomPercent = 0.9;
        private double _leftPercent = 0.1;
        private double _rightPercent = 0.9;
        private double _videoNativeWidth;
        private double _videoNativeHeight;
        private DispatcherTimer _layoutTimer;
        private SrtTranslationService _srtTranslationService;
        // --- AIOSubPhim Cleanup & State ---
        private string _lastImagesFolderPath = "";
        private bool _deleteRawTexts = true;
        private bool _deleteTexts = true;
        private bool _compressRawTexts = false;
        private string _selectedGeminiModelOcr = "gemini-2.5-flash";
        private List<string> _geminiCustomModelsOcr = new List<string>();
        // --- Services & Helpers ---
        private GeminiOcrService _geminiServiceOcr;
        // --- State & Timers ---
        private Stopwatch _operationStopwatch;
        private DispatcherTimer _progressTimer;
        private string _currentTimedLogMessageFormat;
        private string _currentTaskNameForLog;
        private readonly string _desktopErrorFolderPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), $"OCR_Failed_Images_{DateTime.Now:yyyyMMdd_HHmmss}");
        // --- Gemini OCR Config ---
        private List<string> _geminiApiKeysOcr = new List<string>();
        private int _geminiImagesPerRequestOcr = 15;
        private int _geminiRequestsPerMinuteOcr = 8;
        private bool _geminiEnableMultiKeyOcr = false;
        #region Multi-Account Google OCR
        private class GoogleAccountContext
        {
            public string AccountName { get; init; }
            public string DriveFolderId { get; init; }
            public GoogleDriveService DriveService { get; init; }
            public GoogleOcrProcessor OcrProcessor { get; init; }
        }
        private List<GoogleAccountContext> _googleAccounts = new List<GoogleAccountContext>();
        #endregion
        public ObservableCollection<SrtSubtitleLine> SrtSubtitleLinesView { get; set; }
        private bool _isSrtTranslating = false;
        public bool IsSrtTranslating { get => _isSrtTranslating; set { if (_isSrtTranslating != value) { _isSrtTranslating = value; OnPropertyChanged(nameof(IsSrtTranslating)); } } }
        private string _currentSrtFilePath = "";
        // SRT Translation Config
        private string _chutesApiKeySrt = "";
        private List<string> _geminiApiKeysSrt = new List<string>();
        private bool _geminiEnableMultiKeySrt = false;
        private SrtApiProvider _currentSrtApiProvider = SrtApiProvider.AIOLauncher;
        private string _selectedChutesModelSrt = "google/gemini-pro";
        private string _selectedGeminiModelSrt = "gemini-2.5-flash";
        private string _selectedChatGPTModelSrt = "gpt-4o";
        private List<string> _chutesCustomModelsSrt = new List<string>();
        private List<string> _geminiCustomModelsSrt = new List<string>();
        private List<string> _chatGptCustomModelsSrt = new List<string>();
        private int _geminiSrtTranslationRpm = 8;
        private int _geminiSrtTranslationBatchSize = 40;
        private int _geminiSrtThinkingBudget = 8192;
        private int _chatGptSrtBatchSize = 40;
        private string _selectedSrtGenreValue = "H.Huyễn Tiên Hiệp";
        private string _selectedSrtTargetLanguage = "Tiếng Việt";
        private readonly HashSet<string> _srtErrorMarkers;
        private const int MAX_OCR_THREADS_GOOGLE = 50;
        private OcrMode _currentOcrMode = OcrMode.GeminiApi;
        // --- Timeline & Waveform State ---
        private AudioTrackModel _mainAudioTrack;
        private double _waveformZoomLevel = 1.0;
        private const double MIN_PIXELS_PER_SECOND = 0.2;
        private const double MAX_PIXELS_PER_SECOND = 1000.0;
        private const double ZOOM_STEP = 1.2;
        private const double MAX_DB = 20.0;
        private const double MIN_DB = -60.0;
        private const double MUTE_THRESHOLD_DB = -59.0;
        private Border _audioTrackContainer;
        private System.Windows.Point _lastMousePosition;
        private const double AUDIO_TRACK_CONTAINER_HEIGHT = 80.0;
        private const double WAVEFORM_DRAWING_HEIGHT = 40.0;
        private const double SUBTITLE_TRACK_AREA_HEIGHT = 100.0;
        private TimeSpan _visibleDuration = TimeSpan.FromSeconds(60);
        #endregion
        #region Timeline Clip Drag-Move State
        private bool _isDraggingClip = false;
        private TimelineClipViewModel _draggedClipVM = null;
        private double _dragInitialMouseX;
        private TimeSpan _dragInitialStartTime;
        private TimeSpan _dragInitialEndTime;
        private double _dragInitialMouseY;
        private int _dragInitialTrackIndex;
        #endregion
        // === [transport & gating flags] ===
        private volatile bool _isExplicitSeekInProgress = false;
        private volatile bool _isSwitchingSource = false;
        private DateTime _suppressUiCorrectionsUntil = DateTime.MinValue;
        private string _currentProjectFilePath;
        // Transport control
        private volatile int _transportVersion = 0;
        private readonly TimeSpan _settleTolerance = TimeSpan.FromMilliseconds(100);
        private readonly TimeSpan _settleTimeout = TimeSpan.FromMilliseconds(200);
        private readonly TimeSpan _settlePoll = TimeSpan.FromMilliseconds(10);
        private const double DEFAULT_REFERENCE_WIDTH = 1280;
        private const double DEFAULT_REFERENCE_HEIGHT = 720;

        private int NewTransportVersion() => Interlocked.Increment(ref _transportVersion);
        private void BlackoutOn() { }
        private void BlackoutOff() { }
        private bool _suppressAdornerForHardSub = false;
        private bool IsHardSubModeActive()
        {
            return (SubtitleTab != null && SubtitleTab.IsChecked == true)
                   && (ModeOcrRadio != null && ModeOcrRadio.IsChecked == true);
        }
        private void UpdateAdornerSuppression()
        {
            _suppressAdornerForHardSub = IsHardSubModeActive();

            if (_suppressAdornerForHardSub)
            {
                RemoveVideoAdorner();
                RemoveImageAdorner();
                RemoveSubtitleAdorner();
                if (overlayCanvas != null)
                {
                    overlayCanvas.IsHitTestVisible = true;
                    Panel.SetZIndex(overlayCanvas, 5000);
                }
            }
        }
        private async Task<bool> WaitForSeekSettleAsync(TimeSpan targetInClip, int token)
        {

            var start = Environment.TickCount;
            while (Environment.TickCount - start < _settleTimeout.TotalMilliseconds)
            {
                if (token != Volatile.Read(ref _transportVersion))
                {

                    return false;
                }
                if (_newPlaybackController == null)
                {
                    await Task.Delay(_settlePoll);
                    continue;
                }
                var cur = _newPlaybackController.Position;
                if (cur >= targetInClip - _settleTolerance && cur <= targetInClip + _settleTolerance)
                {
                    _consecutiveSeekSettleFailures = 0; 
                    return true;
                }

                await Task.Delay(_settlePoll);
            }
            if (token == Volatile.Read(ref _transportVersion)
                && _newPlaybackController != null
                && !_isSwitchingVideoSource
                && !_isRecoveringFromFreeze)
            {
                var recovered = await TryRecoverFromSeekFreezeAsync(targetInClip);
                if (recovered)
                {
                    return true;
                }
            }
            return false;
        }
        private async Task<bool> TryRecoverFromSeekFreezeAsync(TimeSpan freezeTargetInClip)
        {
            if (_isRecoveringFromFreeze || _isSwitchingVideoSource)
                return false;
            if (_activeVideoClip == null || string.IsNullOrEmpty(_currentVideoPath))
                return false;
            if (_newPlaybackController == null)
                return false;
            _consecutiveSeekSettleFailures++;
            if (_consecutiveSeekSettleFailures < MAX_CONSECUTIVE_SEEK_FAILURES_BEFORE_RELOAD)
            {
                return false;
            }
            _isRecoveringFromFreeze = true;
            bool wasPlaying = _isTimelinePlaying;

            try
            {
                _isTimelinePlaying = false;
                if (_videoOptimizer != null)
                {
                    try { await _videoOptimizer.CancelPendingSeeksAsync(); } catch { }
                }
                var mediaAsset = _activeVideoClip.SourceData as MediaAsset;
                var trimStart = mediaAsset?.TrimStartOffset ?? TimeSpan.Zero;
                var local = freezeTargetInClip;
                if (local < TimeSpan.Zero) local = TimeSpan.Zero;

                _isSwitchingVideoSource = true;
                var token = NewTransportVersion();
                var settled = await WaitForSeekSettleAsync(local, token);

                if (!settled)
                {
                    return false;
                }
                TimeSpan newTimelineTime = _activeVideoClip.StartTime + (local - trimStart);
                if (newTimelineTime < TimeSpan.Zero)
                    newTimelineTime = TimeSpan.Zero;
                _playhead = newTimelineTime;
                UpdatePlaybackUI(_playhead);
                UpdateSubtitleForCurrentTime(_playhead);
                _consecutiveSeekSettleFailures = 0;
                if (wasPlaying)
                {
                    await StartTimelinePlayback();
                }

                return true;
            }
            catch (Exception ex)
            {
                return false;
            }
            finally
            {
                _isRecoveringFromFreeze = false;
                _isSwitchingVideoSource = false;
            }
        }
        public MainWindow()
        {
            try { string ffmpegDllFolder = AppDomain.CurrentDomain.BaseDirectory; FFmpegWaveformExtractor.Register(ffmpegDllFolder); } catch (Exception ex) { }
            InitializeComponent(); 
            this.PreviewKeyDown += MainWindow_PreviewKeyDown;
            InitializeSelectedTextEditorImeSupport();
            CustomPromptNames = new ObservableCollection<string>();
            InitializeFFmpegAndPlayback();
            InitializePerformanceMonitoring();
            overlayCanvas.CacheMode = new BitmapCache();
            RenderOptions.SetBitmapScalingMode(overlayCanvas, BitmapScalingMode.LowQuality);
            _audioEngine = new TimelineAudioEngine();
            InitializeStylePresets();
            videoGridScaleTransform.ScaleX = videoGridScaleTransform.ScaleY = _playerPanelScale;
            ffmpeg.RootPath = AppDomain.CurrentDomain.BaseDirectory;
            PositionMarkerThumb.DragStarted += PositionMarkerThumb_DragStarted;
            PositionMarkerThumb.DragDelta += PositionMarkerThumb_DragDelta;
            PositionMarkerThumb.DragCompleted += PositionMarkerThumb_DragCompleted;
            MainContentGrid.PreviewMouseLeftButtonDown += MainContentGrid_PreviewMouseLeftButtonDown;
            this.DataContext = this;
            SrtSubtitleLinesView = new ObservableCollection<SrtSubtitleLine>();
            SubtitleAssets = new ObservableCollection<MediaAsset>();
            VideoImageAssets = new ObservableCollection<MediaAsset>();
            AudioAssets = new ObservableCollection<MediaAsset>();
            TimelineAudioClips = new ObservableCollection<TimelineAudioClip>();
            TimelineClips = new ObservableCollection<TimelineClipViewModel>();
            TimelineClips.CollectionChanged += TimelineClips_CollectionChanged_ForAudioSync;
            foreach (var vm in TimelineClips) { AttachHandlersForClipVM(vm); }
            TimelineClips.CollectionChanged += TimelineClips_CollectionChanged_ForIndex;
            RebuildSortedClipsIndex();
            VisibleTimelineClips = new ObservableCollection<TimelineClipViewModel>();
            VisibleTimelineClips.CollectionChanged += VisibleTimelineClips_CollectionChanged;
            _zoomRenderDebounce.Tick += (s, e) =>
            {
                _zoomRenderDebounce.Stop();
                RenderTimeline(_pixelsPerSecond);
                UpdateVisibleClips();
                RenderVisibleClipsOnly();
                DrawRuler(_pixelsPerSecond);
                UpdatePositionMarkerVisuals();
                UpdateFilmstripsForZoom();
            };

            _scrollRenderDebounce.Tick += (s, e) =>
            {
                if (!_scrollDirty) { _scrollRenderDebounce.Stop(); return; }
                _scrollDirty = false;

                DrawRuler(this._pixelsPerSecond);
                UpdateVisibleClips();
                RenderVisibleClipsOnly();
                UpdatePositionMarkerVisuals();
                TracksContainerGrid.InvalidateMeasure();
                TracksContainerGrid.UpdateLayout();
            };
            TempFileManager.CleanupPreviousSessionFiles();
            _vsfService = new VsfService { LogMessage = (msg, isErr) => LogMessage(msg, isErr), OnProgress = (p) => Dispatcher.Invoke(() => { /* */ }) };
            _whisperService = new WhisperService { LogMessage = (msg, isErr) => LogMessage(msg, isErr) };
            _whisperNetService = new WhisperNetService
            {
                LogMessage = (msg, isErr) => LogMessage(msg, isErr),
                OnCudaFailed = () =>
                {
                    bool shouldCancel = false;
                    Dispatcher.Invoke(() =>
                    {
                        var result = CustomMessageBox.Show(
                            "Phát hiện lỗi CUDA!\n\n" +
                            "GPU NVIDIA được phát hiện nhưng CUDA runtime không thể khởi động.\n" +
                            "Có thể do driver lỗi hoặc thiếu CUDA toolkit.\n\n" +
                            "Bạn có muốn:\n" +
                            "• Chọn 'Có' để HỦY và khắc phục lỗi CUDA (liên hệ page/hỗ trợ)\n" +
                            "• Chọn 'Không' để tiếp tục với CPU (chậm hơn)\n\n" +
                            "Khuyến nghị: Liên hệ page để được hỗ trợ cài đặt CUDA đúng cách.",
                            "Lỗi CUDA - Cần Khắc Phục",
                            MessageBoxButton.YesNo,
                            MessageBoxImage.Warning);
                        shouldCancel = (result == MessageBoxResult.Yes);
                    });
                    return shouldCancel;
                }
            };
            _progressTimer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(1) };
            _progressTimer.Tick += (s, e) => { /* */ };
            AudioSpeedComboBox.ItemsSource = new List<double> { 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 2.0, 3.0, 4.0 };
            _operationStopwatch = new Stopwatch();
            _mainAudioTrack = new AudioTrackModel();
            Directory.CreateDirectory(Path.GetDirectoryName(_settingsFilePath));
            LoadConfiguration();
            InitializeVsfThreadComboBox();
            ResetApplicationState(true);
            InitializeEditorEvents();
            FontFamilyComboBox.ItemsSource = Fonts.SystemFontFamilies.OrderBy(f => f.Source);
            TempFileManager.CleanupPreviousSessionFiles();
            this.DataContext = this;
            _srtErrorMarkers = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { "[API KHÔNG TRẢ VỀ DÒNG NÀY]", "[API DỊCH RỖNG]", "[LỖI DỊCH BATCH]", "[LỖI BATCH NGHIÊM TRỌNG]", "[LỖI PHẢN HỒI RỖNG TỪ API]", "[LỖI PAYLOAD RỖNG]", "[LỖI PARSE (RETRY)]", "[KHÔNG CÓ PHẢN HỒI (RETRY)]", "[LỖI NGHIÊM TRỌNG (RETRY)]", "[API DỊCH RỖNG (RETRY)]" };
            SrtLinesDataGrid.SelectionChanged += SrtLinesDataGrid_SelectionChanged;
            SrtApiProviderComboBox.ItemsSource = Enum.GetValues(typeof(SrtApiProvider));
            SrtGenreComboBox.ItemsSource = new List<string> { "H.Huyễn Tiên Hiệp", "Ngôn Tình", "Đô Thị Hiện Đại", "Khoa học lịch sử" };
            SrtTargetLanguageComboBox.ItemsSource = new List<string> {
                "Tiếng Việt",
                "Tiếng Anh",
                "Tiếng Trung (Giản thể)",
                "Tiếng Trung (Phồn thể)",
                "Tiếng Ả Rập",
                "Tiếng Bengali",
                "Tiếng Bungary",
                "Tiếng Catalan",
                "Tiếng Croatia",
                "Tiếng Séc",
                "Tiếng Đan Mạch",
                "Tiếng Hà Lan",
                "Tiếng Estonia",
                "Tiếng Filipino",
                "Tiếng Phần Lan",
                "Tiếng Pháp",
                "Tiếng Đức",
                "Tiếng Hy Lạp",
                "Tiếng Gujarati",
                "Tiếng Do Thái",
                "Tiếng Hindi",
                "Tiếng Hungary",
                "Tiếng Iceland",
                "Tiếng Indonesia",
                "Tiếng Ireland",
                "Tiếng Ý",
                "Tiếng Nhật",
                "Tiếng Java",
                "Tiếng Kannada",
                "Tiếng Khmer",
                "Tiếng Hàn",
                "Tiếng Lào",
                "Tiếng Latin",
                "Tiếng Latvia",
                "Tiếng Litva",
                "Tiếng Mã Lai",
                "Tiếng Malayalam",
                "Tiếng Marathi",
                "Tiếng Miến Điện",
                "Tiếng Nepal",
                "Tiếng Na Uy",
                "Tiếng Ba Tư",
                "Tiếng Ba Lan",
                "Tiếng Bồ Đào Nha",
                "Tiếng Punjabi",
                "Tiếng Rumani",
                "Tiếng Nga",
                "Tiếng Serbia",
                "Tiếng Slovak",
                "Tiếng Slovenia",
                "Tiếng Tây Ban Nha",
                "Tiếng Sunda",
                "Tiếng Swahili",
                "Tiếng Thụy Điển",
                "Tiếng Tamil",
                "Tiếng Telugu",
                "Tiếng Thái",
                "Tiếng Thổ Nhĩ Kỳ",
                "Tiếng Ukraina",
                "Tiếng Urdu",
                "Tiếng Uzbek",
                "Tiếng Wales"
            };
            InitializeSubtitleStyler();
            InitializeWhisperControls();
            UpdateTimeInputStates();
            UpdateResultsText();
            InitializeTtsComponents();
            this.PreviewMouseMove += MainWindow_PreviewMouseMove;
            this.PreviewMouseLeftButtonUp += MainWindow_PreviewMouseLeftButtonUp;
            this.Closing += MainWindow_OnClosing;
            this.StateChanged += MainWindow_StateChanged;
            MainContentGrid.PreviewMouseLeftButtonDown += MainContentGrid_PreviewMouseLeftButtonDown;
            if (_totalTimelineDuration.TotalSeconds <= 0) { _totalTimelineDuration = TimeSpan.FromMinutes(5); }
            UpdateTimelineScaleAndRender();
            UpdatePresetMenu();
            CompositionTarget.Rendering += CompositionTarget_Rendering;
            _timelineRulerVisual = new TimelineRulerVisual();
            _rulerHost = new VisualHost(_timelineRulerVisual.Visual);
            TimelineRulerHost.Child = _rulerHost;
            _snapshotResultTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(60)
            };
            _snapshotResultTimer.Tick += _snapshotResultTimer_Tick;
        }
        private void InitializeFFmpegAndPlayback()
        {
            try
            {
                InitializeNewPlaybackSystem();

                if (_useNewPlaybackSystem) {}
                else
                {
                    string ffmpegPath = System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "ffmpeg");
                    if (Directory.Exists(ffmpegPath))
                    {
                        FFmpegHardwareConfig.Initialize(ffmpegPath);
                    }
                    else
                    {
                        FFmpegHardwareConfig.Initialize();
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Không thể khởi tạo FFmpeg: {ex.Message}\n\nỨng dụng có thể hoạt động không ổn định.",
                    "Cảnh báo", MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        private void InitializePerformanceMonitoring()
        {
            var performanceMonitor = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(5)
            };

            performanceMonitor.Tick += (s, e) =>
            {
                if (_videoOptimizer != null)
                {
                    var droppedPct = _videoOptimizer.DroppedFramePercentage;
                    if (droppedPct > 5.0)  {}
                    _videoOptimizer.ResetStatistics();
                }
            };

            performanceMonitor.Start();
        }
        private void CleanupPlaybackResources()
        {
            try
            {
                _performanceMonitor?.Stop();
                _videoOptimizer?.CancelPendingSeeks();
                if (_newPlaybackController != null)
                {
                    DisposeNewPlaybackSystem();
                    _newPlaybackController = null;
                }
                if (FFMEMediaPlayer != null)
                {
                    try
                    {
                        FFMEMediaPlayer.Dispose();
                    }
                    catch (Exception ex) {}
                }
                if (_audioEngine != null)
                {
                    try
                    {
                        _audioEngine.Dispose();
                        _audioEngine = null;
                    }
                    catch (Exception ex)
                    {
                        _audioEngine = null; 
                    }
                }
                if (_ttsAudioPlayer != null)
                {
                    try
                    {
                        _ttsAudioPlayer.Dispose();
                        _ttsAudioPlayer = null;
                    }
                    catch (Exception ex) {}
                }
                if (_compositeRenderer != null)
                {
                    try {}
                    catch (Exception ex) {}
                }
                try
                {
                    subphimv1.Filmstrip.FFmpegLoader.Cleanup();
                }
                catch (Exception ex) {}
                GC.Collect();
                GC.WaitForPendingFinalizers();
                GC.Collect();
            }
            catch (Exception ex){}
        }
        private void RebuildSortedClipsIndex()
        {
            _clipsSortedByStart = TimelineClips.OrderBy(c => c.StartTime).ToList();
        }

        private void InsertIntoSortedIndex(TimelineClipViewModel clip)
        {
            int idx = _clipsSortedByStart.BinarySearch(clip, TimelineClipStartComparer.Instance);
            if (idx < 0) idx = ~idx;
            _clipsSortedByStart.Insert(idx, clip);
        }
        private async void TimelineClips_CollectionChanged_ForIndex(object sender, NotifyCollectionChangedEventArgs e)
        {
            bool hadAnyVideoBefore = _clipsSortedByStart != null && _clipsSortedByStart.Any(c => c != null && c.ClipType == TimelineClipType.Video);

            if (e.Action == NotifyCollectionChangedAction.Add && e.NewItems != null)
            {
                foreach (TimelineClipViewModel clip in e.NewItems)
                    InsertIntoSortedIndex(clip);
                if (!hadAnyVideoBefore)
                {
                    var firstVideoJustAdded = e.NewItems
                        .Cast<TimelineClipViewModel>()
                        .Where(vm => vm != null && vm.ClipType == TimelineClipType.Video)
                        .OrderBy(vm => vm.StartTime)
                        .FirstOrDefault();

                    if (firstVideoJustAdded != null)
                    {
                        await EnsurePlayerReadyOnFirstVideoClipAsync(firstVideoJustAdded);
                    }
                }
            }
            else if (e.Action == NotifyCollectionChangedAction.Remove && e.OldItems != null)
            {
                foreach (TimelineClipViewModel clip in e.OldItems)
                    _clipsSortedByStart.Remove(clip);
            }
            else
            {
                RebuildSortedClipsIndex();
            }
        }
        private async Task EnsurePlayerReadyOnFirstVideoClipAsync(TimelineClipViewModel newVideoClip)
        {
            try
            {
                if (newVideoClip == null || !newVideoClip.IsVideo)
                    return;
                if (_newPlaybackController != null && _activeVideoClip != null)
                    return;
                if (string.IsNullOrWhiteSpace(newVideoClip.FilePath) || !System.IO.File.Exists(newVideoClip.FilePath))
                    return;
                _pendingSeekForNewSource = _playhead;
                await SwitchActiveVideoClip(newVideoClip, resume: false);
            }
            catch
            {
                try { await ResetVideoPlayerState(); } catch { /* swallow */ }
            }
            finally
            {
                BlackoutOff();
            }
        }
        private void LoadGoogleAccounts()
        {
            _googleAccounts.Clear();

            string oauthRoot = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Oauth2.0");
            if (!Directory.Exists(oauthRoot))
            {
                return;
            }
            var accountDirectories = Directory.GetDirectories(oauthRoot).ToList();
            accountDirectories = accountDirectories.OrderBy(d => Guid.NewGuid()).ToList();
            var seenDriveFolderIds = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            var seenTokenDirs = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            foreach (var accDir in accountDirectories)
            {
                try
                {
                    string accountName = Path.GetFileName(accDir);
                    string credentialsPath = Path.Combine(accDir, "credentials.json");
                    if (!File.Exists(credentialsPath))
                    {
                        continue;
                    }
                    string folderIdFile = Directory.GetFiles(accDir)
                                                   .FirstOrDefault(f =>
                                                   {
                                                       string fileName = Path.GetFileName(f);
                                                       string ext = Path.GetExtension(f);

                                                       return string.IsNullOrEmpty(ext)
                                                              && !fileName.Equals("credentials.json", StringComparison.OrdinalIgnoreCase);
                                                   });

                    if (folderIdFile == null)
                    {
                        continue;
                    }

                    string driveFolderId = Path.GetFileName(folderIdFile);
                    if (string.IsNullOrWhiteSpace(driveFolderId))
                    {
                        continue;
                    }
                    if (!seenDriveFolderIds.Add(driveFolderId))
                    {
                        continue;
                    }
                    string tokenDirPath = Path.Combine(accDir, "token.json"); 
                    if (!seenTokenDirs.Add(tokenDirPath))
                    {
                        continue;
                    }
                    Directory.CreateDirectory(tokenDirPath);
                    var driveService = new Subphim.GoogleDriveService(credentialsPath, tokenDirPath, accountName)
                    {
                        LogMessage = (msg, isErr) => LogMessage(msg, isErr)
                    };
                    var semaphoreForThisAccount = new SemaphoreSlim(MAX_OCR_THREADS_GOOGLE, MAX_OCR_THREADS_GOOGLE);
                    var processor = new GoogleOcrProcessor(driveService, semaphoreForThisAccount);
                    processor.ErrorImageCopied += (imagePath, tag) =>
                    {
                        try
                        {
                            Directory.CreateDirectory(_desktopErrorFolderPath);
                            string fileName = Path.GetFileName(imagePath);
                            string dest = Path.Combine(_desktopErrorFolderPath, $"{tag}_{fileName}");
                            File.Copy(imagePath, dest, overwrite: true);
                        }
                        catch {}
                    };

                    _googleAccounts.Add(new GoogleAccountContext
                    {
                        AccountName = accountName,
                        DriveFolderId = driveFolderId,
                        DriveService = driveService,
                        OcrProcessor = processor
                    });
                }
                catch
                {
                    continue;
                }
            }
        }

        private void InitializeSelectedTextEditorImeSupport()
        {
            if (SelectedTextEditorTextBox == null)
                return;
            InputMethod.SetIsInputMethodEnabled(SelectedTextEditorTextBox, true);
            InputMethod.SetPreferredImeState(SelectedTextEditorTextBox, InputMethodState.On);
            TextCompositionManager.AddPreviewTextInputStartHandler(SelectedTextEditorTextBox, SelectedTextEditorTextBox_TextInputStart);
            TextCompositionManager.AddPreviewTextInputUpdateHandler(SelectedTextEditorTextBox, SelectedTextEditorTextBox_TextInputUpdate);
            TextCompositionManager.AddPreviewTextInputHandler(SelectedTextEditorTextBox, SelectedTextEditorTextBox_TextInputCommit);
            SelectedTextEditorTextBox.LostKeyboardFocus += (s, e) =>
            {
                _imeCompositionActive = false;
                _imeCompositionJustCommitted = false;
            };
        }
        private void SelectedTextEditorTextBox_TextInputStart(object sender, TextCompositionEventArgs e)
        {
            _imeCompositionActive = true;
            _imeCompositionJustCommitted = false;
        }
        private void SelectedTextEditorTextBox_TextInputUpdate(object sender, TextCompositionEventArgs e)
        {
            _imeCompositionActive = true;
            _imeCompositionJustCommitted = false;
        }
        private void SelectedTextEditorTextBox_TextInputCommit(object sender, TextCompositionEventArgs e)
        {
            _imeCompositionActive = false;
            _imeCompositionJustCommitted = true;
        }

        private const string CUSTOM_PROMPT_SUFFIX = @"

QUY TẮC CHUNG:
1. Kết quả là văn bản thuần túy, KHÔNG thêm lời dẫn, chú thích, markdown, in đậm/in nghiêng.
2. Mỗi dòng phải giữ nguyên số thứ tự. Ví dụ: 123: Nội dung dịch. Nếu không có gì để dịch, trả về: 123: Không có nội dung để dịch.
3. KHÔNG tự ý thêm dấu chấm, dấu phẩy ở đầu/cuối câu.";

        private void FFMEPlayer_MediaOpening(object sender, Unosquare.FFME.Common.MediaOpeningEventArgs e)
        {
        }
        private void QueueWaveformGeneration(object sourceData)
        {
            WavePeakPyramid existingPyramid = null;
            if (sourceData is MediaAsset ma_check) existingPyramid = ma_check.WavePeaks;
            else if (sourceData is TimelineAudioClip tac_check) existingPyramid = tac_check.WavePeaks;
            if (existingPyramid != null) return;
            string filePath = null;
            Action<WavePeakPyramid> onComplete = null;

            if (sourceData is MediaAsset ma && (ma.Type == AssetType.Video || ma.Type == AssetType.Audio))
            {
                filePath = ma.FilePath;
                onComplete = (pyramid) => ma.WavePeaks = pyramid;
            }
            else if (sourceData is TimelineAudioClip tac)
            {
                filePath = tac.FilePath;
                onComplete = (pyramid) => tac.WavePeaks = pyramid;
            }

            if (string.IsNullOrEmpty(filePath) || !File.Exists(filePath)) return;
            _ = Task.Run(async () =>
            {
                if (WavePeakCache.TryLoad(filePath, out var pyramid))
                {
                    onComplete(pyramid);
                }
                else
                {
                    pyramid = await WavePeakCache.BuildAsync(filePath, CancellationToken.None);
                    onComplete(pyramid);
                }
                await Dispatcher.InvokeAsync(() =>
                {
                    var vm = TimelineClips.FirstOrDefault(c => c.SourceData == sourceData);
                    if (vm != null)
                    {
                        vm.OnPropertyChanged(nameof(vm.WavePeaks));
                    }
                });
            });
        }

        private async void FFMEPlayer_MediaFailed(object sender, Unosquare.FFME.Common.MediaFailedEventArgs e)
        {
        }
        private void UpdateSubtitleButtonVisibility()
        {
            if (DefaultOcrButtonsPanel == null || StartBatchSubtitleCreationButton == null) return;

            if (IsBatchSubtitleMode)
            {
                DefaultOcrButtonsPanel.Visibility = Visibility.Collapsed;
                StartBatchSubtitleCreationButton.Visibility = Visibility.Visible;
            }
            else
            {
                DefaultOcrButtonsPanel.Visibility = Visibility.Visible;
                StartBatchSubtitleCreationButton.Visibility = Visibility.Collapsed;
            }
        }
        private void ClearAllAdorners()
        {
            RemoveSubtitleAdorner();
            RemoveVideoAdorner();
            RemoveImageAdorner();
            RemoveBlurAdorner();
            _activeTransformingImageAsset = null;
            _activeTransformingVideoAsset = null;
            _selectedSubtitle = null;
            _isTextInEditMode = false;
            UpdateEditorPanelVisibility();
        }
        private void MainContentGrid_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {


            var source = e.OriginalSource as DependencyObject;
            if (IsAuxUiActive)
            {
                return;
            }
            bool isClickOnNonPlayerZone =
                FindVisualParent<ContentPresenter>(source)?.DataContext is TimelineClipViewModel ||
                IsDescendantOf(source, EditorPanel) ||
                IsDescendantOf(source, AudioEditorPanel) ||
                IsDescendantOf(source, VideoEditorPanel) ||
                IsInsidePopup(source) ||
                FindVisualParent<System.Windows.Controls.Primitives.ScrollBar>(source) != null;

            if (isClickOnNonPlayerZone)
            {
                return;
            }
            if (overlayCanvas != null)
            {
                System.Windows.Point ptOverlay = e.GetPosition(overlayCanvas);
                var hitOverlay = overlayCanvas.InputHitTest(ptOverlay) as DependencyObject;
                if (hitOverlay != null)
                {
                    var thumbOnOverlay =
                        FindVisualParent<System.Windows.Controls.Primitives.Thumb>(hitOverlay) ??
                        (hitOverlay as System.Windows.Controls.Primitives.Thumb);

                    if (thumbOnOverlay != null)
                    {
                        return;
                    }
                }
            }

            bool clickedPlayerArea = IsDescendantOf(source, VideoContainerBorder);
            if (clickedPlayerArea)
            {
                if (FindVisualParent<Adorner>(source) != null)
                {
                    return;
                }
                System.Windows.Point clickPoint = e.GetPosition(SubtitleRenderCanvas);
                var hitObject = SubtitleRenderCanvas.InputHitTest(clickPoint) as DependencyObject;
                if (hitObject != null)
                {

                    var subtitleVisual = FindVisualParent<Border>(hitObject);
                    if (subtitleVisual != null && subtitleVisual.DataContext is SrtSubtitleLine srtLine)
                    {
                        return;
                    }
                    var blurVisual = FindVisualParent<Border>(hitObject);
                    if (blurVisual != null && blurVisual.Name == "BlurPreview" && blurVisual.DataContext is MediaAsset ma && ma.Type == AssetType.Blur)
                    {
                        return;
                    }

                }
                if (IsPointInsideAnyImageOverlay(clickPoint))
                {
                    return;
                }
                if (GetReferenceVideoFrameRect().Contains(e.GetPosition(PlayerAdornerDecorator)))
                {
                    var currentVideoClip = FindActiveVideoClipAt(_playhead);
                    if (currentVideoClip != null)
                    {
                        SwitchToClip(currentVideoClip);
                        e.Handled = true;
                        return;
                    }
                }
            }
            ClearAllAdorners();
            if (_selectedTimelineClip != null)
            {
                if (_selectedTimelineClip?.SourceData is INotifyPropertyChanged oldSource)
                    oldSource.PropertyChanged -= SelectedClip_PropertyChanged;

                _selectedTimelineClip.IsSelected = false;
                _selectedTimelineClip = null;
            }
            if (SelectedSubtitle != null)
            {
                SelectedSubtitle = null;
            }
            UpdateEditorPanelVisibility();
        }
        private bool IsDescendantOf(DependencyObject child, DependencyObject parent)
        {
            if (child == null || parent == null)
            {
                return false;
            }

            DependencyObject current = child;
            while (current != null)
            {
                if (current == parent)
                {
                    return true;
                }
                current = VisualTreeHelper.GetParent(current);
            }
            return false;
        }
        private void AudioSpeedComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            try
            {
                double ParseSpeed(object item)
                {
                    if (item == null) return 1.0;
                    var ci = System.Globalization.CultureInfo.InvariantCulture;

                    if (item is double d) return d > 0 ? d : 1.0;
                    if (item is float f) return f > 0 ? (double)f : 1.0;
                    if (item is string s)
                    {
                        s = s.Trim().ToLower().Replace("x", "");
                        s = s.Replace(',', '.');
                        if (double.TryParse(s, System.Globalization.NumberStyles.Float, ci, out var v) && v > 0) return v;
                    }
                    if (item is ComboBoxItem cbi)
                    {
                        var txt = cbi.Content?.ToString()?.Trim()?.ToLower();
                        if (!string.IsNullOrEmpty(txt))
                        {
                            txt = txt.Replace("x", "").Replace(',', '.');
                            if (double.TryParse(txt, System.Globalization.NumberStyles.Float, ci, out var v2) && v2 > 0) return v2;
                        }
                    }
                    return 1.0;
                }

                var combo = sender as ComboBox;
                if (combo == null) return;

                double newSpeed = ParseSpeed(combo.SelectedItem);
                if (newSpeed <= 0) return;
                var selectedVMs = TimelineClips
                    .Where(vm => vm.IsSelected && vm.ClipType == TimelineClipType.Audio)
                    .ToList();
                if (selectedVMs.Count == 0 && SelectedAudioClip != null)
                {
                    var vmSingle = TimelineClips.FirstOrDefault(vm => vm.SourceData == SelectedAudioClip);
                    if (vmSingle != null) selectedVMs.Add(vmSingle);
                }
                if (selectedVMs.Count == 0) return;
                _isApplyingBulkAudioChange = true;
                foreach (var vm in selectedVMs)
                {
                    if (vm.SourceData is MediaAsset ma && ma.Type == AssetType.Audio)
                    {
                        if (Math.Abs(ma.Speed - newSpeed) > 1e-9)
                            ma.Speed = newSpeed;
                    }
                    else if (vm.SourceData is TimelineAudioClip tac)
                    {
                        if (Math.Abs(tac.Speed - newSpeed) > 1e-9)
                            tac.Speed = newSpeed;
                    }
                }
                foreach (var vm in selectedVMs)
                {
                    _audioEngine?.UpdateClipProperties(vm);
                    vm.RefreshPropertiesFromSource();
                    if (vm.SourceData is TimelineAudioClip tac2)
                    {
                        vm.Width = Math.Max(1.0, tac2.EffectiveDuration.TotalSeconds * _pixelsPerSecond);
                    }
                    else if (vm.SourceData is MediaAsset ma2)
                    {
                        vm.Width = Math.Max(1.0, ma2.EffectiveDuration.TotalSeconds * _pixelsPerSecond);
                    }
                }
                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();
                _undoRedoService?.AddState(CaptureEditorSnapshot());
                SaveProjectCurrent();
            }
            finally
            {
                _isApplyingBulkAudioChange = false;
            }
        }
        private void UpdateVisibleClips()
        {
            if (_isSuppressingTimelineUpdate) return;
            if (_totalTimelineDuration.TotalSeconds <= 0 || double.IsNaN(TracksContainerGrid.Width) || TracksContainerGrid.Width <= 0)
            {
                if (VisibleTimelineClips.Any()) VisibleTimelineClips.Clear();
                return;
            }
            double pps = this._pixelsPerSecond;
            if (pps <= 0) return;
            double viewportStart = TimelineScrollViewer.HorizontalOffset;
            double viewportEnd = viewportStart + TimelineScrollViewer.ViewportWidth;
            double bufferPx = 2000.0;

            TimeSpan timeStart = TimeSpan.FromSeconds(Math.Max(0, (viewportStart - bufferPx) / pps));
            TimeSpan timeEnd = TimeSpan.FromSeconds((viewportEnd + bufferPx) / pps);

            if (_clipsSortedByStart.Count == 0)
            {
                if (VisibleTimelineClips.Any()) VisibleTimelineClips.Clear();
                return;
            }
            var newVisible = new HashSet<TimelineClipViewModel>();

            foreach (var clip in _clipsSortedByStart)
            {
                if (clip.StartTime < timeEnd && clip.EndTime > timeStart)
                {
                    newVisible.Add(clip);
                }
            }
            for (int i = VisibleTimelineClips.Count - 1; i >= 0; i--)
            {
                if (!newVisible.Contains(VisibleTimelineClips[i]))
                {
                    VisibleTimelineClips.RemoveAt(i);
                }
            }

            foreach (var c in newVisible)
            {
                if (!VisibleTimelineClips.Contains(c))
                {
                    VisibleTimelineClips.Add(c);
                }
            }
        }
        public class TtsProviderInfo
        {
            public string DisplayName { get; set; }
            public string ApiName { get; set; }
        }
        private void TtsInputTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            int currentLength = TtsInputTextBox.Text.Length;
            long remaining = App.User.TtsCharacterLimit - App.User.TtsCharactersUsed;
            TtsCharCountTextBlock.Text = $"{currentLength} / {remaining:N0}";
            if (currentLength > remaining)
            {
                TtsCharCountTextBlock.Foreground = Brushes.Red;
                GenerateTtsButton.IsEnabled = false;
            }
            else
            {
                TtsCharCountTextBlock.Foreground = (SolidColorBrush)FindResource("CapCut.TextSecondaryColor");
                GenerateTtsButton.IsEnabled = true;
            }
        }
        private void InitializeTtsComponents()
        {
            _ttsAudioPlayer = new Unosquare.FFME.MediaElement
            {
                LoadedBehavior = Unosquare.FFME.Common.MediaPlaybackState.Manual,
                UnloadedBehavior = Unosquare.FFME.Common.MediaPlaybackState.Close
            };

            TtsPlayerHost.Children.Add(_ttsAudioPlayer);
            TtsPlaybackControlsPanel.Visibility = Visibility.Collapsed;
            _ttsAudioPlayer.MediaOpened += TtsAudioPlayer_MediaOpened;
            _ttsAudioPlayer.MediaEnded += TtsAudioPlayer_MediaEnded;

            _ttsProgressTimer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(100) };
            _ttsProgressTimer.Tick += TtsProgressTimer_Tick;


            // Tạo danh sách ngôn ngữ từ Google TTS Voices Data + Tiếng Việt
            var languages = new List<TtsLanguage>
            {
                new TtsLanguage("Tiếng Việt (vi-VN)", "vi-VN")
            };

            var googleLanguages = GoogleTtsVoicesData.GetLanguages()
                .Select(g => new TtsLanguage(g.Language, g.LanguageCode))
                .ToList();

            foreach (var lang in googleLanguages)
            {
                if (lang.LanguageCode == "vi-VN")
                {
                    continue;
                }

                if (!languages.Any(l => l.LanguageCode == lang.LanguageCode))
                {
                    languages.Add(lang);
                }
            }

            languages = languages
                .OrderByDescending(l => l.LanguageCode == "vi-VN")
                .ThenBy(l => l.DisplayName)
                .ToList();

            _allTtsLanguages = languages;
            _capCutLanguages = _allTtsLanguages
                .Where(l => HasCapCutVoicesForLanguage(l.LanguageCode))
                .ToList();

            var defaultLanguageCode = _allTtsLanguages.First().LanguageCode;
            RefreshLanguageOptions("Chirp3HD", defaultLanguageCode);

            UpdateAioModelsForLanguage(AioLanguageComboBox.SelectedValue?.ToString());

            // Khởi tạo danh sách voices Chirp3D mặc định (giữ nguyên để tương thích với người dùng cũ)
            _defaultChirp3dVoices = new List<TtsVoice>
    {
        new TtsVoice("Hương Giang (Nữ)", "Achernar"),
        new TtsVoice("Quang Hùng (Nam)", "Achird"),
        new TtsVoice("Podcast (Nam)", "Algenib"),
        new TtsVoice("Podcast 2 (Nam)", "Algieba"),
        new TtsVoice("Quang Minh (Nam)", "Alnilam"),
        new TtsVoice("Ngọc Nhi (Nữ)", "Aoede"),
        new TtsVoice("Quỳnh Như (Nữ)", "Autonoe"),
        new TtsVoice("Hương Tràm (Nữ)", "Callirrhoe"),
        new TtsVoice("Văn Hoàng (Nam)", "Charon"),
        new TtsVoice("Ngọc Diễm (Nữ)", "Despina"),
        new TtsVoice("Trung Thường (Nam)", "Enceladus"),
        new TtsVoice("Lan Anh (Nữ)", "Erinome"),
        new TtsVoice("Nam Miền Nam", "Fenrir"),
        new TtsVoice("MC Ngọc Trinh (Nữ)", "Gacrux"),
        new TtsVoice("MC Nam Minh (Nam)", "Iapetus"),
        new TtsVoice("Hoa (Nữ)", "Kore"),
        new TtsVoice("Quỳnh Anh (Nữ)", "Laomedeia"),
        new TtsVoice("Ngọc Diệp (Nữ)", "Leda"),
        new TtsVoice("Quang Toản (Nam)", "Orus"),
        new TtsVoice("MC Miền Nam (Nam)", "Pulcherrima"),
        new TtsVoice("Nam Miền Nam 2", "Puck"),
        new TtsVoice("Thành Tiến (Nam)", "Rasalgethi"),
        new TtsVoice("Nam Minh (Nam)", "Sadachbia"),
        new TtsVoice("Trầm Giọng Bắc (Nam)", "Sadaltager"),
        new TtsVoice("MC Đám Ma (Nam)", "Schedar"),
        new TtsVoice("Fake Ngọc Huyền (Nữ)", "Sulafat"),
        new TtsVoice("Quang Hải (Nam)", "Umbriel"),
        new TtsVoice("Giọng đọc thơ (Nữ)", "Vindemiatrix"),
        new TtsVoice("Thiền Anh (Nữ)", "Zephyr"),
        new TtsVoice("Nam Trầm (Nam)", "Zubenelgenubi")
    };
            // Sử dụng voices mặc định ban đầu
            AioVoiceComboBox.ItemsSource = _defaultChirp3dVoices;
            AioVoiceComboBox.SelectedIndex = 0;
        }

        private void UpdateAioModelsForLanguage(string languageCode)
        {
            var availableModels = GoogleTtsVoicesData.GetModelsByLanguageCode(languageCode);
            var models = new List<TtsModel>
            {
                    new TtsModel("TTS VIP", "Chirp3HD")
            };

            if (languageCode == "vi-VN")
            {
                models.Add(new TtsModel(GetModelDisplayName("Chirp3HD"), "Chirp3HD"));
            }

            // Thêm CapCut Voice cho các ngôn ngữ được hỗ trợ
            if (HasCapCutVoicesForLanguage(languageCode))
            {
                models.Add(new TtsModel("CapCut Voice", "CapCut"));
            }

            foreach (var modelId in availableModels)
            {
                if (string.IsNullOrWhiteSpace(modelId))
                {
                    continue;
                }

                if (models.Any(m => string.Equals(m.ApiId, modelId, StringComparison.OrdinalIgnoreCase)))
                {
                    continue;
                }

                models.Add(new TtsModel(GetModelDisplayName(modelId), modelId));
            }

            _ttsModels = models;

            var currentSelection = AioModelComboBox.SelectedValue?.ToString();
            AioModelComboBox.ItemsSource = _ttsModels;

            if (!string.IsNullOrEmpty(currentSelection) && _ttsModels.Any(m => m.ApiId == currentSelection))
            {
                AioModelComboBox.SelectedValue = currentSelection;
            }
            else
            {
                AioModelComboBox.SelectedIndex = 0;
            }

            _ttsVoicesLoaded = false;
        }

        private void RefreshLanguageOptions(string modelId, string preferredLanguage = null)
        {
            if (_allTtsLanguages == null)
            {
                return;
            }

            var targetLanguages = string.Equals(modelId, "CapCut", StringComparison.OrdinalIgnoreCase) && _capCutLanguages?.Any() == true
                ? _capCutLanguages
                : _allTtsLanguages;

            var previousSelection = preferredLanguage ?? AioLanguageComboBox.SelectedValue?.ToString();
            var currentSource = AioLanguageComboBox.ItemsSource as IEnumerable<TtsLanguage>;

            if (!ReferenceEquals(currentSource, targetLanguages))
            {
                AioLanguageComboBox.ItemsSource = targetLanguages;
            }

            if (!string.IsNullOrWhiteSpace(previousSelection))
            {
                var matchedLanguage = targetLanguages.FirstOrDefault(l => string.Equals(l.LanguageCode, previousSelection, StringComparison.OrdinalIgnoreCase));
                if (matchedLanguage != null)
                {
                    AioLanguageComboBox.SelectedValue = matchedLanguage.LanguageCode;
                    return;
                }
            }

            if (targetLanguages.Any())
            {
                AioLanguageComboBox.SelectedValue = targetLanguages.First().LanguageCode;
            }
            else
            {
                AioLanguageComboBox.SelectedIndex = -1;
            }
        }

        /// <summary>
        /// Kiểm tra xem CapCut có hỗ trợ ngôn ngữ này không
        /// </summary>
        private bool HasCapCutVoicesForLanguage(string languageCode)
        {
            var capCutLanguage = MapLanguageCodeToCapCutLanguage(languageCode);
            if (string.IsNullOrEmpty(capCutLanguage))
            {
                return false;
            }

            // Kiểm tra xem có voice nào cho ngôn ngữ này không
            var voices = CapCutTtsService.FilterVoices(language: capCutLanguage);
            return voices.Count > 0;
        }

        /// <summary>
        /// Map language code (vi-VN, en-US, etc.) sang tên ngôn ngữ của CapCut (Tiếng Việt, Tiếng Anh, etc.)
        /// </summary>
        private string MapLanguageCodeToCapCutLanguage(string languageCode)
        {
            if (string.IsNullOrEmpty(languageCode))
            {
                return null;
            }

            // Map dựa trên language code
            return languageCode.ToLower() switch
            {
                // Tiếng Việt
                "vi" or "vi-vn" => "Tiếng Việt",

                // Tiếng Anh
                "en-us" => "Tiếng Anh (Mỹ)",
                "en-au" => "Tiếng Anh (Úc)",
                "en-uk" or "en-gb" => "Tiếng Anh (Anh)",
                var code when code.StartsWith("en") => "Tiếng Anh",

                // Châu Âu
                "fr" or "fr-fr" => "Tiếng Pháp",
                "de" or "de-de" => "Tiếng Đức",
                "es" or "es-es" => "Tiếng Tây Ban Nha",
                "es-mx" => "Tiếng Tây Ban Nha (Mexico)",

                // Châu Mỹ
                "pt-br" => "Tiếng Bồ Đào Nha (Brazil)",

                // Châu Á
                "id" or "id-id" => "Tiếng Indonesia",
                "ja" or "ja-jp" or "jp" => "Tiếng Nhật",
                "ko" or "ko-kr" or "kr" => "Tiếng Hàn",

                // Không hỗ trợ
                _ => null
            };
        }

        private string GetModelDisplayName(string modelId)
        {
            if (string.IsNullOrWhiteSpace(modelId))
            {
                return modelId;
            }

            if (_ttsModelDisplayNames.TryGetValue(modelId, out var displayName))
            {
                return displayName;
            }

            return modelId;
        }

        private async Task LoadTtsVoicesFromApiAsync()
        {
            if (_ttsVoicesLoaded)
            {
                return; // Đã load
            }

            try
            {
                // Lấy ngôn ngữ hiện tại được chọn
                string selectedLanguage = AioLanguageComboBox.SelectedValue?.ToString() ?? "vi-VN";

                // Lấy model được chọn
                string modelId = AioModelComboBox.SelectedValue?.ToString() ?? "all";

                List<TtsVoice> finalVoices = new List<TtsVoice>();

                // Nếu chọn CapCut Voice, load voices từ CapCut
                if (modelId == "CapCut")
                {
                    var capCutLanguage = MapLanguageCodeToCapCutLanguage(selectedLanguage);
                    if (!string.IsNullOrEmpty(capCutLanguage))
                    {
                        var capCutVoices = CapCutTtsService.FilterVoices(language: capCutLanguage);
                        foreach (var cv in capCutVoices)
                        {
                            string displayName = $"{cv.DisplayName} [{cv.Category}]";
                            finalVoices.Add(new TtsVoice(displayName, cv.VoiceId));
                        }
                    }
                }
                else
                {
                    // Nếu chọn Tiếng Việt và Chirp3HD, sử dụng danh sách Chirp3D mặc định
                    if (selectedLanguage == "vi-VN" && (modelId == "Chirp3HD" || modelId == "all"))
                    {
                        // Thêm voices Chirp3D Tiếng Việt (giữ nguyên)
                        finalVoices.AddRange(_defaultChirp3dVoices);
                    }

                    // Thêm voices từ Google TTS Data nếu không phải chỉ Chirp3HD
                    if (modelId != "Chirp3HD")
                    {
                        var googleVoices = GoogleTtsVoicesData.GetVoicesByModelAndLanguage(modelId, selectedLanguage);

                        foreach (var gv in googleVoices)
                        {
                            string displayName = $"{gv.VoiceId} ({gv.Gender})";

                            // Nếu voice ID đã có trong danh sách mặc định, bỏ qua
                            if (!finalVoices.Any(v => v.ApiId == gv.VoiceId))
                            {
                                finalVoices.Add(new TtsVoice(displayName, gv.VoiceId));
                            }
                        }
                    }
                }

                // Lưu voice đang được chọn
                var currentSelectedVoice = AioVoiceComboBox.SelectedValue?.ToString();

                // Cập nhật ItemsSource
                if (finalVoices.Count > 0)
                {
                    AioVoiceComboBox.ItemsSource = finalVoices;

                    // Khôi phục lựa chọn
                    if (!string.IsNullOrEmpty(currentSelectedVoice))
                    {
                        var voiceToSelect = finalVoices.FirstOrDefault(v => v.ApiId == currentSelectedVoice);
                        if (voiceToSelect != null)
                        {
                            AioVoiceComboBox.SelectedValue = voiceToSelect.ApiId;
                        }
                        else
                        {
                            AioVoiceComboBox.SelectedIndex = 0;
                        }
                    }
                    else
                    {
                        AioVoiceComboBox.SelectedIndex = 0;
                    }

                    _ttsVoicesLoaded = true;
                    Debug.WriteLine($"[TTS] Đã load {finalVoices.Count} voices (hard-coded)");
                }
                else
                {
                    // Nếu không có voice nào (đặc biệt khi chọn CapCut nhưng không tìm thấy voices)
                    if (modelId == "CapCut")
                    {
                        // Tự động chuyển về TTS VIP để tránh binding error
                        Debug.WriteLine($"[TTS] Không tìm thấy CapCut voices cho {selectedLanguage}, tự động chuyển về TTS VIP");

                        // Chuyển model về TTS VIP
                        AioModelComboBox.SelectedValue = "Chirp3HD";

                        // Force reload voices với model TTS VIP
                        _ttsVoicesLoaded = false;
                        await LoadTtsVoicesFromApiAsync();
                    }
                    else
                    {
                        // Nếu không có voice nào cho các model khác, giữ nguyên danh sách mặc định
                        AioVoiceComboBox.ItemsSource = _defaultChirp3dVoices;
                        AioVoiceComboBox.SelectedIndex = 0;
                        Debug.WriteLine($"[TTS] Không tìm thấy voices cho {selectedLanguage} - {modelId}, sử dụng mặc định");
                    }
                }

                await Task.CompletedTask; // Giữ async signature
            }
            catch (Exception ex)
            {
                // Nếu có lỗi, giữ nguyên danh sách mặc định
                Debug.WriteLine($"[TTS] Exception khi load voices: {ex.Message}");
            }
        }

        private async void GenerateTtsButton_Click(object sender, RoutedEventArgs e)
        {
            if (_isTtsPlaying)
            {
                await _ttsAudioPlayer.Stop();
                _ttsProgressTimer.Stop();
                _isTtsPlaying = false;
            }
            TtsPlaybackControlsPanel.Visibility = Visibility.Collapsed;

            // Kiểm tra xem có dòng subtitle từ timeline được chọn không
            if (_pendingTimelineSubtitlesForTts != null && _pendingTimelineSubtitlesForTts.Any())
            {
                // Tạo TTS từ các dòng timeline đã chọn
                await GenerateTtsFromTimelineSubtitles();
                return;
            }

            // Logic cũ: Tạo TTS từ TtsInputTextBox
            string textToVoice = TtsInputTextBox.Text;
            if (string.IsNullOrWhiteSpace(textToVoice))
            {
                CustomMessageBox.Show("Vui lòng nhập văn bản cần tạo giọng nói hoặc chọn các dòng phụ đề từ timeline.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            if (AioLanguageComboBox.SelectedValue == null || AioVoiceComboBox.SelectedValue == null)
            {
                CustomMessageBox.Show("Vui lòng chọn đầy đủ Ngôn ngữ và Giọng nói.", "Thiếu thông tin", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            string language = AioLanguageComboBox.SelectedValue.ToString();
            string voiceId = AioVoiceComboBox.SelectedValue.ToString();
            string modelId = AioModelComboBox.SelectedValue?.ToString() ?? "all";
            double rate = AioRateSlider.Value;
            string optimizedText = OptimizeTextForTts(textToVoice);
            int totalBytes = Encoding.UTF8.GetByteCount(optimizedText);
            int characterCount = optimizedText.Length;

            // Kiểm tra character limit chỉ khi không sử dụng CapCut
            if (modelId != "CapCut")
            {
                await App.User.RefreshProfileAsync();
                long remainingChars = App.User.TtsCharacterLimit - App.User.TtsCharactersUsed;

                if (characterCount > remainingChars)
                {
                    CustomMessageBox.Show($"Số ký tự văn bản ({characterCount:N0}) vượt quá giới hạn còn lại của bạn ({remainingChars:N0}).", "Không đủ ký tự", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }
            }
            else
            {
                // Kiểm tra quyền CapCut Voice khi sử dụng CapCut model
                await App.User.RefreshProfileAsync();
                if (!App.User.AllowedApiAccess.HasFlag(AllowedApis.Capcutvoice))
                {
                    CustomMessageBox.Show("Bạn không có quyền sử dụng CapCut Voice. Vui lòng liên hệ admin để được cấp quyền.", "Không có quyền truy cập", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }
            }

            GenerateTtsButton.IsEnabled = false;
            GenerateTtsButton.Content = "Đang tạo...";
            LoadingOverlay.Visibility = Visibility.Visible;

            try
            {
                byte[] finalAudioData = null;

                // Sử dụng CapCut TTS nếu chọn model CapCut
                if (modelId == "CapCut")
                {
                    GenerateTtsButton.Content = "Đang tạo (CapCut)...";
                    var result = await CapCutTtsService.CreateTtsAsync(optimizedText, voiceId);

                    if (result.Success && result.AudioData != null)
                    {
                        finalAudioData = result.AudioData;
                    }
                    else
                    {
                        throw new Exception($"Tạo âm thanh CapCut thất bại: {result.ErrorMessage}");
                    }
                }
                // Sử dụng Google TTS API
                else if (totalBytes <= TTS_CHUNK_TRIGGER_BYTES)
                {
                    GenerateTtsButton.Content = "Đang tạo (1/1)...";
                    var (success, audioData, errorMessage) = await ApiService.GenerateAioTtsAsync(language, voiceId, rate, optimizedText);

                    if (success && audioData != null)
                    {
                        finalAudioData = audioData;
                    }
                    else
                    {
                        throw new Exception($"Tạo âm thanh thất bại: {errorMessage}");
                    }
                }
                else
                {
                    List<string> textChunks = SplitTextIntoChunks(optimizedText, TTS_CHUNK_TRIGGER_BYTES, TTS_CHUNK_TARGET_BYTES);
                    var allAudioChunks = new List<byte[]>();
                    int totalChunks = textChunks.Count;

                    for (int i = 0; i < totalChunks; i++)
                    {
                        GenerateTtsButton.Content = $"Đang tạo ({i + 1}/{totalChunks})...";
                        string chunk = textChunks[i];
                        var (success, audioData, errorMessage) = await ApiService.GenerateAioTtsAsync(language, voiceId, rate, chunk);

                        if (success && audioData != null)
                        {
                            allAudioChunks.Add(audioData);
                        }
                        else
                        {
                            throw new Exception($"Tạo âm thanh cho chunk {i + 1} thất bại: {errorMessage}");
                        }
                    }
                    if (allAudioChunks.Count > 0)
                    {
                        GenerateTtsButton.Content = "Đang ghép âm thanh...";
                        finalAudioData = await ConcatenateAudioChunksAsync(allAudioChunks);
                    }
                }

                if (finalAudioData != null)
                {
                    // Refresh profile chỉ khi sử dụng Google TTS (có character limit)
                    if (modelId != "CapCut")
                    {
                        await App.User.RefreshProfileAsync();
                    }
                    TtsInputTextBox_TextChanged(null, null);

                    _currentTtsAudioPath = TempFileManager.CreateTempFile(".mp3");
                    await File.WriteAllBytesAsync(_currentTtsAudioPath, finalAudioData);

                    await _ttsAudioPlayer.Open(new Uri(_currentTtsAudioPath));
                    await _ttsAudioPlayer.Play();
                }
                else
                {
                    CustomMessageBox.Show("Không nhận được dữ liệu âm thanh sau khi xử lý.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Đã xảy ra lỗi không mong muốn: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                GenerateTtsButton.IsEnabled = true;
                GenerateTtsButton.Content = "Tạo Âm Thanh";
                LoadingOverlay.Visibility = Visibility.Collapsed;
            }
        }

        /// <summary>
        /// Tạo TTS từ các dòng subtitle đã chọn từ timeline
        /// </summary>
        private async Task GenerateTtsFromTimelineSubtitles()
        {
            var linesToVoice = _pendingTimelineSubtitlesForTts;

            // Clear pending subtitles
            _pendingTimelineSubtitlesForTts = null;

            if (linesToVoice == null || !linesToVoice.Any())
            {
                CustomMessageBox.Show("Không có dòng phụ đề nào để tạo giọng nói.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            // Kiểm tra đã chọn voice chưa
            if (AioLanguageComboBox.SelectedValue == null || AioVoiceComboBox.SelectedValue == null)
            {
                // Khôi phục lại pending subtitles nếu chưa chọn voice
                _pendingTimelineSubtitlesForTts = linesToVoice;
                CustomMessageBox.Show("Vui lòng chọn đầy đủ Ngôn ngữ và Giọng nói trong tab Text to Speech.", "Thiếu thông tin", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            string voiceId = AioVoiceComboBox.SelectedValue.ToString();
            string modelId = AioModelComboBox.SelectedValue?.ToString() ?? "all";

            // Dựa vào model đã chọn để gọi hàm tương ứng
            if (modelId == "CapCut")
            {
                // Gọi hàm tạo TTS bằng CapCut
                await GenerateVoiceForSrtLinesUsingCapCut(linesToVoice, voiceId);
            }
            else
            {
                // Gọi hàm tạo TTS bằng API Server
                await GenerateVoiceForSrtLines(linesToVoice);
            }
        }

        private string OptimizeTextForTts(string text)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(text))
                {
                    return string.Empty;
                }
                string trimmedText = text.Trim();
                string baseCleanedText = Regex.Replace(trimmedText, @"\s+", " ");
                const int MAX_CHARS_WITHOUT_PUNCTUATION = 220;
                var finalResultBuilder = new StringBuilder();
                var sentences = Regex.Split(baseCleanedText, @"(?<=[.?!…])\s*");

                foreach (var sentence in sentences)
                {
                    if (string.IsNullOrWhiteSpace(sentence)) continue;

                    if (sentence.Length <= MAX_CHARS_WITHOUT_PUNCTUATION)
                    {
                        finalResultBuilder.Append(sentence).Append(" ");
                    }
                    else
                    {
                        string remainingSentence = sentence;

                        while (remainingSentence.Length > MAX_CHARS_WITHOUT_PUNCTUATION)
                        {
                            int breakPosition = remainingSentence.LastIndexOf(' ', MAX_CHARS_WITHOUT_PUNCTUATION);
                            if (breakPosition <= 0)
                            {
                                breakPosition = MAX_CHARS_WITHOUT_PUNCTUATION;
                            }

                            finalResultBuilder.Append(remainingSentence.Substring(0, breakPosition)).Append(". ");
                            remainingSentence = remainingSentence.Substring(breakPosition).TrimStart();
                        }
                        if (!string.IsNullOrWhiteSpace(remainingSentence))
                        {
                            finalResultBuilder.Append(remainingSentence).Append(" ");
                        }
                    }
                }
                string finalResult = finalResultBuilder.ToString().Trim();
                string textWithoutQuotes = finalResult
                    .Replace("\"", "")
                    .Replace("'", "")
                    .Replace("“", "")
                    .Replace("”", "")
                    .Replace("‘", "")
                    .Replace("’", "");


                return textWithoutQuotes;
            }
            catch (Exception ex)
            {
                return text?.Trim() ?? string.Empty;
            }
        }
        private List<string> SplitTextIntoChunks(string text, int maxBytes, int targetBytes)
        {
            var chunks = new List<string>();
            if (string.IsNullOrWhiteSpace(text))
            {
                return chunks;
            }
            var currentChunk = new StringBuilder();
            var sentences = Regex.Split(text, @"(?<=[.?!…])\s*");
            foreach (var sentence in sentences)
            {
                if (string.IsNullOrWhiteSpace(sentence)) continue;
                var sentenceBytes = Encoding.UTF8.GetByteCount(sentence);
                var currentChunkBytes = Encoding.UTF8.GetByteCount(currentChunk.ToString());
                if (sentenceBytes > maxBytes)
                {
                    if (currentChunk.Length > 0)
                    {
                        chunks.Add(currentChunk.ToString().Trim());
                        currentChunk.Clear();
                    }

                    var words = sentence.Split(' ');
                    var wordChunk = new StringBuilder();
                    foreach (var word in words)
                    {
                        var wordWithSpace = word + " ";
                        if (Encoding.UTF8.GetByteCount(wordChunk.ToString() + wordWithSpace) > maxBytes)
                        {
                            chunks.Add(wordChunk.ToString().Trim());
                            wordChunk.Clear();
                        }
                        wordChunk.Append(wordWithSpace);
                    }
                    if (wordChunk.Length > 0)
                    {
                        chunks.Add(wordChunk.ToString().Trim());
                    }
                    continue;
                }
                if (currentChunk.Length > 0 &&
                    (currentChunkBytes + sentenceBytes > maxBytes || currentChunkBytes > targetBytes))
                {
                    chunks.Add(currentChunk.ToString().Trim());
                    currentChunk.Clear();
                    currentChunkBytes = 0;
                }
                currentChunk.Append(sentence);
            }
            if (currentChunk.Length > 0)
            {
                chunks.Add(currentChunk.ToString().Trim());
            }
            return chunks;
        }
        private async Task<byte[]> ConcatenateAudioChunksAsync(List<byte[]> audioChunks)
        {
            if (audioChunks == null || audioChunks.Count == 0) return null;
            if (audioChunks.Count == 1) return audioChunks[0];

            var tempFilePaths = new List<string>();
            string tempDir = TempFileManager.CreateTempDirectory();
            string outputPath = Path.Combine(tempDir, "output.mp3");

            try
            {
                for (int i = 0; i < audioChunks.Count; i++)
                {
                    string tempFilePath = Path.Combine(tempDir, $"chunk_{i}.mp3");
                    await File.WriteAllBytesAsync(tempFilePath, audioChunks[i]);
                    tempFilePaths.Add(tempFilePath);
                }
                bool success = await FFMpegArguments
                    .FromConcatInput(tempFilePaths)
                    .OutputToFile(outputPath, true, options => options
                        .CopyChannel(Channel.Audio))
                    .ProcessAsynchronously();
                if (success && File.Exists(outputPath))
                {
                    byte[] resultData = await File.ReadAllBytesAsync(outputPath);
                    if (resultData.Length > 0)
                    {
                        return resultData;
                    }
                    else
                    {
                        return null;
                    }
                }
                return null;
            }
            catch (Exception ex)
            {
                return null;
            }
            finally
            {
                try
                {
                    if (Directory.Exists(tempDir))
                    {
                        Directory.Delete(tempDir, true);
                    }
                }
                catch (Exception ex) { }
            }
        }
        private async void GenerateVoiceSubButton_Click(object sender, RoutedEventArgs e)
        {
            var linesToVoice = SrtLinesDataGrid.SelectedItems.Cast<SrtSubtitleLine>().ToList();
            if (!linesToVoice.Any())
            {
                linesToVoice = SrtSubtitleLinesView.ToList();
            }

            if (!linesToVoice.Any())
            {
                CustomMessageBox.Show("Không có dòng phụ đề nào để tạo giọng nói.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            // Lưu các dòng đã chọn vào biến global
            _pendingTimelineSubtitlesForTts = linesToVoice;

            // Chuyển sang tab Text to Speech
            TtsTab.IsChecked = true;
        }
        private async void CreateVoice_Click(object sender, RoutedEventArgs e)
        {
            var selectedClips = TimelineClips
                .Where(c => c.IsSelected && (c.ClipType == TimelineClipType.Text || c.ClipType == TimelineClipType.Subtitle))
                .ToList();

            var linesToVoice = selectedClips
                .Select(c => c.SourceData as SrtSubtitleLine)
                .Where(s => s != null)
                .ToList();

            if (!linesToVoice.Any())
            {
                CustomMessageBox.Show("Hãy chọn các clip phụ đề trên timeline để tạo voice.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            // Lưu các dòng đã chọn vào biến global
            _pendingTimelineSubtitlesForTts = linesToVoice;

            // Chuyển sang tab Text to Speech
            TtsTab.IsChecked = true;
        }

        // Legacy function - kept for backward compatibility but replaced by new flow
        private async void CreateVoice_Click_Legacy(object sender, RoutedEventArgs e)
        {
            var selectedClips = TimelineClips
                .Where(c => c.IsSelected && (c.ClipType == TimelineClipType.Text || c.ClipType == TimelineClipType.Subtitle))
                .ToList();

            var linesToVoice = selectedClips
                .Select(c => c.SourceData as SrtSubtitleLine)
                .Where(s => s != null)
                .ToList();

            string sourceTextChoice = "Original";
            bool hasTranslatedText = linesToVoice.Any(l => !string.IsNullOrWhiteSpace(l.TranslatedText));
            if (hasTranslatedText)
            {
                var result = CustomMessageBox.Show(
                    "Bạn muốn tạo giọng nói từ 'Văn bản gốc' hay 'Bản dịch'?\n\n- Chọn 'Yes' để dùng VĂN BẢN GỐC.\n- Chọn 'No' để dùng BẢN DỊCH.",
                    "Chọn nguồn văn bản",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Question);
                if (result == MessageBoxResult.No) sourceTextChoice = "Translated";
            }
            if (AioLanguageComboBox.SelectedValue == null || AioVoiceComboBox.SelectedValue == null)
            {
                CustomMessageBox.Show("Vui lòng chọn đầy đủ Ngôn ngữ và Giọng nói trong tab Text to Speech.", "Thiếu thông tin", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            string language = AioLanguageComboBox.SelectedValue.ToString();
            string voiceId = AioVoiceComboBox.SelectedValue.ToString();
            double rate = AioRateSlider.Value;

            string srtContent = SrtFileUtils.GenerateSrtContent(linesToVoice, sourceTextChoice == "Translated");
            long totalCharacterCount = srtContent.Length;

            await App.User.RefreshProfileAsync();
            long remainingChars = App.User.TtsCharacterLimit - App.User.TtsCharactersUsed;
            if (totalCharacterCount > remainingChars)
            {
                CustomMessageBox.Show(
                    $"Tổng số ký tự của các dòng đã chọn ({totalCharacterCount:N0}) vượt quá giới hạn còn lại ({remainingChars:N0}).",
                    "Không đủ ký tự",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
                return;
            }

            LoadingOverlay.Visibility = Visibility.Visible;
            var generateButton = GenerateVoiceSubButton;
            generateButton.IsEnabled = false;
            generateButton.Content = "Bắt đầu.";

            try
            {
                var (startSuccess, jobId, startError) =
                    await ApiService.StartAioTtsBatchJobAsync(srtContent, language, voiceId, rate);
                if (!startSuccess) throw new Exception($"Không thể bắt đầu tác vụ: {startError}");
                generateButton.Content = "Đang xử lý.";
                AioTtsBatchJobStatus currentStatus;
                while (true)
                {
                    await Task.Delay(3000);
                    var (statusSuccess, status, statusError) = await ApiService.GetAioTtsBatchJobStatusAsync(jobId);
                    if (!statusSuccess) throw new Exception($"Mất kết nối khi kiểm tra trạng thái: {statusError}");
                    currentStatus = status;
                    generateButton.Content = $"Đang xử lý. ({currentStatus.ProcessedLines}/{currentStatus.TotalLines})";
                    if (currentStatus.Status == "Completed" || currentStatus.Status == "Failed") break;
                }
                if (currentStatus.Status == "Failed")
                    throw new Exception($"Tác vụ thất bại trên server: {currentStatus.ErrorMessage}");
                generateButton.Content = "Đang tải kết quả.";
                var (downloadSuccess, zipData, downloadError) = await ApiService.DownloadAioTtsBatchResultAsync(jobId);
                if (!downloadSuccess) throw new Exception($"Không thể tải kết quả: {downloadError}");
                generateButton.Content = "Đang xử lý.";
                string projectsRootFolder = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Projects");
                string ttsProjectFolder = Path.Combine(projectsRootFolder, "TTS", _currentProject.ProjectName, DateTime.Now.ToString("yyyyMMdd_HHmmss_fff"));
                Directory.CreateDirectory(ttsProjectFolder);
                using (var stream = new MemoryStream(zipData))
                using (var archive = new ZipArchive(stream))
                {
                    archive.ExtractToDirectory(ttsProjectFolder, true);
                }
                var audioFiles = Directory
    .GetFiles(ttsProjectFolder, "*.*", SearchOption.AllDirectories)
    .Where(f =>
        f.EndsWith(".mp3", StringComparison.OrdinalIgnoreCase) ||
        f.EndsWith(".wav", StringComparison.OrdinalIgnoreCase) ||
        f.EndsWith(".m4a", StringComparison.OrdinalIgnoreCase))
    .ToList();

                if (!audioFiles.Any())
                    throw new Exception("Không tìm thấy file âm thanh nào trong gói trả về.");

                var linesByIndex = linesToVoice.ToDictionary(l => l.Index);
                var audioPathByIndex = new Dictionary<int, string>();
                const double timeToleranceMs = 300.0;

                var newClipViewModels = new List<TimelineClipViewModel>();
                int matchedCount = 0;

                foreach (var audioFile in audioFiles)
                {
                    string fileName = Path.GetFileNameWithoutExtension(audioFile);
                    var parts = fileName.Split('_');
                    if (parts.Length < 3) continue;

                    if (!int.TryParse(parts[0], NumberStyles.Integer, CultureInfo.InvariantCulture, out int idx))
                        continue;

                    SrtSubtitleLine lineToUpdate = null;
                    if (!linesByIndex.TryGetValue(idx, out lineToUpdate))
                    {
                        if (long.TryParse(parts[1], NumberStyles.Integer, CultureInfo.InvariantCulture, out long startMs) &&
                            long.TryParse(parts[2], NumberStyles.Integer, CultureInfo.InvariantCulture, out long endMs))
                        {
                            var startT = TimeSpan.FromMilliseconds(startMs);
                            var endT = TimeSpan.FromMilliseconds(endMs);

                            lineToUpdate = linesToVoice.FirstOrDefault(l =>
                                Math.Abs((l.StartTime - startT).TotalMilliseconds) <= timeToleranceMs &&
                                Math.Abs((l.EndTime - endT).TotalMilliseconds) <= timeToleranceMs);
                        }
                    }

                    if (lineToUpdate == null) continue;

                    var mediaInfo = await FFProbe.AnalyseAsync(audioFile);
                    if (mediaInfo?.PrimaryAudioStream == null && mediaInfo?.Duration == TimeSpan.Zero) continue;

                    var newAudioClip = new TimelineAudioClip
                    {
                        FilePath = audioFile,
                        StartTime = lineToUpdate.StartTime,
                        OriginalDuration = mediaInfo.Duration,
                        TrimStartOffset = TimeSpan.Zero,
                        TrimEndOffset = TimeSpan.Zero,
                        SourceSubtitleIndexSnapshot = lineToUpdate.Index,
                        CaptionTextSnapshot = lineToUpdate.OriginalText
                    };

                    _currentProject.VoicedSubtitles.Add(newAudioClip);
                    TimelineAudioClips.Add(newAudioClip);
                    QueueWaveformGeneration(newAudioClip);

                    var newClipVM = new TimelineClipViewModel(newAudioClip);
                    TimelineClips.Add(newClipVM);
                    newClipViewModels.Add(newClipVM);

                    lineToUpdate.VoicedAudioPath = audioFile;
                    lineToUpdate.IsVoiced = true;
                    audioPathByIndex[lineToUpdate.Index] = audioFile;
                    matchedCount++;
                }
                await WriteTtsSmartCutManifestAsync(ttsProjectFolder, linesToVoice, audioPathByIndex, _currentSrtFilePath);
                if (newClipViewModels.Any())
                {
                    AssignAudioClipsToIntelligentTracks(newClipViewModels);
                    RecalculateTotalDuration();
                    UpdateTimelineScaleAndRender();
                    _undoRedoService.AddState(CaptureEditorSnapshot());
                    SaveProjectCurrent();
                }
                await App.User.RefreshProfileAsync();
                TtsInputTextBox_TextChanged(null, null);
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Đã xảy ra lỗi trong quá trình tạo Voice Sub:\n\n{ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                generateButton.IsEnabled = true;
                generateButton.Content = "Tạo Voice Sub";
                LoadingOverlay.Visibility = Visibility.Collapsed;
            }
        }

        private async Task GenerateVoiceForSrtLines(List<SrtSubtitleLine> linesToVoice)
        {
            if (linesToVoice == null || !linesToVoice.Any())
            {
                CustomMessageBox.Show("Không có dòng phụ đề nào hợp lệ để tạo giọng nói.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }
            string sourceTextChoice = "Original";
            bool hasTranslatedText = linesToVoice.Any(l => !string.IsNullOrWhiteSpace(l.TranslatedText));
            if (hasTranslatedText)
            {
                var result = CustomMessageBox.Show(
                    "Bạn muốn tạo giọng nói từ 'Văn bản gốc' hay 'Bản dịch'?\n\n- Chọn 'Yes' để dùng VĂN BẢN GỐC.\n- Chọn 'No' để dùng BẢN DỊCH.",
                    "Chọn nguồn văn bản",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Question);
                if (result == MessageBoxResult.No) sourceTextChoice = "Translated";
            }

            if (AioLanguageComboBox.SelectedValue == null || AioVoiceComboBox.SelectedValue == null)
            {
                CustomMessageBox.Show("Vui lòng chọn đầy đủ Ngôn ngữ và Giọng nói trong tab Text to Speech.", "Thiếu thông tin", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            string language = AioLanguageComboBox.SelectedValue.ToString();
            string voiceId = AioVoiceComboBox.SelectedValue.ToString();
            double rate = AioRateSlider.Value;
            string srtContent = SrtFileUtils.GenerateSrtContent(linesToVoice, sourceTextChoice == "Translated");
            long totalCharacterCount = srtContent.Length;
            await App.User.RefreshProfileAsync();
            long remainingChars = App.User.TtsCharacterLimit - App.User.TtsCharactersUsed;
            if (totalCharacterCount > remainingChars)
            {
                CustomMessageBox.Show(
                    $"Tổng số ký tự của các dòng đã chọn ({totalCharacterCount:N0}) vượt quá giới hạn còn lại ({remainingChars:N0}).",
                    "Không đủ ký tự",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
                return;
            }

            LoadingOverlay.Visibility = Visibility.Visible;
            var generateButton = TtsModeVoiceSubRadio.IsChecked == true ? GenerateVoiceSubButton : GenerateTtsButton;
            generateButton.IsEnabled = false;
            generateButton.Content = "Bắt đầu.";

            try
            {
                var (startSuccess, jobId, startError) =
                    await ApiService.StartAioTtsBatchJobAsync(srtContent, language, voiceId, rate);
                if (!startSuccess) throw new Exception($"Không thể bắt đầu tác vụ: {startError}");
                generateButton.Content = "Đang xử lý.";
                AioTtsBatchJobStatus currentStatus;
                while (true)
                {
                    await Task.Delay(3000);
                    var (statusSuccess, status, statusError) = await ApiService.GetAioTtsBatchJobStatusAsync(jobId);
                    if (!statusSuccess) throw new Exception($"Mất kết nối khi kiểm tra trạng thái: {statusError}");
                    currentStatus = status;
                    generateButton.Content = $"Đang xử lý. ({currentStatus.ProcessedLines}/{currentStatus.TotalLines})";
                    if (currentStatus.Status == "Completed" || currentStatus.Status == "Failed") break;
                }
                if (currentStatus.Status == "Failed")
                    throw new Exception($"Tác vụ thất bại trên server: {currentStatus.ErrorMessage}");
                generateButton.Content = "Đang tải kết quả.";
                var (downloadSuccess, zipData, downloadError) = await ApiService.DownloadAioTtsBatchResultAsync(jobId);
                if (!downloadSuccess) throw new Exception($"Không thể tải kết quả: {downloadError}");
                generateButton.Content = "Đang xử lý.";
                string projectsRootFolder = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Projects");
                string ttsProjectFolder = Path.Combine(projectsRootFolder, "TTS", _currentProject.ProjectName, DateTime.Now.ToString("yyyyMMdd_HHmmss_fff"));
                Directory.CreateDirectory(ttsProjectFolder);
                using (var stream = new MemoryStream(zipData))
                using (var archive = new ZipArchive(stream))
                {
                    archive.ExtractToDirectory(ttsProjectFolder, true);
                }
                var audioFiles = Directory
    .GetFiles(ttsProjectFolder, "*.*", SearchOption.AllDirectories)
    .Where(f =>
        f.EndsWith(".mp3", StringComparison.OrdinalIgnoreCase) ||
        f.EndsWith(".wav", StringComparison.OrdinalIgnoreCase) ||
        f.EndsWith(".m4a", StringComparison.OrdinalIgnoreCase))
    .ToList();

                if (!audioFiles.Any())
                    throw new Exception("Không tìm thấy file âm thanh nào trong gói trả về.");

                var linesByIndex = linesToVoice.ToDictionary(l => l.Index);
                var audioPathByIndex = new Dictionary<int, string>();
                const double timeToleranceMs = 300.0;

                var newClipViewModels = new List<TimelineClipViewModel>();
                int matchedCount = 0;

                foreach (var audioFile in audioFiles)
                {
                    string fileName = Path.GetFileNameWithoutExtension(audioFile);
                    var parts = fileName.Split('_');
                    if (parts.Length < 3) continue;

                    if (!int.TryParse(parts[0], NumberStyles.Integer, CultureInfo.InvariantCulture, out int idx))
                        continue;

                    SrtSubtitleLine lineToUpdate = null;
                    if (!linesByIndex.TryGetValue(idx, out lineToUpdate))
                    {
                        if (long.TryParse(parts[1], NumberStyles.Integer, CultureInfo.InvariantCulture, out long startMs) &&
                            long.TryParse(parts[2], NumberStyles.Integer, CultureInfo.InvariantCulture, out long endMs))
                        {
                            var startT = TimeSpan.FromMilliseconds(startMs);
                            var endT = TimeSpan.FromMilliseconds(endMs);

                            lineToUpdate = linesToVoice.FirstOrDefault(l =>
                                Math.Abs((l.StartTime - startT).TotalMilliseconds) <= timeToleranceMs &&
                                Math.Abs((l.EndTime - endT).TotalMilliseconds) <= timeToleranceMs);
                        }
                    }

                    if (lineToUpdate == null) continue;

                    var mediaInfo = await FFProbe.AnalyseAsync(audioFile);
                    if (mediaInfo?.PrimaryAudioStream == null && mediaInfo?.Duration == TimeSpan.Zero) continue;

                    var newAudioClip = new TimelineAudioClip
                    {
                        FilePath = audioFile,
                        StartTime = lineToUpdate.StartTime,
                        OriginalDuration = mediaInfo.Duration,
                        TrimStartOffset = TimeSpan.Zero,
                        TrimEndOffset = TimeSpan.Zero,
                        SourceSubtitleIndexSnapshot = lineToUpdate.Index,
                        CaptionTextSnapshot = lineToUpdate.OriginalText
                    };
                    _currentProject.VoicedSubtitles.Add(newAudioClip);
                    TimelineAudioClips.Add(newAudioClip);
                    QueueWaveformGeneration(newAudioClip);
                    var newClipVM = new TimelineClipViewModel(newAudioClip);
                    TimelineClips.Add(newClipVM);
                    newClipViewModels.Add(newClipVM);
                    lineToUpdate.VoicedAudioPath = audioFile;
                    lineToUpdate.IsVoiced = true;
                    audioPathByIndex[lineToUpdate.Index] = audioFile;
                    matchedCount++;
                }
                await WriteTtsSmartCutManifestAsync(ttsProjectFolder, linesToVoice, audioPathByIndex, _currentSrtFilePath);
                if (newClipViewModels.Any())
                {
                    AssignAudioClipsToIntelligentTracks(newClipViewModels);
                    RecalculateTotalDuration();
                    UpdateTimelineScaleAndRender();
                    _undoRedoService.AddState(CaptureEditorSnapshot());
                    SaveProjectCurrent();
                }

                await App.User.RefreshProfileAsync();
                TtsInputTextBox_TextChanged(null, null);
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Đã xảy ra lỗi trong quá trình tạo Voice Sub:\n\n{ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                generateButton.IsEnabled = true;
                generateButton.Content = "Tạo Voice Sub";
                LoadingOverlay.Visibility = Visibility.Collapsed;
            }
        }

        /// <summary>
        /// Tạo Voice Sub sử dụng CapCut TTS API (local, không qua server)
        /// Voice ID sẽ tự động chuyển đổi vi/Vi sang Vy/VY
        /// </summary>
        private async Task GenerateVoiceForSrtLinesUsingCapCut(List<SrtSubtitleLine> linesToVoice, string voiceId)
        {
            if (linesToVoice == null || !linesToVoice.Any())
            {
                CustomMessageBox.Show("Không có dòng phụ đề nào hợp lệ để tạo giọng nói.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            // Voice ID được truyền từ AioVoiceComboBox (đã chọn trong tab TTS)

            // Hỏi nguồn text
            string sourceTextChoice = "Original";
            bool hasTranslatedText = linesToVoice.Any(l => !string.IsNullOrWhiteSpace(l.TranslatedText));
            if (hasTranslatedText)
            {
                var result = CustomMessageBox.Show(
                    "Bạn muốn tạo giọng nói từ 'Văn bản gốc' hay 'Bản dịch'?\n\n- Chọn 'Yes' để dùng VĂN BẢN GỐC.\n- Chọn 'No' để dùng BẢN DỊCH.",
                    "Chọn nguồn văn bản",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Question);
                if (result == MessageBoxResult.No) sourceTextChoice = "Translated";
            }

            LoadingOverlay.Visibility = Visibility.Visible;
            var generateButton = TtsModeVoiceSubRadio.IsChecked == true ? GenerateVoiceSubButton : GenerateTtsButton;
            generateButton.IsEnabled = false;
            generateButton.Content = "Đang tạo...";

            try
            {
                // Tạo thư mục lưu TTS
                string projectsRootFolder = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Projects");
                string ttsProjectFolder = Path.Combine(projectsRootFolder, "TTS_CapCut", _currentProject.ProjectName, DateTime.Now.ToString("yyyyMMdd_HHmmss_fff"));
                Directory.CreateDirectory(ttsProjectFolder);

                // Chuẩn bị danh sách text để tạo TTS
                var textsToProcess = new List<string>();
                var lineMapping = new Dictionary<int, SrtSubtitleLine>(); // index in textsToProcess -> SrtSubtitleLine

                for (int i = 0; i < linesToVoice.Count; i++)
                {
                    var line = linesToVoice[i];
                    string textToVoice = sourceTextChoice == "Translated" && !string.IsNullOrWhiteSpace(line.TranslatedText)
                        ? line.TranslatedText
                        : line.OriginalText;

                    textsToProcess.Add(textToVoice);
                    lineMapping[i] = line;
                }

                // Tạo progress reporter
                var progress = new Progress<(int completed, int total)>(p =>
                {
                    Dispatcher.Invoke(() =>
                    {
                        generateButton.Content = $"Đang tạo ({p.completed}/{p.total})...";
                    });
                });

                // Gọi CapCut TTS batch
                generateButton.Content = $"Đang tạo (0/{textsToProcess.Count})...";
                var results = await CapCutTtsService.CreateTtsBatchAsync(
                    textsToProcess,
                    voiceId,
                    maxConcurrency: 10, // Có thể điều chỉnh số luồng đồng thời
                    retries: 3,
                    delaySeconds: 1,
                    progress: progress);

                // Lưu các file MP3 thành công
                var audioPathByIndex = new Dictionary<int, string>();
                var newClipViewModels = new List<TimelineClipViewModel>();
                int successCount = 0;
                int failedCount = 0;
                var failedLines = new List<(int Index, string Text, string Error)>();

                for (int i = 0; i < results.Count; i++)
                {
                    var result = results[i];
                    if (!result.Success)
                    {
                        failedCount++;
                        if (lineMapping.TryGetValue(i, out var failedLine))
                        {
                            string truncatedText = failedLine.OriginalText?.Length > 50 
                                ? failedLine.OriginalText.Substring(0, 50) + "..." 
                                : failedLine.OriginalText;
                            failedLines.Add((failedLine.Index, truncatedText, result.ErrorMessage));
                        }
                        continue;
                    }

                    if (!lineMapping.TryGetValue(i, out var line))
                        continue;

                    // Tạo tên file: {index}_{startMs}_{endMs}.mp3
                    long startMs = (long)line.StartTime.TotalMilliseconds;
                    long endMs = (long)line.EndTime.TotalMilliseconds;
                    string fileName = $"{line.Index}_{startMs}_{endMs}.mp3";
                    string filePath = Path.Combine(ttsProjectFolder, fileName);

                    // Lưu file
                    await File.WriteAllBytesAsync(filePath, result.AudioData);

                    // Phân tích thông tin audio
                    var mediaInfo = await FFProbe.AnalyseAsync(filePath);
                    if (mediaInfo?.Duration == TimeSpan.Zero)
                    {
                        failedCount++;
                        string truncatedText = line.OriginalText?.Length > 50 
                            ? line.OriginalText.Substring(0, 50) + "..." 
                            : line.OriginalText ?? "";
                        failedLines.Add((line.Index, truncatedText, "Audio duration is zero"));
                        continue;
                    }

                    // Tạo audio clip
                    var newAudioClip = new TimelineAudioClip
                    {
                        FilePath = filePath,
                        StartTime = line.StartTime,
                        OriginalDuration = mediaInfo.Duration,
                        TrimStartOffset = TimeSpan.Zero,
                        TrimEndOffset = TimeSpan.Zero,
                        SourceSubtitleIndexSnapshot = line.Index,
                        CaptionTextSnapshot = line.OriginalText
                    };

                    _currentProject.VoicedSubtitles.Add(newAudioClip);
                    TimelineAudioClips.Add(newAudioClip);
                    QueueWaveformGeneration(newAudioClip);

                    var newClipVM = new TimelineClipViewModel(newAudioClip);
                    TimelineClips.Add(newClipVM);
                    newClipViewModels.Add(newClipVM);

                    line.VoicedAudioPath = filePath;
                    line.IsVoiced = true;
                    audioPathByIndex[line.Index] = filePath;
                    successCount++;
                }

                // Lưu manifest
                await WriteTtsSmartCutManifestAsync(ttsProjectFolder, linesToVoice, audioPathByIndex, _currentSrtFilePath);

                // Cập nhật UI
                if (newClipViewModels.Any())
                {
                    AssignAudioClipsToIntelligentTracks(newClipViewModels);
                    RecalculateTotalDuration();
                    UpdateTimelineScaleAndRender();
                    _undoRedoService.AddState(CaptureEditorSnapshot());
                    SaveProjectCurrent();
                }

                // Hiển thị kết quả cuối cùng
                if (failedCount > 0)
                {
                    var sb = new StringBuilder();
                    sb.AppendLine($"✓ Tạo thành công: {successCount}/{textsToProcess.Count} voice(s)");
                    sb.AppendLine($"✗ Thất bại: {failedCount} voice(s)");
                    sb.AppendLine();
                    sb.AppendLine("Các dòng bị lỗi (đã retry nhiều lần với các session khác nhau):");
                    
                    // Chỉ hiển thị tối đa 10 dòng lỗi
                    int displayCount = Math.Min(failedLines.Count, 10);
                    for (int i = 0; i < displayCount; i++)
                    {
                        var failed = failedLines[i];
                        sb.AppendLine($"  - Dòng {failed.Index}: \"{failed.Text}\"");
                    }
                    if (failedLines.Count > 10)
                    {
                        sb.AppendLine($"  ... và {failedLines.Count - 10} dòng khác");
                    }

                    CustomMessageBox.Show(sb.ToString(), "Kết quả tạo Voice CapCut", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
                else
                {
                    CustomMessageBox.Show($"✓ Đã tạo thành công {successCount} voice(s)!\n\nTất cả voice đã được thêm vào timeline.", "Hoàn thành", MessageBoxButton.OK, MessageBoxImage.Information);
                }
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Đã xảy ra lỗi trong quá trình tạo Voice Sub bằng CapCut:\n\n{ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                generateButton.IsEnabled = true;
                generateButton.Content = "Tạo Voice Sub";
                LoadingOverlay.Visibility = Visibility.Collapsed;
            }
        }

        private void PlayVoicedLine_Click(object sender, RoutedEventArgs e)
        {
            if (sender is Button btn && btn.DataContext is SrtSubtitleLine line)
            {
                if (!string.IsNullOrEmpty(line.VoicedAudioPath) && File.Exists(line.VoicedAudioPath))
                {
                    _currentTtsAudioPath = line.VoicedAudioPath;
                    _ttsAudioPlayer.Play();
                    _isTtsPlaying = true;
                    TtsPlayPauseButton.Content = "\uE769";
                    TtsTab.IsChecked = true;
                }
            }
        }

        private void TtsAudioPlayer_MediaOpened(object sender, Unosquare.FFME.Common.MediaOpenedEventArgs e)
        {
            if (_ttsAudioPlayer.NaturalDuration.HasValue)
            {
                TtsProgressSlider.Maximum = _ttsAudioPlayer.NaturalDuration.Value.TotalSeconds;
                _isTtsPlaying = true;
                TtsPlayPauseButton.Content = "";
                TtsPlaybackControlsPanel.Visibility = Visibility.Visible;
                TtsPlayPauseButton.IsEnabled = true;
                TtsProgressSlider.IsEnabled = true;
                _ttsProgressTimer.Start();
            }
        }
        private void VoiceItem_MouseEnter(object sender, MouseEventArgs e)
        {
            if (sender is FrameworkElement element && element.DataContext is TtsVoice voice)
            {
                audioPreviewPlayer.Stop();

                string displayName = voice.DisplayName;
                string baseName = displayName.Contains("(") ? displayName.Substring(0, displayName.IndexOf("(")).Trim() : displayName.Trim();

                try
                {
                    string voiceFolderPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Resources", "voices");
                    string filePath = Path.Combine(voiceFolderPath, $"{baseName}.mp3");

                    if (File.Exists(filePath))
                    {
                        audioPreviewPlayer.Source = new Uri(filePath);
                        audioPreviewPlayer.Play();
                    }
                    else { }
                }
                catch (Exception ex) { }
            }
        }

        private void VoiceItem_MouseLeave(object sender, MouseEventArgs e)
        {
            audioPreviewPlayer.Stop();
        }

        private void AioVoiceComboBox_DropDownClosed(object sender, EventArgs e)
        {
            audioPreviewPlayer.Stop();
        }

        private async void AioModelComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (!this.IsLoaded) return;

            RefreshLanguageOptions(AioModelComboBox.SelectedValue?.ToString());

            // Reset flag để reload voices với model mới
            _ttsVoicesLoaded = false;

            // Reload voices nếu tab TTS đang được mở
            if (TtsTab.IsChecked == true)
            {
                await LoadTtsVoicesFromApiAsync();
            }
        }

        private async void AioLanguageComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (!this.IsLoaded) return;

            // Reset flag để reload voices với ngôn ngữ mới
            _ttsVoicesLoaded = false;

            UpdateAioModelsForLanguage(AioLanguageComboBox.SelectedValue?.ToString());

            // Reload voices nếu tab TTS đang được mở
            if (TtsTab.IsChecked == true)
            {
                await LoadTtsVoicesFromApiAsync();
            }
        }
        private async void TtsAudioPlayer_MediaEnded(object sender, EventArgs e)
        {
            _isTtsPlaying = false;
            _ttsProgressTimer.Stop();
            await _ttsAudioPlayer.Stop();
            TtsProgressSlider.Value = 0;
            TtsPlayPauseButton.Content = "";
            if (_ttsAudioPlayer.NaturalDuration.HasValue)
            {
                TtsTimeDisplay.Text = $"{TimeSpan.Zero:mm\\:ss} / {_ttsAudioPlayer.NaturalDuration.Value:mm\\:ss}";
            }
        }
        private void TtsPlayPauseButton_Click(object sender, RoutedEventArgs e)
        {
            if (_isTtsPlaying)
            {
                _ttsAudioPlayer.Pause();
                _ttsProgressTimer.Stop();
                TtsPlayPauseButton.Content = "\uE768";
            }
            else
            {
                _ttsAudioPlayer.Play();
                _ttsProgressTimer.Start();
                TtsPlayPauseButton.Content = "\uE769";
            }
            _isTtsPlaying = !_isTtsPlaying;
        }

        private void TtsProgressTimer_Tick(object sender, EventArgs e)
        {
            if (!_isTtsSliderDragging && _ttsAudioPlayer.NaturalDuration.HasValue)
            {
                TtsProgressSlider.Value = _ttsAudioPlayer.Position.TotalSeconds;
                TtsTimeDisplay.Text = $"{_ttsAudioPlayer.Position:mm\\:ss} / {_ttsAudioPlayer.NaturalDuration.Value:mm\\:ss}";
            }
        }

        private void FontFamilyComboBox_DropDownOpened(object sender, EventArgs e)
        {
            EnterAuxUi();
            _originalFontFamilyBeforePreview = FontFamilyComboBox.SelectedItem as FontFamily;
        }

        private void FontFamilyTextBlock_MouseEnter(object sender, MouseEventArgs e)
        {
            if (sender is TextBlock textBlock && textBlock.DataContext is FontFamily hoveredFont)
            {
                if (_selectedSubtitle != null && _originalFontFamilyBeforePreview != null)
                {
                    if (_activeVisuals.TryGetValue(_selectedSubtitle, out var currentVisual))
                    {
                        var previewStyle = _selectedSubtitle.Style.Clone();
                        previewStyle.FontFamilyName = hoveredFont.Source;

                        ApplyStyleToVisual(currentVisual, previewStyle);
                    }
                    else
                    {
                    }
                }
                else
                {
                }
            }
            else
            {
            }
        }
        private sealed class VideoSegmentInfo
        {
            public int SegmentIndex { get; init; }
            public TimeSpan SourceStart { get; init; }
            public TimeSpan SourceEnd { get; init; }
            public TimeSpan SourceDuration => SourceEnd - SourceStart;
            public TimeSpan TargetDuration { get; init; }
            public double ActualOutputDuration { get; set; } = 0;
            public double SourceStartExact { get; set; } = 0;
            public double SourceEndExact { get; set; } = 0;
            public double TargetDurationExact { get; set; } = 0;
            public double RequiredSpeed { get; init; }
            public TimelineAudioClip VoiceClip { get; init; }
            public SrtSubtitleLine SubtitleLine { get; init; }
            public bool IsSilenceGap { get; init; }
            public TimeSpan OutputStart { get; set; }
            public TimeSpan OutputEnd { get; set; }
            public string OutputPath { get; set; }
            public bool HasError { get; set; }
            public string ErrorMessage { get; set; }
            public string TempAssPath { get; set; } 
            public List<SegmentOverlayInfo> Overlays { get; set; } = new List<SegmentOverlayInfo>();
            public ProjectState.BlurApplyMode BlurMode { get; set; }
            public System.Windows.Rect? BlurRect { get; set; }
            public double BlurRadius { get; set; }
        }
        private sealed class ParallelProcessingQueue
        {
            public ConcurrentQueue<VideoSegmentInfo> PendingSegments { get; init; }
            public ConcurrentBag<VideoSegmentInfo> CompletedSegments { get; init; }
            public ConcurrentBag<VideoSegmentInfo> FailedSegments { get; init; }
            public int TotalSegments { get; init; }
            public int MaxParallelProcesses { get; init; }
            private int _processedCount = 0;
            public int ProcessedCount => _processedCount;
            public void IncrementProcessed()
            {
                Interlocked.Increment(ref _processedCount);
            }
        }
        private double CalculateRequiredSpeed(TimeSpan videoSegmentDuration, TimeSpan voiceDuration)
        {
            if (voiceDuration <= TimeSpan.Zero)
                return 1.0;

            if (videoSegmentDuration <= TimeSpan.Zero)
                return 1.0;
            double speed = voiceDuration.TotalSeconds / videoSegmentDuration.TotalSeconds;
            if (speed > 1.0)
                speed = 1.0;
            speed = Math.Clamp(speed, 0.25, 1.0);

            return speed;
        }
        private TimeSpan CalculateTargetDuration(TimeSpan sourceDuration, double speed)
        {
            if (speed <= 0.0001)
                return sourceDuration;

            double targetSeconds = sourceDuration.TotalSeconds / speed;
            return TimeSpan.FromSeconds(targetSeconds);
        }
        private async Task<List<VideoSegmentInfo>> BuildSegmentListForParallelProcessing(
    MediaAsset mainVideoAsset,
    List<SmartCutMapItem> smartCutMapItems,
    CancellationToken cancellationToken,
    bool alignToKeyframes = true)
        {
            var segments = new List<VideoSegmentInfo>();

            if (smartCutMapItems == null || smartCutMapItems.Count == 0)
            {
                throw new Exception("Không có dữ liệu SmartCut để xử lý.");
            }
            double videoFps = 30.0;
            try
            {
                var videoInfo = await FFProbe.AnalyseAsync(mainVideoAsset.FilePath);
                if (videoInfo?.PrimaryVideoStream != null)
                {
                    videoFps = videoInfo.PrimaryVideoStream.FrameRate;
                }
            }
            catch (Exception ex)
            {
            }
            double gopDuration = 2.0;
            double frameTime = 1.0 / videoFps;

            var (ttsClips, _) = ClassifyAudioClipsForExport();
            var ttsPlacement = ResolveTtsPlacementsForDynamic(
                ttsClips,
                smartCutMapItems.Select(it => (it.Line, it.FinalStart, it.FinalEnd)).ToList()
            );
            var timelineSubtitleLines = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Subtitle || c.ClipType == TimelineClipType.Text)
                .Select(c => c.SourceData as SrtSubtitleLine)
                .Where(s => s != null)
                .ToHashSet();
            int segmentIndex = 1;
            TimeSpan outputCursor = TimeSpan.Zero;
            TimeSpan previousSourceEnd = TimeSpan.Zero;

            foreach (var mapItem in smartCutMapItems.OrderBy(m => m.FinalStart))
            {
                var line = mapItem.Line;
                double sourceStartSec = line.StartTime.TotalSeconds;
                double sourceEndSec = line.EndTime.TotalSeconds;
                if (alignToKeyframes)
                {
                    sourceStartSec = AlignToKeyframe(sourceStartSec, gopDuration, frameTime, alignToStart: true);
                    sourceEndSec = AlignToKeyframe(sourceEndSec, gopDuration, frameTime, alignToStart: false);
                }
                if (alignToKeyframes) {}
                TimeSpan alignedSourceStart = TimeSpan.FromSeconds(sourceStartSec);
                TimeSpan alignedSourceEnd = TimeSpan.FromSeconds(sourceEndSec);
                if (alignedSourceStart > previousSourceEnd)
                {
                    TimeSpan gapSourceStart = previousSourceEnd;
                    TimeSpan gapSourceEnd = alignedSourceStart;
                    TimeSpan gapDuration = gapSourceEnd - gapSourceStart;
                    if (gapDuration > TimeSpan.FromMilliseconds(50))
                    {
                        double gapStartSec = gapSourceStart.TotalSeconds;
                        double gapEndSec = gapSourceEnd.TotalSeconds;

                        if (alignToKeyframes)
                        {
                            gapStartSec = AlignToKeyframe(gapStartSec, gopDuration, frameTime, alignToStart: true);
                            gapEndSec = AlignToKeyframe(gapEndSec, gopDuration, frameTime, alignToStart: false);
                        }
                        if (alignToKeyframes){}
                        double gapDurSec = gapEndSec - gapStartSec;
                        int gapFrames = (int)Math.Round(gapDurSec * videoFps);
                        gapFrames = Math.Max(gapFrames, 1);
                        gapDurSec = gapFrames / videoFps;
                        double outputCursorSecQ_1 = Math.Round(outputCursor.TotalSeconds * videoFps) / videoFps;
                        if (gapDurSec > 0.05)
                        {
                            var gapSegment = new VideoSegmentInfo
                            {
                                SegmentIndex = segmentIndex++,
                                SourceStart = TimeSpan.FromSeconds(gapStartSec),
                                SourceEnd = TimeSpan.FromSeconds(gapEndSec),
                                SourceStartExact = gapStartSec,
                                SourceEndExact = gapEndSec,
                                TargetDuration = TimeSpan.FromSeconds(gapDurSec),
                                TargetDurationExact = gapDurSec,
                                RequiredSpeed = 1.0,
                                IsSilenceGap = true,
                                SubtitleLine = null,
                                VoiceClip = null,
                                OutputStart = TimeSpan.FromSeconds(outputCursorSecQ_1),
                                OutputEnd = TimeSpan.FromSeconds(outputCursorSecQ_1 + gapDurSec)
                            };
                            segments.Add(gapSegment);

                            outputCursor = TimeSpan.FromSeconds(outputCursorSecQ_1 + gapDurSec);
                        }
                        else{ }
                    }
                    else{}
                }
                else if (alignedSourceStart < previousSourceEnd)
                {
                    alignedSourceStart = previousSourceEnd;
                    if (alignedSourceStart >= alignedSourceEnd - TimeSpan.FromMilliseconds(10))
                    {
                        continue; 
                    }
                    sourceStartSec = alignedSourceStart.TotalSeconds;
                }
                TimelineAudioClip voiceClip = null;
                double voiceDurationSec = 0;
                if (!string.IsNullOrWhiteSpace(line.VoicedAudioPath) && File.Exists(line.VoicedAudioPath))
                {
                    voiceClip = ttsClips.FirstOrDefault(c =>
                        string.Equals(c.FilePath, line.VoicedAudioPath, StringComparison.OrdinalIgnoreCase));

                    if (voiceClip != null)
                    {
                        try
                        {
                            var info = await FFProbe.AnalyseAsync(voiceClip.FilePath);
                            voiceDurationSec = info?.Duration.TotalSeconds ?? 0;
                        }
                        catch
                        {
                            voiceDurationSec = voiceClip.EffectiveDuration.TotalSeconds;
                        }
                        if (Math.Abs(voiceClip.Speed - 1.0) > 0.01)
                        {
                            double originalVoiceDur = voiceDurationSec;
                            voiceDurationSec = voiceDurationSec / voiceClip.Speed;
                        }
                    }
                }
                double sourceSegmentDurSec = sourceEndSec - sourceStartSec;
                double requiredSpeed = 1.0;
                double targetDurSec = sourceSegmentDurSec;
                if (voiceDurationSec > 0.01)
                {
                    if (voiceDurationSec > sourceSegmentDurSec)
                    {
                        requiredSpeed = sourceSegmentDurSec / voiceDurationSec;
                        requiredSpeed = Math.Clamp(requiredSpeed, 0.25, 4.0);
                        targetDurSec = sourceSegmentDurSec / requiredSpeed;
                    }
                    else
                    {
                        requiredSpeed = 1.0;
                        targetDurSec = sourceSegmentDurSec;
                    }
                }
                else{}
                double outputCursorSecQ = Math.Round(outputCursor.TotalSeconds * videoFps) / videoFps;
                int targetFrames = (int)Math.Round(targetDurSec * videoFps);
                double targetDurSecBeforeFrameAdjust = targetDurSec;
                targetDurSec = targetFrames / videoFps;

                if (Math.Abs(targetDurSec - targetDurSecBeforeFrameAdjust) > 0.001)
                {}
                SrtSubtitleLine subtitleForSegment = timelineSubtitleLines.Contains(line) ? line : null;

                if (subtitleForSegment == null && line != null) {}

                var subtitleSegment = new VideoSegmentInfo
                {
                    SegmentIndex = segmentIndex,
                    SourceStart = TimeSpan.FromSeconds(sourceStartSec),
                    SourceEnd = TimeSpan.FromSeconds(sourceEndSec),
                    SourceStartExact = sourceStartSec,
                    SourceEndExact = sourceEndSec,
                    TargetDuration = TimeSpan.FromSeconds(targetDurSec),
                    TargetDurationExact = targetDurSec,
                    RequiredSpeed = requiredSpeed,
                    IsSilenceGap = false,
                    SubtitleLine = subtitleForSegment,
                    VoiceClip = voiceClip,
                    OutputStart = TimeSpan.FromSeconds(outputCursorSecQ),
                    OutputEnd = TimeSpan.FromSeconds(outputCursorSecQ + targetDurSec)
                };
                segments.Add(subtitleSegment);
                segmentIndex++;
                outputCursor = TimeSpan.FromSeconds(outputCursorSecQ + targetDurSec);
                previousSourceEnd = TimeSpan.FromSeconds(sourceEndSec);
            }
            if (mainVideoAsset != null && previousSourceEnd < mainVideoAsset.Duration)
            {
                double finalGapStartSec = previousSourceEnd.TotalSeconds;
                double finalGapEndSec = mainVideoAsset.Duration.TotalSeconds;
                if (alignToKeyframes)
                {
                    finalGapStartSec = AlignToKeyframe(finalGapStartSec, gopDuration, frameTime, alignToStart: true);
                    finalGapEndSec = AlignToKeyframe(finalGapEndSec, gopDuration, frameTime, alignToStart: false);
                }

                double finalGapDurSec = finalGapEndSec - finalGapStartSec;
                int finalGapFrames = (int)Math.Round(finalGapDurSec * videoFps);
                finalGapFrames = Math.Max(finalGapFrames, 1);
                finalGapDurSec = finalGapFrames / videoFps;
                double outputCursorSecQ = Math.Round(outputCursor.TotalSeconds * videoFps) / videoFps;
                if (finalGapDurSec > 0.05)
                {
                    var finalGapSegment = new VideoSegmentInfo
                    {
                        SegmentIndex = segmentIndex++,
                        SourceStart = TimeSpan.FromSeconds(finalGapStartSec),
                        SourceEnd = TimeSpan.FromSeconds(finalGapEndSec),
                        SourceStartExact = finalGapStartSec,
                        SourceEndExact = finalGapEndSec,
                        TargetDuration = TimeSpan.FromSeconds(finalGapDurSec),
                        TargetDurationExact = finalGapDurSec,
                        RequiredSpeed = 1.0,
                        IsSilenceGap = true,
                        SubtitleLine = null,
                        VoiceClip = null,
                        OutputStart = TimeSpan.FromSeconds(outputCursorSecQ),
                        OutputEnd = TimeSpan.FromSeconds(outputCursorSecQ + finalGapDurSec)
                    };

                    segments.Add(finalGapSegment);
                    outputCursor = TimeSpan.FromSeconds(outputCursorSecQ + finalGapDurSec);
                }
                else {}
            }
            int gapCount = segments.Count(s => s.IsSilenceGap);
            int subtitleCount = segments.Count(s => !s.IsSilenceGap);
            return segments;
        }
        private double MapSourceTimeToOutputTimelineSeconds(double sourceTimeSec, List<VideoSegmentInfo> segments)
        {
            foreach (var segment in segments.OrderBy(s => s.SourceStart))
            {
                if (sourceTimeSec >= segment.SourceStartExact && sourceTimeSec < segment.SourceEndExact)
                {
                    double progressInSegment = sourceTimeSec - segment.SourceStartExact;
                    double sourceDur = segment.SourceEndExact - segment.SourceStartExact;
                    double segmentRatio = sourceDur > 0 ? progressInSegment / sourceDur : 0;

                    double offsetInOutput = segmentRatio * segment.TargetDurationExact;
                    return segment.OutputStart.TotalSeconds + offsetInOutput;
                }
            }
            return sourceTimeSec;
        }
        private double AlignToKeyframe(double timeSec, double gopDuration, double frameTime, bool alignToStart)
        {
            if (alignToStart)
            {
                int frameIndex = (int)Math.Ceiling(timeSec / frameTime);
                double alignedTime = frameIndex * frameTime;
                int gopIndex = (int)(alignedTime / gopDuration);
                double gopStart = gopIndex * gopDuration;
                if (Math.Abs(alignedTime - gopStart) < frameTime)
                {
                    return gopStart;
                }
                return alignedTime;
            }
            else
            {
                int frameIndex = (int)Math.Floor(timeSec / frameTime);
                double alignedTime = frameIndex * frameTime;
                int gopIndex = (int)Math.Ceiling(alignedTime / gopDuration);
                double gopEnd = gopIndex * gopDuration;
                if (Math.Abs(gopEnd - alignedTime) < frameTime)
                {
                    return gopEnd;
                }

                return alignedTime;
            }
        }
        private async Task<bool> ProcessSingleSegmentAsync(
    VideoSegmentInfo segment,
    MediaAsset mainVideoAsset,
    string ffmpegPath,
    VideoExportSettings settings,
    IProgress<string> progress,
    CancellationToken cancellationToken)
        {
            try
            {
                progress?.Report($"Segment #{segment.SegmentIndex}: Bắt đầu xử lý");
                segment.OutputPath = TempFileManager.CreateTempFile(".mp4");
                TempFileManager.RegisterForCleanup(segment.OutputPath);
                var args = new StringBuilder();
                args.Append("-y -hide_banner ");
                string finalGpuAccel = "none";
                string finalVideoCodec = settings.VideoCodec;

                if (settings.GpuAcceleration == "auto")
                {
                    var allGpus = await FfmpegGpuDetector.GetAvailableGpusAsync();
                    var bestGpu = FfmpegGpuDetector.GetBestAvailableGpu(allGpus);
                    if (bestGpu != null && bestGpu.FfmpegValue != "none")
                    {
                        finalGpuAccel = bestGpu.FfmpegValue;
                        finalVideoCodec = bestGpu.RecommendedCodec;
                    }
                }
                else if (!string.IsNullOrEmpty(settings.GpuAcceleration) && settings.GpuAcceleration != "none")
                {
                    finalGpuAccel = settings.GpuAcceleration;
                }

                if (finalGpuAccel != "none")
                {
                    args.Append($"-hwaccel {finalGpuAccel} ");
                }
                args.Append($"-i \"{mainVideoAsset.FilePath}\" ");
                bool hasVoice = segment.VoiceClip != null &&
                                !string.IsNullOrWhiteSpace(segment.VoiceClip.FilePath) &&
                                File.Exists(segment.VoiceClip.FilePath);
                if (hasVoice)
                {
                    args.Append($"-i \"{segment.VoiceClip.FilePath}\" ");
                }
                var uniqueOverlays = segment.Overlays.Select(o => o.FilePath).Distinct(StringComparer.OrdinalIgnoreCase).ToList();
                var overlayInputMap = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
                int currentInputIdx = hasVoice ? 2 : 1;

                foreach (var path in uniqueOverlays)
                {
                    args.Append($"-stream_loop -1 -i \"{path}\" ");
                    overlayInputMap[path] = currentInputIdx++;
                }
                var filterParts = new List<string>();
                string videoTag = "0:v";
                string audioTag = "0:a";
                string startStr = segment.SourceStartExact.ToString("0.000000", CultureInfo.InvariantCulture);
                string endStr = segment.SourceEndExact.ToString("0.000000", CultureInfo.InvariantCulture);
                filterParts.Add($"[{videoTag}]trim=start={startStr}:end={endStr},setpts=PTS-STARTPTS,fps=30[v_trimmed]");
                videoTag = "v_trimmed";
                filterParts.Add($"[{audioTag}]atrim=start={startStr}:end={endStr},asetpts=PTS-STARTPTS[a_trimmed]");
                audioTag = "a_trimmed";
                if (Math.Abs(segment.RequiredSpeed - 1.0) > 0.001)
                {
                    double ptsMultiplier = 1.0 / segment.RequiredSpeed;
                    filterParts.Add($"[{videoTag}]setpts={ptsMultiplier.ToString("0.000000", CultureInfo.InvariantCulture)}*PTS[v_speed]");
                    videoTag = "v_speed";
                    string atempoChain = BuildAtempoChain(segment.RequiredSpeed);
                    if (!string.IsNullOrEmpty(atempoChain))
                    {
                        filterParts.Add($"[{audioTag}]{atempoChain}[a_speed]");
                        audioTag = "a_speed";
                    }
                }
                int W = settings.ResolutionWidth;
                int H = settings.ResolutionHeight;
                string panZoomFilter;
                double zoom = mainVideoAsset.Scale;
                double posX = mainVideoAsset.PositionX;
                double posY = mainVideoAsset.PositionY;

                if (Math.Abs(zoom - 1.0) > 0.001 || Math.Abs(posX - 0.5) > 0.001 || Math.Abs(posY - 0.5) > 0.001)
                {
                    string cover = $"max({W}/iw\\,{H}/ih)";
                    string zoomExpr = $"max({zoom.ToString(CultureInfo.InvariantCulture)}\\,1)";
                    string eff = $"({cover})*({zoomExpr})";
                    string scaleFilter = $"scale=w=ceil(iw*{eff}):h=ceil(ih*{eff})";
                    string cx = $"(iw - {W})/2 - ({posX.ToString(CultureInfo.InvariantCulture)} - 0.5)*{W}";
                    string cy = $"(ih - {H})/2 - ({posY.ToString(CultureInfo.InvariantCulture)} - 0.5)*{H}";
                    string cropX = $"x='max(0\\,min(iw-{W}\\,({cx})))'";
                    string cropY = $"y='max(0\\,min(ih-{H}\\,({cy})))'";
                    panZoomFilter = $"{scaleFilter},crop={W}:{H}:{cropX}:{cropY}";
                }
                else
                {
                    string cover = $"max({W}/iw\\,{H}/ih)";
                    panZoomFilter = $"scale=w=ceil(iw*({cover})):h=ceil(ih*({cover})),crop={W}:{H}";
                }
                filterParts.Add($"[{videoTag}]{panZoomFilter},setsar=1[v_sized]");
                videoTag = "v_sized";
                bool shouldApplyBlur = segment.BlurMode != ProjectState.BlurApplyMode.None &&
                                       segment.BlurRect.HasValue &&
                                       (segment.BlurMode == ProjectState.BlurApplyMode.AllTime || !segment.IsSilenceGap);

                if (shouldApplyBlur)
                {
                    var r = segment.BlurRect.Value;
                    var ci = CultureInfo.InvariantCulture;
                    double sigma = Math.Max(0.1, segment.BlurRadius * 0.75);
                    double nx = Math.Max(0.0, Math.Min(1.0, r.X));
                    double ny = Math.Max(0.0, Math.Min(1.0, r.Y));
                    double nw = Math.Max(0.0, Math.Min(1.0, r.Width));
                    double nh = Math.Max(0.0, Math.Min(1.0, r.Height));
                    string wExprCrop = $"max(1,{nw.ToString(ci)}*iw)";
                    string hExprCrop = $"max(1,{nh.ToString(ci)}*ih)";
                    string xExprCrop = $"clip({nx.ToString(ci)}*iw,0,iw-({wExprCrop}))";
                    string yExprCrop = $"clip({ny.ToString(ci)}*ih,0,ih-({hExprCrop}))";
                    string wExprOv = wExprCrop.Replace("iw", "main_w").Replace("ih", "main_h");
                    string hExprOv = hExprCrop.Replace("iw", "main_w").Replace("ih", "main_h");
                    string xExprOv = $"clip({nx.ToString(ci)}*main_w,0,main_w-({wExprOv}))";
                    string yExprOv = $"clip({ny.ToString(ci)}*main_h,0,main_h-({hExprOv}))";
                    string QuoteExpr(string expr)
                    {
                        if (string.IsNullOrEmpty(expr)) return "''";
                        return "'" + expr.Replace("\\", "\\\\").Replace("'", "\\'") + "'";
                    }

                    string blurChain =
                        $"[{videoTag}]split[base][to_blur];" +
                        $"[to_blur]crop=w={QuoteExpr(wExprCrop)}:h={QuoteExpr(hExprCrop)}:x={QuoteExpr(xExprCrop)}:y={QuoteExpr(yExprCrop)},gblur=sigma={sigma.ToString(ci)}[blurred];" +
                        $"[base][blurred]overlay=x={QuoteExpr(xExprOv)}:y={QuoteExpr(yExprOv)}:enable='1'[v_blurred]";

                    filterParts.Add(blurChain);
                    videoTag = "v_blurred";
                }
                if (_isVideoFlipEnabled)
                {
                    filterParts.Add($"[{videoTag}]hflip[v_flipped]");
                    videoTag = "v_flipped";
                }
                int ovIdx = 0;
                double refW = _currentProject.ProjectReferenceVideoWidth > 0 ? _currentProject.ProjectReferenceVideoWidth : 1280.0;
                double refH = _currentProject.ProjectReferenceVideoHeight > 0 ? _currentProject.ProjectReferenceVideoHeight : 720.0;
                double scaleXFactor = W / refW;
                double scaleYFactor = H / refH;

                foreach (var ov in segment.Overlays)
                {
                    if (!overlayInputMap.TryGetValue(ov.FilePath, out int inputIdx)) continue;

                    string procImgTag = $"img_{ovIdx}";
                    string ovOutTag = $"v_ov_{ovIdx}";
                    double imgAR = ov.Height > 0 ? (double)ov.Width / ov.Height : 1.0;
                    double initW_ref, initH_ref;
                    if ((refW / refH) > imgAR) { initH_ref = refH; initW_ref = initH_ref * imgAR; }
                    else { initW_ref = refW; initH_ref = initW_ref / imgAR; }
                    double finalW = initW_ref * Math.Max(ov.ScaleX, 0.001) * scaleXFactor;
                    double finalH = initH_ref * Math.Max(ov.ScaleY, 0.001) * scaleYFactor;
                    int iW = Math.Max(1, (int)Math.Round(finalW));
                    int iH = Math.Max(1, (int)Math.Round(finalH));
                    string rotate = Math.Abs(ov.Rotation) > 0.1
                        ? $",rotate={ov.Rotation * Math.PI / 180.0}:c=none:ow=hypot(iw\\,ih):oh=hypot(iw\\,ih)"
                        : "";

                    filterParts.Add($"[{inputIdx}:v]scale={iW}:{iH}:flags=lanczos{rotate},format=rgba[{procImgTag}]");
                    double cx = ov.X * refW * scaleXFactor;
                    double cy = ov.Y * refH * scaleYFactor;
                    string ox = $"{cx.ToString(CultureInfo.InvariantCulture)} - w/2";
                    string oy = $"{cy.ToString(CultureInfo.InvariantCulture)} - h/2";
                    string enable = $"between(t,{ov.RelativeStartSeconds.ToString(CultureInfo.InvariantCulture)},{ov.RelativeEndSeconds.ToString(CultureInfo.InvariantCulture)})";

                    filterParts.Add($"[{videoTag}][{procImgTag}]overlay=x={ox}:y={oy}:enable='{enable}'[{ovOutTag}]");
                    videoTag = ovOutTag;
                    ovIdx++;
                }
                if (!string.IsNullOrEmpty(segment.TempAssPath) && File.Exists(segment.TempAssPath))
                {
                    string assPath = segment.TempAssPath.Replace("\\", "/").Replace(":", "\\:");
                    string fontsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Fonts").Replace("\\", "/").Replace(":", "\\:");
                    filterParts.Add($"[{videoTag}]subtitles=filename='{assPath}':charenc=UTF-8[v_subbed]");
                    videoTag = "v_subbed";
                }
                string mixTag = "a_mixed";
                if (hasVoice)
                {
                    string vVol = DbToGain(mainVideoAsset.VolumeDb).ToString(CultureInfo.InvariantCulture);
                    string ttsVol = DbToGain(segment.VoiceClip.VolumeDb).ToString(CultureInfo.InvariantCulture);
                    filterParts.Add($"[{audioTag}]volume={vVol},aformat=sample_fmts=fltp:sample_rates=48000:channel_layouts=stereo[a_main]");
                    filterParts.Add($"[1:a]volume={ttsVol},aformat=sample_fmts=fltp:sample_rates=48000:channel_layouts=stereo[a_voice]");
                    filterParts.Add($"[a_main][a_voice]amix=inputs=2:duration=longest:normalize=0:dropout_transition=0,alimiter=limit=0.95[{mixTag}]");
                }
                else
                {
                    string vVol = DbToGain(mainVideoAsset.VolumeDb).ToString(CultureInfo.InvariantCulture);
                    filterParts.Add($"[{audioTag}]volume={vVol},aformat=sample_fmts=fltp:sample_rates=48000:channel_layouts=stereo,alimiter=limit=0.95[{mixTag}]");
                }
                string targetDurStr = segment.TargetDurationExact.ToString("0.000000", CultureInfo.InvariantCulture);
                filterParts.Add($"[{videoTag}]trim=duration={targetDurStr},setpts=PTS-STARTPTS[vout]");
                filterParts.Add($"[{mixTag}]atrim=duration={targetDurStr},asetpts=PTS-STARTPTS,apad[aout_padded]");
                filterParts.Add($"[aout_padded]atrim=duration={targetDurStr},asetpts=PTS-STARTPTS[aout]");
                string filterContent = string.Join(";", filterParts);
                string filterPath = TempFileManager.CreateTempFile(".txt");
                await WriteTextNoBomAsync(filterPath, filterContent, cancellationToken);
                TempFileManager.RegisterForCleanup(filterPath);
                args.Append($"-filter_complex_script \"{filterPath}\" ");
                args.Append("-map \"[vout]\" -map \"[aout]\" ");
                bool isHwEncoder = !string.IsNullOrWhiteSpace(finalVideoCodec) &&
                                   (finalVideoCodec.ToLowerInvariant().Contains("_nvenc") ||
                                    finalVideoCodec.ToLowerInvariant().Contains("_qsv") ||
                                    finalVideoCodec.ToLowerInvariant().Contains("_amf"));

                if (isHwEncoder)
                {
                    args.Append($"-c:v {finalVideoCodec} ");
                    args.Append($"-cq {settings.Crf} ");
                    string hwPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "p4";
                    args.Append($"-preset {hwPreset} ");
                }
                else
                {
                    string cpuCodec = !string.IsNullOrWhiteSpace(finalVideoCodec) &&
                                      (finalVideoCodec.Contains("libx264") || finalVideoCodec.Contains("libx265"))
                                      ? finalVideoCodec : "libx264";
                    args.Append($"-c:v {cpuCodec} ");
                    args.Append($"-crf {settings.Crf} ");
                    args.Append("-preset ultrafast ");
                }
                args.Append("-r 30 -g 60 -keyint_min 60 -sc_threshold 0 "); 
                args.Append("-pix_fmt yuv420p "); 
                if (settings.ThreadsPerProcess > 0)
                {
                    args.Append($"-threads {settings.ThreadsPerProcess} ");
                }
                args.Append("-c:a aac -b:a 192k -ar 48000 -ac 2 ");
                args.Append($"\"{segment.OutputPath}\"");
                progress?.Report($"Segment #{segment.SegmentIndex}: Đang render video");
                int code = await RunFfmpegAsync(ffmpegPath, args.ToString(), cancellationToken);

                if (code != 0 || !File.Exists(segment.OutputPath))
                {
                    segment.HasError = true;
                    segment.ErrorMessage = $"Failed with code {code}";
                    progress?.Report($"Segment #{segment.SegmentIndex}: Lỗi");
                    return false;
                }
                progress?.Report($"Segment #{segment.SegmentIndex}: Đang kiểm tra");
                try
                {
                    var info = await FFProbe.AnalyseAsync(segment.OutputPath);
                    segment.ActualOutputDuration = info.Duration.TotalSeconds;
                }
                catch { }

                progress?.Report($"Segment #{segment.SegmentIndex}: Hoàn thành");
                return true;
            }
            catch (Exception ex)
            {
                segment.HasError = true;
                segment.ErrorMessage = ex.Message;
                progress?.Report($"Segment #{segment.SegmentIndex}: Lỗi - {ex.Message}");
                return false;
            }
        }
        private string BuildVideoSpeedFilter(double speed)
        {
            if (Math.Abs(speed - 1.0) < 0.001)
                return string.Empty;
            speed = Math.Clamp(speed, 0.25, 4.0);
            double ptsMultiplier = 1.0 / speed;

            return $"setpts={ptsMultiplier.ToString("0.######", CultureInfo.InvariantCulture)}*PTS";
        }
        private string BuildBlurFilterForSegment(string videoInLabel, string videoOutLabel, VideoSegmentInfo segment)
        {
            if (_currentProject.BlurRectNormalized == null)
                return string.Empty;

            var rect = _currentProject.BlurRectNormalized.Value;
            double sigma = _currentProject.BlurPreviewRadius / 100.0 * 20.0;
            sigma = Math.Clamp(sigma, 0.1, 50.0);

            var ci = CultureInfo.InvariantCulture;
            string wCrop = $"iw*{rect.Width.ToString(ci)}";
            string hCrop = $"ih*{rect.Height.ToString(ci)}";
            string xCrop = $"iw*{rect.X.ToString(ci)}";
            string yCrop = $"ih*{rect.Y.ToString(ci)}";
            return $"[{videoInLabel}]split[orig][crop];" +
                   $"[crop]crop=w={wCrop}:h={hCrop}:x={xCrop}:y={yCrop},gblur=sigma={sigma.ToString(ci)}[blurred];" +
                   $"[orig][blurred]overlay=x={xCrop}:y={yCrop}:enable='1'[{videoOutLabel}]";
        }
        private async Task ProcessSegmentsInParallelAsync(
            List<VideoSegmentInfo> segments,
            MediaAsset mainVideoAsset,
            string ffmpegPath,
            VideoExportSettings settings,
            GenerateVideoWindow progressWindow,
            int maxParallelProcesses,
            CancellationToken cancellationToken)
        {
            var queue = new ParallelProcessingQueue
            {
                PendingSegments = new ConcurrentQueue<VideoSegmentInfo>(segments),
                CompletedSegments = new ConcurrentBag<VideoSegmentInfo>(),
                FailedSegments = new ConcurrentBag<VideoSegmentInfo>(),
                TotalSegments = segments.Count,
                MaxParallelProcesses = maxParallelProcesses
            };
            var progress = new Progress<string>(msg =>
            {
                int processed = queue.ProcessedCount;
                int total = queue.TotalSegments;
                int percentage = (int)((double)processed / total * 80) + 10;

                progressWindow.UpdateProgress(percentage,
                    $"Đang xử lý segments: {processed}/{total} - {msg}");
            });
            var tasks = new List<Task>();
            for (int i = 0; i < maxParallelProcesses; i++)
            {
                int workerId = i + 1;

                tasks.Add(Task.Run(async () =>
                {
                    while (queue.PendingSegments.TryDequeue(out VideoSegmentInfo segment))
                    {
                        if (cancellationToken.IsCancellationRequested)
                            break;
                        bool success = false;
                        int attempts = 0;
                        const int maxAttempts = 3;

                        while (!success && attempts < maxAttempts)
                        {
                            attempts++;

                            try
                            {
                                success = await ProcessSingleSegmentAsync(
                                    segment,
                                    mainVideoAsset,
                                    ffmpegPath,
                                    settings,
                                    progress,
                                    cancellationToken);

                                if (!success && attempts < maxAttempts)
                                {
                                    await Task.Delay(1000, cancellationToken);
                                }
                            }
                            catch (Exception ex)
                            {
                                segment.HasError = true;
                                segment.ErrorMessage = $"Attempt {attempts}: {ex.Message}";

                                if (attempts >= maxAttempts)
                                {
                                    success = false;
                                }
                            }
                        }

                        if (success)
                        {
                            queue.CompletedSegments.Add(segment);
                        }
                        else
                        {
                            queue.FailedSegments.Add(segment);
                        }

                        queue.IncrementProcessed();
                    }
                }, cancellationToken));
            }
            await Task.WhenAll(tasks);
            if (queue.FailedSegments.Any())
            {
                var errorMsg = new StringBuilder();
                errorMsg.AppendLine($"Có {queue.FailedSegments.Count} segments bị lỗi:");

                foreach (var failed in queue.FailedSegments.Take(5))
                {
                    errorMsg.AppendLine($"  - Segment #{failed.SegmentIndex}: {failed.ErrorMessage}");
                }

                if (queue.FailedSegments.Count > 5)
                {
                    errorMsg.AppendLine($"  ... và {queue.FailedSegments.Count - 5} lỗi khác");
                }

                throw new Exception(errorMsg.ToString());
            }
        }
        private void BatchProcessMenuItem_Click(object sender, RoutedEventArgs e)
        {
            IsBatchProcessingPopupOpen = true;
        }

        private void CloseBatchPopup_Click(object sender, RoutedEventArgs e)
        {
            _batchCts?.Cancel();
            _batchSrtCts?.Cancel();
            IsBatchProcessingPopupOpen = false;
            BatchProcessingLog = "Đã hủy bởi người dùng.";
            BatchSrtProcessingLog = "Đã hủy bởi người dùng.";
        }

        private void SelectBatchInput_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new Ookii.Dialogs.Wpf.VistaFolderBrowserDialog
            {
                Description = "Chọn thư mục chứa các video cần xử lý",
                UseDescriptionForTitle = true
            };

            if (dialog.ShowDialog(this).GetValueOrDefault())
            {
                BatchInputFolderPath = dialog.SelectedPath;
            }
        }

        private void SelectBatchOutput_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new Ookii.Dialogs.Wpf.VistaFolderBrowserDialog
            {
                Description = "Chọn thư mục để lưu kết quả",
                UseDescriptionForTitle = true
            };

            if (dialog.ShowDialog(this).GetValueOrDefault())
            {
                BatchOutputFolderPath = dialog.SelectedPath;
            }
        }

        private void SelectBatchSrtInput_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new Ookii.Dialogs.Wpf.VistaFolderBrowserDialog
            {
                Description = "Chọn thư mục chứa các file SRT cần dịch",
                UseDescriptionForTitle = true
            };

            if (dialog.ShowDialog(this).GetValueOrDefault())
            {
                BatchSrtInputFolderPath = dialog.SelectedPath;
            }
        }

        private void SelectBatchSrtOutput_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new Ookii.Dialogs.Wpf.VistaFolderBrowserDialog
            {
                Description = "Chọn thư mục để lưu các file SRT đã dịch",
                UseDescriptionForTitle = true
            };

            if (dialog.ShowDialog(this).GetValueOrDefault())
            {
                BatchSrtOutputFolderPath = dialog.SelectedPath;
            }
        }

        private void LogToBatchSrtPopup(string message)
        {
            Dispatcher.Invoke(() =>
            {
                BatchSrtProcessingLog += $"[{DateTime.Now:HH:mm:ss}] {message}\n";
                if (FindName("BatchSrtLogTextBlock") is TextBlock logTextBlock && VisualTreeHelper.GetParent(logTextBlock) is ScrollViewer scrollViewer)
                {
                    scrollViewer.ScrollToEnd();
                }
            });
        }

        private async void StartBatchSrtTranslationButton_Click(object sender, RoutedEventArgs e)
        {
            if (string.IsNullOrWhiteSpace(BatchSrtInputFolderPath) || !Directory.Exists(BatchSrtInputFolderPath))
            {
                CustomMessageBox.Show("Vui lòng chọn thư mục chứa file SRT hợp lệ.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }
            if (string.IsNullOrWhiteSpace(BatchSrtOutputFolderPath))
            {
                CustomMessageBox.Show("Vui lòng chọn thư mục để lưu kết quả.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }
            var srtFiles = Directory.GetFiles(BatchSrtInputFolderPath, "*.srt", SearchOption.TopDirectoryOnly).ToList();

            if (!srtFiles.Any())
            {
                CustomMessageBox.Show("Không tìm thấy file SRT nào trong thư mục đã chọn.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }
            LogToBatchSrtPopup($"Tìm thấy {srtFiles.Count} file SRT. Đang kiểm tra số lần dịch còn lại...");
            int totalLinesToTranslate = 0;
            var fileLinesCounts = new Dictionary<string, int>();

            foreach (var srtFile in srtFiles)
            {
                try
                {
                    var lines = SrtFileUtils.LoadFromFile(srtFile);
                    int lineCount = lines.Count(l => !string.IsNullOrWhiteSpace(l.OriginalText));
                    fileLinesCounts[srtFile] = lineCount;
                    totalLinesToTranslate += lineCount;
                }
                catch (Exception ex){ }
            }
            if (_currentSrtApiProvider == SrtApiProvider.AIOLauncher || _currentSrtApiProvider == SrtApiProvider.AIOLauncherVIP)
            { }
            else
            {
                var (canTranslate, message, remaining) = await ApiService.PreSrtTranslateCheckAsync(totalLinesToTranslate);

                if (!canTranslate)
                {
                    CustomMessageBox.Show(message, "Không đủ lượt dịch", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

            }
            StartBatchSrtTranslationButton.IsEnabled = false;
            _batchSrtCts = new CancellationTokenSource();
            var token = _batchSrtCts.Token;
            RebuildSrtTranslationService();

            try
            {
                await ProcessBatchSrtTranslation(srtFiles, fileLinesCounts, token);
                LogToBatchSrtPopup("✓ Hoàn thành dịch tất cả các file SRT!");
            }
            catch (OperationCanceledException) {}
            catch (Exception ex)
            {
                LogToBatchSrtPopup($"✗ Lỗi: {ex.Message}");
                CustomMessageBox.Show($"Có lỗi xảy ra: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                StartBatchSrtTranslationButton.IsEnabled = true;
                _batchSrtCts?.Dispose();
                _batchSrtCts = null;
            }
        }

        private async Task ProcessBatchSrtTranslation(List<string> srtFiles, Dictionary<string, int> fileLinesCounts, CancellationToken token)
        {
            int processedCount = 0;
            int totalFiles = srtFiles.Count;

            foreach (var srtFile in srtFiles)
            {
                if (token.IsCancellationRequested)
                    break;

                processedCount++;
                string fileName = Path.GetFileName(srtFile);
                LogToBatchSrtPopup($"[{processedCount}/{totalFiles}] Đang dịch: {fileName}");

                try
                {
                    var lines = SrtFileUtils.LoadFromFile(srtFile);

                    if (!lines.Any() || !lines.Any(l => !string.IsNullOrWhiteSpace(l.OriginalText)))
                    {
                        LogToBatchSrtPopup($"⚠ File {fileName} trống hoặc không có nội dung, bỏ qua.");
                        continue;
                    }
                    var linesToTranslate = lines.Where(l => !string.IsNullOrWhiteSpace(l.OriginalText)).ToList();
                    LogToBatchSrtPopup($"  - Số dòng cần dịch: {linesToTranslate.Count}");
                    if (_currentSrtApiProvider == SrtApiProvider.AIOLauncher)
                    {
                        await TranslateSrtFileWithAioLauncher(linesToTranslate, fileName, token);
                    }
                    else if (_currentSrtApiProvider == SrtApiProvider.AIOLauncherVIP)
                    {
                        await TranslateSrtFileWithAioLauncherVip(linesToTranslate, fileName, token);
                    }
                    else
                    {
                        await TranslateSrtFileWithThirdParty(linesToTranslate, fileName, token);
                    }
                    string outputFileName = Path.GetFileNameWithoutExtension(srtFile) + "_translated.srt";
                    string outputPath = Path.Combine(BatchSrtOutputFolderPath, outputFileName);

                    SrtFileUtils.SaveToFile(outputPath, lines);

                    LogToBatchSrtPopup($"  ✓ Đã lưu: {outputFileName}");
                }
                catch (OperationCanceledException)
                {
                    throw;
                }
                catch (Exception ex)
                {
                    LogToBatchSrtPopup($"  ✗ Lỗi khi dịch {fileName}: {ex.Message}");
                }
            }
        }

        private async Task TranslateSrtFileWithAioLauncher(List<SrtSubtitleLine> linesToTranslate, string fileName, CancellationToken token)
        {
            bool acceptPartial = false;
            string systemInstruction;

            if (IsCustomPromptEnabled)
            {
                if (string.IsNullOrWhiteSpace(CurrentCustomPromptText))
                {
                    throw new Exception("Prompt tùy chỉnh đang được bật nhưng nội dung lại trống.");
                }
                systemInstruction = CurrentCustomPromptText.Trim() + CUSTOM_PROMPT_SUFFIX;
            }
            else
            {
                systemInstruction = _srtTranslationService.GetSystemInstructionForGeminiSrtTranslation(_selectedSrtGenreValue, _selectedSrtTargetLanguage);
            }

            while (!token.IsCancellationRequested)
            {
                var srtLinesForRequest = linesToTranslate.Select(l => new SrtLine(l.Index, l.OriginalText)).ToList();
                var response = await ApiService.StartTranslationJobAsync(_selectedSrtGenreValue, _selectedSrtTargetLanguage, srtLinesForRequest, systemInstruction, acceptPartial);

                switch (response.Status)
                {
                    case "Accepted":
                        string sessionId = response.SessionId;
                        _currentLoadingSessionId = sessionId; // THÊM MỚI: Lưu sessionId
                        try
                        {
                            await PollForAioResultsForBatchSrt(sessionId, linesToTranslate, fileName, token);
                        }
                        catch (OperationCanceledException)
                        {
                            // Cancel job on server when user cancels
                            if (!string.IsNullOrEmpty(sessionId))
                            {
                                try
                                {
                                    await ApiService.CancelTranslationJobAsync(sessionId);
                                }
                                catch { }
                            }
                            throw;
                        }
                        finally
                        {
                            _currentLoadingSessionId = null; // THÊM MỚI: Clear sessionId
                        }
                        return;

                    case "PartialContent":
                        LogToBatchSrtPopup($"  ⚠ {response.Message}");
                        acceptPartial = true;
                        continue;

                    case "Error":
                    default:
                        throw new Exception(response.Message);
                }
            }
        }

        private async Task PollForAioResultsForBatchSrt(string sessionId, List<SrtSubtitleLine> linesToTranslate, string fileName, CancellationToken token)
        {
            var totalLines = linesToTranslate.Count;
            var translatedCount = 0;

            // THÊM MỚI: Timeout và tracking
            var startTime = DateTime.UtcNow;
            var timeout = TimeSpan.FromMinutes(15);
            int consecutiveEmptyPolls = 0;
            const int maxConsecutiveEmptyPolls = 60;

            while (!token.IsCancellationRequested)
            {
                // THÊM MỚI: Kiểm tra timeout
                if (DateTime.UtcNow - startTime > timeout)
                {
                    LogToBatchSrtPopup($"  ⚠ Timeout: Quá trình dịch vượt quá 15 phút!");
                    return;
                }

                var result = await ApiService.GetTranslationResultsAsync(sessionId);

                if (result.NewLines != null && result.NewLines.Any())
                {
                    consecutiveEmptyPolls = 0;
                    foreach (var newLine in result.NewLines)
                    {
                        var lineToUpdate = linesToTranslate.FirstOrDefault(l => l.Index == newLine.Index);
                        if (lineToUpdate != null)
                        {
                            lineToUpdate.TranslatedText = newLine.TranslatedText;
                        }
                    }
                    translatedCount += result.NewLines.Count;
                    LogToBatchSrtPopup($"  - Đã dịch {translatedCount}/{totalLines} dòng");
                }
                else
                {
                    consecutiveEmptyPolls++;
                    if (consecutiveEmptyPolls >= maxConsecutiveEmptyPolls && !result.IsCompleted)
                    {
                        LogToBatchSrtPopup($"  ⚠ Cảnh báo: Không nhận được dữ liệu mới trong {consecutiveEmptyPolls} giây");
                    }
                }

                if (result.IsCompleted)
                {
                    if (!string.IsNullOrEmpty(result.ErrorMessage))
                    {
                        LogToBatchSrtPopup($"  ⚠ Cảnh báo: {result.ErrorMessage}");
                    }
                    var failedLines = linesToTranslate.Where(l => string.IsNullOrWhiteSpace(l.TranslatedText)).ToList();
                    if (failedLines.Any())
                    {
                        LogToBatchSrtPopup($"  - Đang retry {failedLines.Count} dòng thất bại...");
                        await RetryFailedSrtTranslationsForBatch(failedLines, fileName, token);
                    }

                    return;
                }

                await Task.Delay(1000, token);
            }
        }

        private async Task RetryFailedSrtTranslationsForBatch(List<SrtSubtitleLine> failedLines, string fileName, CancellationToken token)
        {
            int retryCount = 0;
            const int maxRetries = 3;

            while (retryCount < maxRetries && !token.IsCancellationRequested)
            {
                var stillFailing = failedLines.Where(l => string.IsNullOrWhiteSpace(l.TranslatedText)).ToList();
                if (!stillFailing.Any()) break;

                retryCount++;
                LogToBatchSrtPopup($"  - Retry lần {retryCount}/{maxRetries} cho {stillFailing.Count} dòng...");

                var results = await _srtTranslationService.TranslateAllSrtLinesAsync(
                    stillFailing, _currentSrtApiProvider, _selectedSrtGenreValue, _selectedSrtTargetLanguage,
                    (progress) => { /* No UI update needed in batch mode */ },
                    token
                );

                foreach (var result in results)
                {
                    var line = stillFailing.FirstOrDefault(l => l.Index == result.Key);
                    if (line != null && result.Value.success && !string.IsNullOrWhiteSpace(result.Value.text))
                    {
                        line.TranslatedText = result.Value.text;
                    }
                }

                await Task.Delay(1000, token);
            }
        }

        private async Task TranslateSrtFileWithAioLauncherVip(List<SrtSubtitleLine> linesToTranslate, string fileName, CancellationToken token)
        {
            string systemInstruction;

            if (IsCustomPromptEnabled)
            {
                if (string.IsNullOrWhiteSpace(CurrentCustomPromptText))
                {
                    throw new Exception("Prompt tùy chỉnh đang được bật nhưng nội dung lại trống.");
                }
                systemInstruction = CurrentCustomPromptText.Trim() + CUSTOM_PROMPT_SUFFIX;
            }
            else
            {
                systemInstruction = _srtTranslationService.GetSystemInstructionForGeminiSrtTranslation(_selectedSrtGenreValue, _selectedSrtTargetLanguage);
            }

            var srtLinesForRequest = linesToTranslate.Select(l => new SrtLine(l.Index, l.OriginalText)).ToList();
            var response = await ApiService.StartVipTranslationAsync(_selectedSrtTargetLanguage, srtLinesForRequest, systemInstruction);

            if (response.Status == "Accepted")
            {
                string sessionId = response.SessionId;
                _currentLoadingSessionId = sessionId;
                try
                {
                    await PollForAioVipResultsForBatchSrt(sessionId, linesToTranslate, fileName, token);
                }
                catch (OperationCanceledException)
                {
                    // Cancel job on server when user cancels
                    if (!string.IsNullOrEmpty(sessionId))
                    {
                        try
                        {
                            await ApiService.CancelVipJobAsync(sessionId);
                        }
                        catch { }
                    }
                    throw;
                }
                finally
                {
                    _currentLoadingSessionId = null;
                }
            }
            else
            {
                throw new Exception(response.Message ?? "Lỗi không xác định từ VIP API");
            }
        }

        private async Task PollForAioVipResultsForBatchSrt(string sessionId, List<SrtSubtitleLine> linesToTranslate, string fileName, CancellationToken token)
        {
            var totalLines = linesToTranslate.Count;
            var translatedCount = 0;

            var startTime = DateTime.UtcNow;
            var timeout = TimeSpan.FromMinutes(15);
            int consecutiveEmptyPolls = 0;
            const int maxConsecutiveEmptyPolls = 60;

            while (!token.IsCancellationRequested)
            {
                if (DateTime.UtcNow - startTime > timeout)
                {
                    LogToBatchSrtPopup($"  ⚠ Timeout: Quá trình dịch VIP vượt quá 15 phút!");
                    return;
                }

                var result = await ApiService.GetVipResultsAsync(sessionId);

                if (result.NewLines != null && result.NewLines.Any())
                {
                    consecutiveEmptyPolls = 0;
                    foreach (var newLine in result.NewLines)
                    {
                        var lineToUpdate = linesToTranslate.FirstOrDefault(l => l.Index == newLine.Index);
                        if (lineToUpdate != null)
                        {
                            lineToUpdate.TranslatedText = newLine.TranslatedText;
                        }
                    }
                    translatedCount += result.NewLines.Count;
                    LogToBatchSrtPopup($"  - Đã dịch {translatedCount}/{totalLines} dòng");
                }
                else
                {
                    consecutiveEmptyPolls++;
                    if (consecutiveEmptyPolls >= maxConsecutiveEmptyPolls && !result.IsCompleted)
                    {
                        LogToBatchSrtPopup($"  ⚠ Cảnh báo: Không nhận được dữ liệu mới trong {consecutiveEmptyPolls} giây");
                    }
                }

                if (result.IsCompleted)
                {
                    if (!string.IsNullOrEmpty(result.ErrorMessage))
                    {
                        LogToBatchSrtPopup($"  ⚠ Cảnh báo: {result.ErrorMessage}");
                    }
                    var failedLines = linesToTranslate.Where(l => string.IsNullOrWhiteSpace(l.TranslatedText)).ToList();
                    if (failedLines.Any())
                    {
                        LogToBatchSrtPopup($"  - Đang retry {failedLines.Count} dòng thất bại...");
                        await RetryFailedSrtTranslationsForBatch(failedLines, fileName, token);
                    }

                    return;
                }

                await Task.Delay(2000, token); // Poll every 2 seconds for VIP API
            }
        }

        private async Task TranslateSrtFileWithThirdParty(List<SrtSubtitleLine> linesToTranslate, string fileName, CancellationToken token)
        {
            var results = await _srtTranslationService.TranslateAllSrtLinesAsync(
                linesToTranslate, _currentSrtApiProvider, _selectedSrtGenreValue, _selectedSrtTargetLanguage,
                (progress) =>
                {
                    if (progress % 10 == 0 || progress == linesToTranslate.Count)
                    {
                        Dispatcher.Invoke(() => LogToBatchSrtPopup($"  - Tiến độ: {progress}/{linesToTranslate.Count} dòng"));
                    }
                },
                token
            );

            foreach (var result in results)
            {
                var line = linesToTranslate.FirstOrDefault(l => l.Index == result.Key);
                if (line != null && result.Value.success)
                {
                    line.TranslatedText = result.Value.text;
                }
            }
        }
        private List<Task> _backgroundTranslationTasks = new List<Task>();

        private async void StartBatchProcessingButton_Click(object sender, RoutedEventArgs e)
        {
            // =================================================================================
            // 1. KIỂM TRA ĐẦU VÀO & KHỞI TẠO
            // =================================================================================
            if (string.IsNullOrWhiteSpace(BatchInputFolderPath) || !Directory.Exists(BatchInputFolderPath))
            {
                CustomMessageBox.Show("Vui lòng chọn thư mục chứa video hợp lệ.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }
            if (string.IsNullOrWhiteSpace(BatchOutputFolderPath))
            {
                CustomMessageBox.Show("Vui lòng chọn thư mục để lưu kết quả.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            // Lấy danh sách video
            var videoFiles = Directory.GetFiles(BatchInputFolderPath, "*.*", SearchOption.TopDirectoryOnly)
                .Where(f => new[] { ".mp4", ".mkv", ".avi", ".mov", ".wmv" }.Contains(Path.GetExtension(f).ToLowerInvariant()))
                .OrderBy(f => f, new NaturalStringComparer())
                .ToList();

            if (!videoFiles.Any())
            {
                CustomMessageBox.Show("Không tìm thấy file video nào.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            // Kiểm tra các tùy chọn
            bool isSpeechToTextMode = BatchModeSpeechToTextRadio.IsChecked == true;
            bool shouldTranslateFlag = BatchTranslateCheckBox.IsChecked == true;
            bool onlyCreateOriginalSrt = BatchOnlyCreateOriginalSrtCheckBox.IsChecked == true;
            bool shouldTranslate = shouldTranslateFlag && !onlyCreateOriginalSrt;

            if (isSpeechToTextMode)
            {
                var selectedModel = WhisperNetModelComboBox.SelectedItem as WhisperNetModelInfo;
                if (selectedModel == null || !WhisperNetModelManager.IsModelDownloaded(selectedModel.Name))
                {
                    CustomMessageBox.Show("Chưa tải model WhisperNet.", "Thiếu Model", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }
            }
            else
            {
                // Hardsub bắt buộc dùng Google Cloud OCR (AIO OCR)
                if (!await CheckGoogleAccountsAndShowGuideAsync()) return;
                RebuildOcrServices();
            }

            // Khóa UI
            StartBatchProcessingButton.IsEnabled = false;
            _batchCts = new CancellationTokenSource();
            var token = _batchCts.Token;
            BatchProcessingLog = "";
            _backgroundTranslationTasks.Clear();

            // Lấy tham số VSF từ giao diện
            var vsfParamsTemplate = GetVsfParametersFromUi();

            // Nếu có dịch thì khởi tạo service dịch
            if (shouldTranslate) RebuildSrtTranslationService();

            try
            {
                int counter = 0;
                int total = videoFiles.Count;

                // =================================================================================
                // 2. VÒNG LẶP XỬ LÝ TUẦN TỰ (Waterfall)
                // =================================================================================
                foreach (var videoPath in videoFiles)
                {
                    if (token.IsCancellationRequested) break;
                    counter++;

                    string videoFileName = Path.GetFileName(videoPath);
                    string videoNameWithoutExt = Path.GetFileNameWithoutExtension(videoPath);
                    string videoOutputDir = Path.Combine(BatchOutputFolderPath, videoNameWithoutExt);
                    Directory.CreateDirectory(videoOutputDir);

                    LogToBatchPopup($"=== [{counter}/{total}] Bắt đầu: {videoFileName} ===");

                    string srtPathForTranslate = null; // Đường dẫn file SRT gốc (nếu tạo thành công)

                    // ---------------------------------------------------------
                    // NHÁNH 1: SPEECH TO TEXT (WHISPER)
                    // ---------------------------------------------------------
                    if (isSpeechToTextMode)
                    {
                        LogToBatchPopup($"[STT] Đang chạy Whisper...");
                        var selectedModel = WhisperNetModelComboBox.SelectedItem as WhisperNetModelInfo;
                        var selectedLanguage = WhisperNetLanguageComboBox.SelectedValue?.ToString() ?? "auto";
                        string srtOutputPath = Path.Combine(videoOutputDir, $"{videoNameWithoutExt}_original.srt");

                        var p = new WhisperNetService.WhisperNetParameters
                        {
                            VideoPath = videoPath,
                            ModelName = selectedModel.Name,
                            Language = selectedLanguage,
                            OutputSrtPath = srtOutputPath,
                            TranslateToEnglish = false,
                            PreferGpu = true
                        };

                        // [AWAIT] Chờ Whisper xong mới đi tiếp
                        bool ok = await _whisperNetService.RunAsync(p, token);
                        if (ok && File.Exists(srtOutputPath))
                        {
                            LogToBatchPopup($"✓ Xong. Đã lưu SRT gốc.");
                            srtPathForTranslate = srtOutputPath;
                        }
                        else
                        {
                            LogToBatchPopup($"✗ Thất bại.");
                            continue; // Bỏ qua, sang video kế tiếp
                        }
                    }
                    // ---------------------------------------------------------
                    // NHÁNH 2: HARDSUB (VSF -> OCR)
                    // ---------------------------------------------------------
                    else
                    {
                        // --- A. CHẠY VSF (QUÉT SUB) ---
                        LogToBatchPopup($"Đang quét sub...");
                        var vsfParams = vsfParamsTemplate;
                        vsfParams.VideoPath = videoPath;
                        vsfParams.SpecificOutputDirectory = videoOutputDir;
                        vsfParams.ClearDirectories = true;
                        vsfParams.StartTime = null;
                        vsfParams.EndTime = null;

                        // [AWAIT] Chạy VSF, chặn luồng chính cho đến khi xong
                        var (vsfSuccess, imagesPath) = await _vsfService.RunVSFProcessAsync(vsfParams, token);

                        if (token.IsCancellationRequested) break;

                        if (!vsfSuccess || string.IsNullOrEmpty(imagesPath) || !Directory.Exists(imagesPath))
                        {
                            LogToBatchPopup($"✗ Thất bại hoặc không tìm thấy ảnh. Bỏ qua video này.");
                            continue;
                        }

                        LogToBatchPopup($" ✓ Quét xong.");

                        // --- B. CHẠY OCR (GOOGLE CLOUD - CHẶN & RETRY) ---
                        LogToBatchPopup($"[OCR] Started...");

                        // Lấy danh sách ảnh (Logic gốc: tìm .jpeg, .png, .jpg, .bmp)
                        var imageFiles = Directory.GetFiles(imagesPath, "*.*", SearchOption.TopDirectoryOnly)
                            .Where(f => f.EndsWith(".jpg", StringComparison.OrdinalIgnoreCase) ||
                                        f.EndsWith(".png", StringComparison.OrdinalIgnoreCase) ||
                                        f.EndsWith(".jpeg", StringComparison.OrdinalIgnoreCase) ||
                                        f.EndsWith(".bmp", StringComparison.OrdinalIgnoreCase))
                            .OrderBy(f => f, new NaturalStringComparer())
                            .ToList();

                        if (!imageFiles.Any())
                        {
                            LogToBatchPopup($"[OCR] ⚠ Không tìm thấy file ảnh nào để OCR. Bỏ qua.");
                            continue;
                        }

                        LogToBatchPopup($"[OCR] Bắt đầu OCR {imageFiles.Count} ảnh...");

                        // Tạo List SRT Line trong bộ nhớ
                        var srtLines = SrtFileUtils.CreateSrtLinesFromImageFiles(imageFiles);
                        var pathToLineMap = srtLines.ToDictionary(l => l.ImagePath, l => l);
                        string rawTextsDir = Path.Combine(videoOutputDir, "raw_texts_ocr");

                        // >> CHẠY OCR LẦN 1 (AWAIT) <<
                        await RunOcrTasks(
                            imageFiles,
                            rawTextsDir,
                            token,
                            (pct, msg) => { },
                            pathToLineMap,
                            isBatchMode: true,
                            forcedOcrMode: OcrMode.GoogleCloud
                        );

                        if (token.IsCancellationRequested) break;

                        // >> LOGIC RETRY THÔNG MINH (CHỈ RETRY LỖI API) <<
                        int maxRetries = 3;
                        int retryCount = 0;

                        while (retryCount < maxRetries && !token.IsCancellationRequested)
                        {
                            // Lọc các dòng bị lỗi API thực sự
                            // KHÔNG bao gồm Text Rỗng hoặc NO_TEXT_INDICATOR (vì đó là kết quả hợp lệ)
                            var failedLines = srtLines
                                .Where(l => !string.IsNullOrWhiteSpace(l.OriginalText) &&
                                            l.OriginalText != GeminiOcrService.NO_TEXT_INDICATOR &&
                                            (
                                                l.OriginalText.StartsWith("[Lỗi") ||
                                                l.OriginalText.Contains("HTTP 429") ||
                                                l.OriginalText.Contains("HTTP 500") ||
                                                l.OriginalText.Contains("HTTP 502") ||
                                                l.OriginalText.Contains("HTTP 503") ||
                                                l.OriginalText.Contains("Timeout") ||
                                                l.OriginalText.Contains("canceled")
                                            ))
                                .ToList();

                            if (failedLines.Count == 0) break; // Không có lỗi API -> Thoát

                            retryCount++;
                            LogToBatchPopup($"[OCR-Retry] Phát hiện {failedLines.Count} dòng lỗi API. Thử lại lần {retryCount}/{maxRetries}...");

                            // Backoff
                            await Task.Delay(TimeSpan.FromSeconds(5 * retryCount), token);

                            var failedImagePaths = failedLines.Select(l => l.ImagePath).ToList();
                            foreach (var line in failedLines) line.OriginalText = "[Đang OCR lại...]";

                            string retryRawDir = Path.Combine(rawTextsDir, $"retry_{retryCount}");

                            // Gọi OCR lại chỉ cho ảnh lỗi
                            await RunOcrTasks(failedImagePaths, retryRawDir, token, (p, m) => { }, pathToLineMap, true, OcrMode.GoogleCloud);

                            try { if (Directory.Exists(retryRawDir)) Directory.Delete(retryRawDir, true); } catch { }
                        }
                        var validLines = srtLines.Where(l => !string.IsNullOrWhiteSpace(l.OriginalText) &&
                                                             l.OriginalText != GeminiOcrService.NO_TEXT_INDICATOR &&
                                                             !l.OriginalText.StartsWith("[Lỗi") &&
                                                             !l.OriginalText.Contains("HTTP ") &&
                                                             l.OriginalText != "[Đang OCR lại...]").ToList();

                        if (validLines.Count == 0)
                        {
                            LogToBatchPopup($"[OCR] Video này không có nội dung phụ đề (hoặc lỗi toàn bộ).");
                            continue;
                        }

                        // Merge duplicate
                        var finalLines = new List<SrtSubtitleLine>();
                        if (validLines.Count > 0)
                        {
                            finalLines.Add(validLines[0]);
                            for (int i = 1; i < validLines.Count; i++)
                            {
                                if (string.Equals(validLines[i].OriginalText?.Trim(), finalLines.Last().OriginalText?.Trim(), StringComparison.OrdinalIgnoreCase))
                                {
                                    finalLines.Last().EndTime = validLines[i].EndTime;
                                    finalLines.Last().Duration = finalLines.Last().EndTime - finalLines.Last().StartTime;
                                }
                                else
                                {
                                    finalLines.Add(validLines[i]);
                                }
                            }
                        }

                        // Re-index
                        for (int i = 0; i < finalLines.Count; i++) finalLines[i].Index = i + 1;

                        // Lưu file SRT Gốc
                        string srtOut = Path.Combine(videoOutputDir, $"{videoNameWithoutExt}_original.srt");
                        await File.WriteAllTextAsync(srtOut, SrtFileUtils.GenerateSrtContent(finalLines, false), Encoding.UTF8, token);

                        LogToBatchPopup($"[OCR] ✓ Hoàn tất. Tạo được {finalLines.Count} dòng sub.");
                        srtPathForTranslate = srtOut;
                    }

                    // ---------------------------------------------------------
                    // NHÁNH 3: DỊCH (SONG SONG - FIRE AND FORGET)
                    // ---------------------------------------------------------
                    // Nếu đã có file SRT gốc (từ Whisper hoặc OCR) và user chọn dịch
                    if (shouldTranslate && !string.IsNullOrEmpty(srtPathForTranslate) && File.Exists(srtPathForTranslate))
                    {
                        LogToBatchPopup($"[Dịch] >> Đẩy video '{videoFileName}'...");

                        // Tạo Task dịch riêng, KHÔNG await ở đây để vòng lặp tiếp tục sang video sau ngay lập tức
                        var translationTask = ProcessTranslationBackgroundTask(
                            srtPathForTranslate,
                            videoOutputDir,
                            videoFileName,
                            videoNameWithoutExt,
                            token);

                        // Lưu task lại để chờ ở cuối cùng
                        _backgroundTranslationTasks.Add(translationTask);
                    }

                    // KẾT THÚC BƯỚC LẶP: Main Thread lập tức chuyển sang video tiếp theo (VSF Video B)
                    // Trong khi đó, Translation Task của Video A vẫn đang chạy ngầm.
                }

                // =================================================================================
                // 3. ĐỢI CÁC TASK DỊCH CUỐI CÙNG
                // =================================================================================
                if (_backgroundTranslationTasks.Any(t => !t.IsCompleted))
                {
                    LogToBatchPopup("\n--- Đang đợi các tác vụ dịch còn lại hoàn tất... ---");
                    await Task.WhenAll(_backgroundTranslationTasks);
                }

                if (token.IsCancellationRequested)
                    LogToBatchPopup("\nĐÃ DỪNG TIẾN TRÌNH.");
                else
                    LogToBatchPopup("\nĐÃ HOÀN TẤT TẤT CẢ.");

            }
            catch (Exception ex)
            {
                LogToBatchPopup($"\nLỗi không mong muốn: {ex.Message}");
            }
            finally
            {
                StartBatchProcessingButton.IsEnabled = true;
                _batchCts?.Dispose();
                _batchCts = null;
            }
        }

        private async Task ProcessTranslationBackgroundTask(
            string srtPath,
            string outputDir,
            string fileName,
            string nameNoExt,
            CancellationToken token)
        {
            try
            {
                LogToBatchPopup($"[Dịch-BG] Bắt đầu dịch cho: {fileName}...");

                var lines = SrtFileUtils.LoadFromFile(srtPath);
                if (lines == null || !lines.Any()) return;

                // Gọi hàm dịch (sử dụng lại hàm BatchTranslateSrtLines tôi đã cung cấp trước đó)
                // Hàm này dùng API setting hiện tại
                await BatchTranslateSrtLines(lines, token);

                if (token.IsCancellationRequested) return;

                // Lưu kết quả
                string translatedPath = Path.Combine(outputDir, $"{nameNoExt}_translated.srt");
                string content = SrtFileUtils.GenerateSrtContent(lines, true);

                // Đảm bảo thư mục tồn tại (dù đã tạo ở main thread nhưng an toàn vẫn hơn)
                Directory.CreateDirectory(outputDir);
                await File.WriteAllTextAsync(translatedPath, content, Encoding.UTF8, token);

                LogToBatchPopup($"[Dịch-BG] ✓ Hoàn tất dịch cho: {fileName}");
            }
            catch (Exception ex)
            {
                LogToBatchPopup($"[Dịch-BG] ✗ Lỗi dịch video {fileName}: {ex.Message}");
            }
        }
        private async Task BatchTranslateSrtLines(List<SrtSubtitleLine> lines, CancellationToken token)
        {
            // Tái sử dụng logic của _srtTranslationService
            // Lấy thông tin từ cấu hình (đã được nạp vào _srtTranslationService qua RebuildSrtTranslationService)

            // Chia batch nếu dùng API bên thứ 3, hoặc dùng AIO Launcher
            if (_currentSrtApiProvider == SrtApiProvider.AIOLauncher || _currentSrtApiProvider == SrtApiProvider.AIOLauncherVIP)
            {
                // Dùng hàm TranslateWithAioLauncherApi nhưng sửa lại để nhận List thay vì đọc từ UI
                // Do hàm TranslateWithAioLauncherApi hiện tại gắn chặt với UI (SrtSubtitleLinesView), ta viết lại logic ngắn gọn ở đây

                bool useVipApi = _currentSrtApiProvider == SrtApiProvider.AIOLauncherVIP;
                bool acceptPartial = false;
                string systemInstruction;
                if (IsCustomPromptEnabled && !string.IsNullOrWhiteSpace(CurrentCustomPromptText))
                    systemInstruction = CurrentCustomPromptText.Trim() + CUSTOM_PROMPT_SUFFIX;
                else
                    systemInstruction = _srtTranslationService.GetSystemInstructionForGeminiSrtTranslation(_selectedSrtGenreValue, _selectedSrtTargetLanguage);

                // Gửi request
                var srtLinesForRequest = lines.Select(l => new SrtLine(l.Index, l.OriginalText)).ToList();
                
                string sessionId;
                if (useVipApi)
                {
                    var response = await ApiService.StartVipTranslationAsync(_selectedSrtTargetLanguage, srtLinesForRequest, systemInstruction);
                    if (response.Status != "Accepted")
                    {
                        throw new Exception($"Lỗi khởi tạo dịch VIP: {response.Message}");
                    }
                    sessionId = response.SessionId;
                }
                else
                {
                    var response = await ApiService.StartTranslationJobAsync(_selectedSrtGenreValue, _selectedSrtTargetLanguage, srtLinesForRequest, systemInstruction, acceptPartial);
                    if (response.Status != "Accepted" && response.Status != "PartialContent")
                    {
                        throw new Exception($"Lỗi khởi tạo dịch AIO: {response.Message}");
                    }
                    sessionId = response.SessionId;
                }

                // Poll kết quả
                try
                {
                    while (!token.IsCancellationRequested)
                    {
                        await Task.Delay(useVipApi ? 2000 : 1000, token);

                        // --- FIX LỖI CS0173 BẮT ĐẦU TỪ ĐÂY ---
                        // Khai báo biến chung để hứng dữ liệu từ 2 loại response khác nhau
                        List<TranslatedSrtLine> newLines = null;
                        bool isCompleted = false;
                        string errorMessage = null;

                        // Tách logic gọi API ra 2 nhánh if-else rõ ràng
                        if (useVipApi)
                        {
                            var result = await ApiService.GetVipResultsAsync(sessionId);
                            newLines = result.NewLines;
                            isCompleted = result.IsCompleted;
                            errorMessage = result.ErrorMessage;
                            Debug.WriteLine($"[BatchTranslate] VIP Poll: Completed={isCompleted}, Lines={newLines?.Count ?? 0}");
                        }
                        else
                        {
                            var result = await ApiService.GetTranslationResultsAsync(sessionId);
                            newLines = result.NewLines;
                            isCompleted = result.IsCompleted;
                            errorMessage = result.ErrorMessage;
                            Debug.WriteLine($"[BatchTranslate] AIO Poll: Completed={isCompleted}, Lines={newLines?.Count ?? 0}");
                        }

                        // Xử lý dữ liệu đã hứng được
                        if (newLines != null)
                        {
                            foreach (var newLine in newLines)
                            {
                                var target = lines.FirstOrDefault(l => l.Index == newLine.Index);
                                if (target != null) target.TranslatedText = newLine.TranslatedText;
                            }
                        }

                        if (isCompleted)
                        {
                            if (!string.IsNullOrEmpty(errorMessage))
                                LogToBatchPopup($"[Dịch {(useVipApi ? "VIP" : "AIO")}] Cảnh báo server: {errorMessage}");
                            break;
                        }
                        // --- KẾT THÚC ĐOẠN FIX ---
                    }
                }
                catch (OperationCanceledException)
                {
                    // Cancel job on server when user cancels
                    if (!string.IsNullOrEmpty(sessionId))
                    {
                        try
                        {
                            if (useVipApi)
                                await ApiService.CancelVipJobAsync(sessionId);
                            else
                                await ApiService.CancelTranslationJobAsync(sessionId);
                        }
                        catch { }
                    }
                    throw;
                }
            }
            else
            {
                // Dùng API bên thứ 3 (Gemini/ChatGPT/Chutes)
                // Gọi TranslateAllSrtLinesAsync của service
                // Hàm này trả về Dictionary<int, (bool success, string text)>
                var results = await _srtTranslationService.TranslateAllSrtLinesAsync(
                    lines,
                    _currentSrtApiProvider,
                    _selectedSrtGenreValue,
                    _selectedSrtTargetLanguage,
                    (progress) => { /* Update log progress nếu cần */ },
                    token
                );

                foreach (var res in results)
                {
                    var target = lines.FirstOrDefault(l => l.Index == res.Key);
                    if (target != null && res.Value.success)
                    {
                        target.TranslatedText = res.Value.text;
                    }
                }
            }
        }

        private void LogToBatchPopup(string message)
        {
            Dispatcher.Invoke(() =>
            {
                BatchProcessingLog += $"[{DateTime.Now:HH:mm:ss}] {message}\n";
                if (FindName("BatchLogTextBlock") is TextBlock logTextBlock && VisualTreeHelper.GetParent(logTextBlock) is ScrollViewer scrollViewer)
                {
                    scrollViewer.ScrollToEnd();
                }
            });
        }
        private async Task ConcatSegmentsToFinalOutputAsync(
    List<VideoSegmentInfo> segments,
    string ffmpegPath,
    VideoExportSettings settings,
    string tempAssPath,
    string outputPath,
    GenerateVideoWindow progressWindow,
    CancellationToken cancellationToken)
        {
            var ordered = segments.OrderBy(s => s.OutputStart).ToList();
            string listPath = TempFileManager.CreateTempFile(".txt");
            var sb = new StringBuilder();
            foreach (var s in ordered)
            {
                if (File.Exists(s.OutputPath))
                    sb.AppendLine($"file '{s.OutputPath.Replace("\\", "/").Replace("'", "'\\''")}'");
            }
            await WriteTextNoBomAsync(listPath, sb.ToString(), cancellationToken);
            TempFileManager.RegisterForCleanup(listPath);
            string intermediatePath = TempFileManager.CreateTempFile(".mp4");
            TempFileManager.RegisterForCleanup(intermediatePath);

            var concatArgs = $"-y -hide_banner -f concat -safe 0 -i \"{listPath}\" -c copy -avoid_negative_ts make_zero \"{intermediatePath}\"";
            await RunFfmpegAsync(ffmpegPath, concatArgs, cancellationToken);
            var (_, bgClips) = ClassifyAudioClipsForExport();
            if (!bgClips.Any())
            {
                var finalArgs = new StringBuilder();
                finalArgs.Append($"-y -i \"{intermediatePath}\" ");
                if (settings.VideoCodec.Contains("nvenc"))
                {
                    string nvencPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "p4";
                    finalArgs.Append($"-c:v {settings.VideoCodec} -preset {nvencPreset} -cq {settings.Crf} ");
                }
                else
                {
                    string cpuPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "medium";
                    finalArgs.Append($"-c:v {settings.VideoCodec} -preset {cpuPreset} -crf {settings.Crf} ");
                }

                finalArgs.Append("-c:a copy "); 
                finalArgs.Append($"\"{outputPath}\"");

                progressWindow.UpdateProgress(92, "Đang mã hóa video cuối cùng...");
                await ExecuteFfmpegWithProgress(ffmpegPath, finalArgs.ToString(), progressWindow, outputPath, cancellationToken);
            }
            else
            {
                var finalArgs = new StringBuilder();
                finalArgs.Append($"-y -i \"{intermediatePath}\" ");
                var inputMap = new Dictionary<string, int>();
                int idx = 1;
                var bgPaths = bgClips.Select(b => b.FilePath).Distinct().ToList();
                foreach (var p in bgPaths)
                {
                    finalArgs.Append($"-i \"{p}\" ");
                    inputMap[p] = idx++;
                }
                var complex = new StringBuilder();
                var audios = new List<string> { "[0:a]" };
                foreach (var bg in bgClips)
                {
                    if (!inputMap.ContainsKey(bg.FilePath)) continue;
                    int i = inputMap[bg.FilePath];
                    string lbl = $"bg_{i}";
                    string vol = DbToGain(bg.VolumeDb).ToString(CultureInfo.InvariantCulture);
                    double start = MapSourceTimeToOutputTimelineSeconds(bg.StartTime.TotalSeconds, segments);
                    long delay = (long)(start * 1000);

                    complex.Append($"[{i}:a]volume={vol},adelay={delay}|{delay}[{lbl}];");
                    audios.Add($"[{lbl}]");
                }
                complex.Append($"{string.Join("", audios)}amix=inputs={audios.Count}:duration=first:dropout_transition=0[aout]");

                string script = TempFileManager.CreateTempFile(".txt");
                await WriteTextNoBomAsync(script, complex.ToString(), cancellationToken);
                finalArgs.Append($"-filter_complex_script \"{script}\" -map 0:v -map \"[aout]\" ");
                if (settings.VideoCodec.Contains("nvenc"))
                {
                    string nvencPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "p4";
                    finalArgs.Append($"-c:v {settings.VideoCodec} -preset {nvencPreset} -cq {settings.Crf} ");
                }
                else
                {
                    string cpuPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "medium";
                    finalArgs.Append($"-c:v {settings.VideoCodec} -preset {cpuPreset} -crf {settings.Crf} ");
                }
                finalArgs.Append("-c:a aac -b:a 192k ");
                finalArgs.Append($"\"{outputPath}\"");
                progressWindow.UpdateProgress(92, "Đang mã hóa video và mix audio...");
                await ExecuteFfmpegWithProgress(ffmpegPath, finalArgs.ToString(), progressWindow, outputPath, cancellationToken, null);
            }

            progressWindow.UpdateProgress(100, "Hoàn tất!");
            progressWindow.MarkAsComplete(true);
        }
        private TimeSpan MapSourceTimeToOutputTimeline(TimeSpan sourceTime, List<VideoSegmentInfo> segments)
        {
            foreach (var segment in segments.OrderBy(s => s.SourceStart))
            {
                if (sourceTime >= segment.SourceStart && sourceTime < segment.SourceEnd)
                {
                    double progressInSegment = (sourceTime - segment.SourceStart).TotalSeconds;
                    double segmentRatio = segment.SourceDuration.TotalSeconds > 0
                        ? progressInSegment / segment.SourceDuration.TotalSeconds
                        : 0;

                    double offsetInOutput = segmentRatio * segment.TargetDuration.TotalSeconds;
                    return segment.OutputStart + TimeSpan.FromSeconds(offsetInOutput);
                }
            }
            return sourceTime;
        }
        private async Task ExecuteStaticSmartCutExportAsync(
    string ffmpegPath,
    VideoExportSettings settings,
    GenerateVideoWindow progressWindow,
    CancellationToken cancellationToken)
        {
            progressWindow.UpdateProgress(1, "Đang kiểm tra video...");
            var mainVideoClip = TimelineClips.FirstOrDefault(c => c.ClipType == TimelineClipType.Video);
            if (mainVideoClip == null || mainVideoClip.SourceData is not MediaAsset mainVideoAsset
                || string.IsNullOrWhiteSpace(mainVideoAsset.FilePath) || !File.Exists(mainVideoAsset.FilePath))
            {
                throw new Exception("Không tìm thấy video chính để xuất ở chế độ Static");
            }
            var videoDuration = mainVideoAsset.Duration;
            const double maxMinutesForDirectProcessing = 30;

            if (videoDuration.TotalMinutes >= maxMinutesForDirectProcessing)
            {
                progressWindow.UpdateProgress(2, $"Video dài {videoDuration.TotalMinutes:F1} phút phân đoạn...");
                await ExecuteStaticSmartCutExportWithSegmentationAsync(
                    ffmpegPath,
                    settings,
                    progressWindow,
                    cancellationToken
                );
                return;
            }
            progressWindow.UpdateProgress(2, "Đang thu tính toán...");
            var mapItems = await BuildSmartCutMapItemsAsync();
            if (mapItems == null || mapItems.Count == 0)
            {
                throw new InvalidOperationException("Không tìm thấy dữ liệu Voice/Subtitle treen timeline.");
            }
            var segments = await BuildSegmentListForParallelProcessing(mainVideoAsset, mapItems, cancellationToken, alignToKeyframes: false);
            if (segments == null || segments.Count == 0)
            {
                throw new InvalidOperationException("Không thể tạo segments xử lý video.");
            }

            _smartCutSegmentMaps = segments.Select(s => new SmartCutSegmentMap
            {
                SourceStart = s.SourceStart,
                SourceEnd = s.SourceEnd,
                FinalStart = s.OutputStart,
                FinalEnd = s.OutputEnd,
                IsGap = s.IsSilenceGap,
                Scale = s.SourceDuration.TotalSeconds > 0.001 ? (s.TargetDuration.TotalSeconds / s.SourceDuration.TotalSeconds) : 1.0
            }).ToList();
            var subtitleTimeline = new List<(SrtSubtitleLine Line, TimeSpan FinalStart, TimeSpan FinalEnd)>();
            var contentSegments = segments.Where(s => !s.IsSilenceGap).OrderBy(s => s.SegmentIndex).ToList();
            var orderedMapItems = mapItems.OrderBy(m => m.FinalStart).ToList();
            int segIdx = 0;
            for (int i = 0; i < orderedMapItems.Count && segIdx < contentSegments.Count; i++)
            {
                var item = orderedMapItems[i];
                var seg = contentSegments[segIdx];
                double timeDiff = Math.Abs(seg.SourceStart.TotalSeconds - item.Line.StartTime.TotalSeconds);

                if (timeDiff < 3.0)
                {
                    subtitleTimeline.Add((item.Line, seg.OutputStart, seg.OutputEnd));
                    segIdx++;
                }
                else{ }
            }
            _smartCutSubtitleTimeline = subtitleTimeline;
            _actualContentDuration = segments.Last().OutputEnd;
            _totalTimelineDuration = _actualContentDuration;
            
            // Check if there are subtitles/text to burn into the video
            // Priority: check timeline first (user may have deleted subtitles from timeline)
            bool hasSubtitlesToBurn = HasSubtitlesOrTextOnTimeline() || HasSubtitlesForSmartCutExport(subtitleTimeline);
            
            string tempAssPath = null;
            if (hasSubtitlesToBurn)
            {
                string assSmartContent = GenerateAssFileContentForSmartCut(settings.ResolutionWidth, settings.ResolutionHeight, subtitleTimeline);
                tempAssPath = TempFileManager.CreateTempFile(".ass");
                await File.WriteAllTextAsync(tempAssPath, assSmartContent, Encoding.UTF8, cancellationToken);
                TempFileManager.RegisterForCleanup(tempAssPath);
            }
            
            var argsBuilder = new StringBuilder();
            argsBuilder.Append("-y -hide_banner ");
            string finalGpuAccel = "none";
            string finalVideoCodec = settings.VideoCodec;
            if (settings.GpuAcceleration == "auto")
            {
                var allGpus = await FfmpegGpuDetector.GetAvailableGpusAsync();
                var bestGpu = FfmpegGpuDetector.GetBestAvailableGpu(allGpus);
                if (bestGpu != null && bestGpu.FfmpegValue != "none")
                {
                    finalGpuAccel = bestGpu.FfmpegValue;
                    finalVideoCodec = bestGpu.RecommendedCodec;
                }
            }
            else if (!string.IsNullOrEmpty(settings.GpuAcceleration) && settings.GpuAcceleration != "none")
            {
                finalGpuAccel = settings.GpuAcceleration;
            }

            if (finalGpuAccel != "none")
            {
                argsBuilder.Append($"-hwaccel {finalGpuAccel} ");
            }

            var inputMap = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            int inputIndex = 0;

            argsBuilder.Append($"-i \"{mainVideoAsset.FilePath}\" ");
            inputMap[mainVideoAsset.FilePath] = inputIndex++;

            var imageOverlayClips = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Image)
                .ToList();

            foreach (var imgClip in imageOverlayClips)
            {
                if (imgClip.SourceData is not MediaAsset imgAsset || string.IsNullOrWhiteSpace(imgAsset.FilePath) || !File.Exists(imgAsset.FilePath))
                    continue;

                if (inputMap.ContainsKey(imgAsset.FilePath))
                    continue;

                argsBuilder.Append($"-stream_loop -1 -i \"{imgAsset.FilePath}\" ");
                inputMap[imgAsset.FilePath] = inputIndex++;
            }

            var (_, bgFxClips) = ClassifyAudioClipsForExport();
            foreach (var bgClip in bgFxClips)
            {
                if (bgClip == null || string.IsNullOrWhiteSpace(bgClip.FilePath) || !File.Exists(bgClip.FilePath))
                    continue;
                if (inputMap.ContainsKey(bgClip.FilePath))
                    continue;

                argsBuilder.Append($"-i \"{bgClip.FilePath}\" ");
                inputMap[bgClip.FilePath] = inputIndex++;
            }

            var filterComplex = new StringBuilder();
            var videoSegments = new List<string>();
            var voiceAudioLabels = new List<string>();
            var videoAudioLabels = new List<string>();

            double mainVideoVolumeDb = ResolveDbOrDefault(mainVideoAsset.VolumeDb, 0.0);
            int W = settings.ResolutionWidth;
            int H = settings.ResolutionHeight;

            double zoom = Math.Max(mainVideoAsset.Scale, 0.0001);
            double posX = mainVideoAsset.PositionX;
            double posY = mainVideoAsset.PositionY;
            string cover = $"max({W}/iw\\,{H}/ih)";
            string zoomExpr = $"max({zoom.ToString(CultureInfo.InvariantCulture)}\\,1)";
            string eff = $"({cover})*({zoomExpr})";
            string scaleFilter = $"scale=w=ceil(iw*{eff}):h=ceil(ih*{eff})";
            string cx = $"(iw - {W})/2 - ({posX.ToString(CultureInfo.InvariantCulture)} - 0.5)*{W}";
            string cy = $"(ih - {H})/2 - ({posY.ToString(CultureInfo.InvariantCulture)} - 0.5)*{H}";
            string cropX = $"x='max(0\\,min(iw-{W}\\,({cx})))'";
            string cropY = $"y='max(0\\,min(ih-{H}\\,({cy})))'";
            string panZoomFilter = $"{scaleFilter},crop={W}:{H}:{cropX}:{cropY},scale='trunc(iw/2)*2:trunc(ih/2)*2'";

            int segIndex = 0;
            foreach (var segment in segments.OrderBy(s => s.OutputStart))
            {
                double startSrc = segment.SourceStartExact > 0 ? segment.SourceStartExact : segment.SourceStart.TotalSeconds;
                double endSrc = segment.SourceEndExact > 0 ? segment.SourceEndExact : segment.SourceEnd.TotalSeconds;
                double targetDur = segment.TargetDurationExact > 0 ? segment.TargetDurationExact : segment.TargetDuration.TotalSeconds;
                double speed = segment.RequiredSpeed;
                if (speed <= 0.0001) speed = 1.0;

                const double fps = 30.0; 
                double startSrcQ = SnapToFps(startSrc, fps);
                double endSrcQ = SnapToFps(endSrc, fps);
                double targetDurQ = Math.Max(1.0 / fps, SnapToFps(targetDur, fps));

                string startStr = Fmt6(startSrcQ);
                string endStr = Fmt6(endSrcQ);
                string speedStr = speed.ToString("0.################", CultureInfo.InvariantCulture);
                string targetDurStr = Fmt6(targetDurQ);

                filterComplex.Append($"[0:v]trim=start={startStr}:end={endStr},setpts=PTS-STARTPTS");
                if (Math.Abs(speed - 1.0) > 0.0001)
                {
                    filterComplex.Append($",setpts=PTS/{speedStr}");
                }
                filterComplex.Append($",tpad=stop_mode=clone:stop_duration={targetDurStr},trim=duration={targetDurStr},setpts=PTS-STARTPTS");
                filterComplex.Append($",{panZoomFilter}[v{segIndex}];");
                videoSegments.Add($"[v{segIndex}]");

                bool hasVoice = segment.VoiceClip != null && !string.IsNullOrWhiteSpace(segment.VoiceClip.FilePath) && File.Exists(segment.VoiceClip.FilePath);
                if (hasVoice)
                {
                    double ttsDb = DbToGain(ResolveDbOrDefault(segment.VoiceClip.VolumeDb, +3.0));
                    filterComplex.Append($"amovie='{EscapePathForFilterScript(segment.VoiceClip.FilePath)}'");
                    if (Math.Abs(segment.VoiceClip.Speed - 1.0) > 0.01)
                    {
                        var ttsAtempo = BuildAtempoChain(segment.VoiceClip.Speed);
                        if (!string.IsNullOrEmpty(ttsAtempo))
                        {
                            filterComplex.Append($",{ttsAtempo}");
                        }
                    }
                    filterComplex.Append($",atrim=duration={targetDurStr},asetpts=PTS-STARTPTS,apad=pad_dur={targetDurStr},atrim=duration={targetDurStr},asetpts=PTS-STARTPTS,volume={ttsDb.ToString(CultureInfo.InvariantCulture)},aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a_voice{segIndex}];");
                    voiceAudioLabels.Add($"[a_voice{segIndex}]");
                }
                else
                {
                    filterComplex.Append($"anullsrc=r=44100:cl=stereo,atrim=duration={targetDurStr},asetpts=PTS-STARTPTS[a_voice{segIndex}];");
                    voiceAudioLabels.Add($"[a_voice{segIndex}]");
                }
                filterComplex.Append($"[0:a]atrim=start={startStr}:end={endStr},asetpts=PTS-STARTPTS");
                filterComplex.Append($",volume={DbToGain(mainVideoVolumeDb).ToString(CultureInfo.InvariantCulture)}");
                string videoAtempoChain = BuildAtempoChain(speed);
                if (!string.IsNullOrEmpty(videoAtempoChain))
                {
                    filterComplex.Append($",{videoAtempoChain}");
                    filterComplex.Append(",asetpts=PTS-STARTPTS");
                }
                filterComplex.Append(",aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo");
                filterComplex.Append(",apad");
                filterComplex.Append($",atrim=duration={targetDurStr}");
                filterComplex.Append($",asetpts=PTS-STARTPTS[a_vid{segIndex}];");
                videoAudioLabels.Add($"[a_vid{segIndex}]");
                segIndex++;
            }
            filterComplex.Append($"{string.Join("", videoSegments)}concat=n={videoSegments.Count}:v=1:a=0[v_concat];");
            filterComplex.Append($"{string.Join("", voiceAudioLabels)}concat=n={voiceAudioLabels.Count}:v=0:a=1[a_voice];");
            filterComplex.Append($"{string.Join("", videoAudioLabels)}concat=n={videoAudioLabels.Count}:v=0:a=1[a_vid];");

            string currentVideoTag = "v_concat";
            int overlayIdx = 0;
            double refW = CurrentProject?.ProjectReferenceVideoWidth > 0 ? CurrentProject.ProjectReferenceVideoWidth : 1280.0;
            double refH = CurrentProject?.ProjectReferenceVideoHeight > 0 ? CurrentProject.ProjectReferenceVideoHeight : 720.0;
            double scaleXFactor = settings.ResolutionWidth / refW;
            double scaleYFactor = settings.ResolutionHeight / refH;
            foreach (var imgClip in imageOverlayClips)
            {
                var imgAsset = (MediaAsset)imgClip.SourceData;
                if (imgAsset == null || !inputMap.TryGetValue(imgAsset.FilePath, out int imgInputIndex))
                    continue;

                double imgStart = MapSourceTimeToOutputTimelineSeconds(imgClip.StartTime.TotalSeconds, segments);
                double imgEnd = MapSourceTimeToOutputTimelineSeconds(imgClip.EndTime.TotalSeconds, segments);
                if (imgEnd < imgStart) imgEnd = imgStart;
                if (imgEnd <= imgStart + 1e-6) continue;

                double imgAR = imgAsset.Height > 0 ? (double)imgAsset.Width / imgAsset.Height : 1.0;
                double initW_ref, initH_ref;
                if ((refW / refH) > imgAR) { initH_ref = refH; initW_ref = initH_ref * imgAR; }
                else { initW_ref = refW; initH_ref = initW_ref / imgAR; }

                double finalW_out = initW_ref * Math.Max(imgAsset.ScaleX, 0.0001) * scaleXFactor;
                double finalH_out = initH_ref * Math.Max(imgAsset.ScaleY, 0.0001) * scaleYFactor;
                int outW = Math.Max(1, (int)Math.Round(finalW_out));
                int outH = Math.Max(1, (int)Math.Round(finalH_out));
                double centerX_out = imgAsset.PositionX * refW * scaleXFactor;
                double centerY_out = imgAsset.PositionY * refH * scaleYFactor;

                double radians = (imgAsset.Rotation) * Math.PI / 180.0;

                string processedLabel = $"processed_img_{overlayIdx}";
                string overLabel = $"v_img_{overlayIdx}";
                filterComplex.Append(
                    $"[{imgInputIndex}:v]" +
                    $"scale={outW}:{outH}:flags=lanczos," +
                    $"format=rgba," +
                    $"rotate='{radians.ToString(CultureInfo.InvariantCulture)}:c=none:ow=hypot(iw\\,ih):oh=hypot(iw\\,ih)'" +
                    $"[{processedLabel}];");
                string ox = $"{centerX_out.ToString(CultureInfo.InvariantCulture)}-overlay_w/2";
                string oy = $"{centerY_out.ToString(CultureInfo.InvariantCulture)}-overlay_h/2";

                string enableExpr = $"between(t,{imgStart.ToString("0.########", CultureInfo.InvariantCulture)},{imgEnd.ToString("0.########", CultureInfo.InvariantCulture)})";

                filterComplex.Append(
                    $"[{currentVideoTag}][{processedLabel}]" +
                    $"overlay=x='{ox}':y='{oy}':eval=init:shortest=1:format=auto:enable='{enableExpr}'" +
                    $"[{overLabel}];");

                currentVideoTag = overLabel;
                overlayIdx++;
            }
            _smartCutSubtitleTimeline = subtitleTimeline;
            _smartCutSegmentMaps = segments.Select(s => new SmartCutSegmentMap
            {
                SourceStart = s.SourceStart,
                SourceEnd = s.SourceEnd,
                FinalStart = s.OutputStart,
                FinalEnd = s.OutputEnd,
                IsGap = s.IsSilenceGap,
                Scale = s.SourceDuration.TotalSeconds > 0 ? (s.TargetDuration.TotalSeconds / s.SourceDuration.TotalSeconds) : 1.0
            }).ToList();

            _actualContentDuration = segments.Last().OutputEnd;
            _totalTimelineDuration = _actualContentDuration;

            if (CurrentProject?.Subtitles != null && CurrentProject.Subtitles.Count > 0)
            {
                _exportCachedBlurIntervals = CurrentProject.Subtitles
                    .OrderBy(s => s.StartTime)
                    .Select(s => (s.StartTime, s.EndTime))
                    .ToList();
            }
            else
            {
                _exportCachedBlurIntervals = null;
            }
            bool burnSubsForStatic = _smartCutSubtitleTimeline != null && _smartCutSubtitleTimeline.Count > 0;
            string blurChainStatic = BuildBlurBoxFilter(
                currentVideoTag,           
                "video_blur_e",
                CurrentProject,
                burnSubsForStatic,         
                _actualContentDuration     
            );
            filterComplex.Append(blurChainStatic + ";");
            currentVideoTag = "video_blur_e";
            if (_isVideoFlipEnabled)
            {
                filterComplex.Append($"[{currentVideoTag}]hflip[video_flipped];");
                currentVideoTag = "video_flipped";
            }
            string fontsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Fonts");
            if (!Directory.Exists(fontsDir))
                fontsDir = @"C:\Windows\Fonts";
            
            // Conditionally apply subtitle filter based on hasSubtitlesToBurn
            if (hasSubtitlesToBurn && !string.IsNullOrEmpty(tempAssPath) && File.Exists(tempAssPath))
            {
                string escapedAss = EscapePathForFilterScript(tempAssPath);
                string escapedFonts = EscapePathForFilterScript(fontsDir);
                filterComplex.Append(
                    $"[{currentVideoTag}]setsar=1[video_out_scaled];" +
                    $"[video_out_scaled]subtitles=filename='{escapedAss}':fontsdir='{escapedFonts}':charenc=UTF-8[video_out];"
                );
            }
            else
            {
                // No subtitles to burn - just set SAR and output
                filterComplex.Append($"[{currentVideoTag}]setsar=1[video_out];");
            }
            string finalDurStr = _actualContentDuration.TotalSeconds.ToString(CultureInfo.InvariantCulture);
            filterComplex.Append($"[a_voice]apad=whole_dur={finalDurStr},atrim=duration={finalDurStr}[a_voice_trimmed];");
            filterComplex.Append($"[a_vid]apad=whole_dur={finalDurStr},atrim=duration={finalDurStr}[a_vid_trimmed];");

            var finalMixInputs = new List<string> { "[a_voice_trimmed]", "[a_vid_trimmed]" };
            foreach (var bg in bgFxClips)
            {
                if (bg == null || !inputMap.TryGetValue(bg.FilePath, out int bgInputIndex)) continue;
                string processedLabel = $"bgp_{bgInputIndex}";
                string finalBgLabel = $"bg_{bgInputIndex}";
                var bgFilters = new List<string>
                {
                    $"volume={DbToGain(bg.VolumeDb).ToString(CultureInfo.InvariantCulture)}",
                    "aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo"
                };
                filterComplex.Append($"[{bgInputIndex}:a]{string.Join(",", bgFilters)}[{processedLabel}];");

                double mappedBgStartSec = MapSourceTimeToOutputTimeline(bg.StartTime, segments).TotalSeconds;
                long delayMs = (long)Math.Max(0, mappedBgStartSec * 1000.0);
                filterComplex.Append($"[{processedLabel}]adelay={delayMs}|{delayMs}[{finalBgLabel}];");
                finalMixInputs.Add($"[{finalBgLabel}]");
            }

            filterComplex.Append($"{string.Join("", finalMixInputs)}amix=inputs={finalMixInputs.Count}:duration=first:normalize=0:dropout_transition=0,alimiter=limit=0.95[final_audio]");

            var filterScriptPath = TempFileManager.CreateTempFile(".txt");
            await WriteTextNoBomAsync(filterScriptPath, filterComplex.ToString(), cancellationToken);
            TempFileManager.RegisterForCleanup(filterScriptPath);

            argsBuilder.Append($" -filter_complex_script \"{filterScriptPath}\" -filter_threads 0 ");
            argsBuilder.Append("-map \"[video_out]\" -map \"[final_audio]\" ");

            bool isHardwareEncoder = false;
            if (!string.IsNullOrWhiteSpace(finalVideoCodec))
            {
                string lowerCodec = finalVideoCodec.ToLowerInvariant();
                if (lowerCodec.Contains("_nvenc") || lowerCodec.Contains("_qsv") || lowerCodec.Contains("_amf"))
                {
                    isHardwareEncoder = true;
                }
            }

            if (isHardwareEncoder)
            {
                argsBuilder.Append($"-c:v {finalVideoCodec} ");
                argsBuilder.Append($"-cq {settings.Crf} ");
                string hwPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "p4";
                argsBuilder.Append($"-preset {hwPreset} ");
                const int fps = 30;
                argsBuilder.Append($"-vsync cfr -r {fps} ");
            }
            else
            {
                string cpuCodec = !string.IsNullOrWhiteSpace(finalVideoCodec) ? finalVideoCodec : "libx264";
                argsBuilder.Append($"-c:v {cpuCodec} ");
                argsBuilder.Append($"-crf {settings.Crf} ");
                string cpuPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "medium";
                argsBuilder.Append($"-preset {cpuPreset} ");
                const int fps = 30; 
                argsBuilder.Append($"-vsync cfr -r {fps} ");
            }

            if (settings.IsThreadLimitEnabled && !isHardwareEncoder)
            {
                argsBuilder.Append($"-threads {settings.ThreadLimit} ");
            }
            if (!string.IsNullOrEmpty(settings.Tune)) argsBuilder.Append($"-tune {settings.Tune} ");
            if (!string.IsNullOrEmpty(settings.PixelFormat)) argsBuilder.Append($"-pix_fmt {settings.PixelFormat} ");

            argsBuilder.Append($"-c:a aac -b:a {settings.AudioBitrate} -ar 44100 ");
            if (settings.ForceStereo) argsBuilder.Append("-ac 2 ");
            argsBuilder.Append("-movflags +faststart ");
            argsBuilder.Append("-shortest ");
            argsBuilder.Append($"\"{settings.OutputPath}\"");
            Debug.WriteLine($"[STATIC-MODE] Command: ffmpeg {argsBuilder}");
            progressWindow.UpdateProgress(5, "Đang bắt đầu mã hóa video...");
            await ExecuteFfmpegWithProgress(ffmpegPath, argsBuilder.ToString(), progressWindow, settings.OutputPath, cancellationToken, _actualContentDuration.TotalSeconds);
            progressWindow.UpdateProgress(100, "Hoàn tất!");
            progressWindow.MarkAsComplete(true);
        }

        #region Long Video Segmentation Support
        private sealed class LongVideoSegmentMetadata
        {
            public int SegmentIndex { get; set; }
            public TimeSpan SourceStart { get; set; }
            public TimeSpan SourceEnd { get; set; }
            public TimeSpan Duration => SourceEnd - SourceStart;
            public string OutputPath { get; set; }
            public List<SmartCutMapItem> MapItems { get; set; } = new();
            public List<TimelineClipViewModel> Overlays { get; set; } = new();
            public List<TimelineAudioClip> AudioClips { get; set; } = new();
            public TimeSpan OutputTimelineOffset { get; set; } 
            public TimeSpan SourceOffsetFromStart { get; set; }
            public TimeSpan EstimatedOutputDuration { get; set; }
            public TimeSpan ActualOutputDuration { get; set; }
        }
        private class SmartCutPoint
        {
            public TimeSpan CutTime { get; set; }
            public TimeSpan OriginalCutTime { get; set; } 
            public bool WasAdjusted { get; set; }
            public string AdjustmentReason { get; set; }
        }
        private List<SmartCutPoint> CalculateSmartCutPoints(
            TimeSpan videoDuration,
            List<SmartCutMapItem> mapItems,
            List<TimelineClipViewModel> overlays,
            List<TimelineClipViewModel> textClips,
            List<TimelineAudioClip> audioClips,
            double targetSegmentMinutes = 15.0,
            double maxSegmentMinutes = 20.0,
            double minSegmentMinutes = 10.0)
        {
            var cutPoints = new List<SmartCutPoint>();
            var currentStart = TimeSpan.Zero;
            var occupiedZones = new List<(TimeSpan Start, TimeSpan End, string Type)>();
            if (mapItems != null)
            {
                foreach (var item in mapItems)
                {
                    occupiedZones.Add((item.Line.StartTime, item.Line.EndTime, "Voice/Subtitle"));
                }
            }
            if (overlays != null)
            {
                foreach (var overlay in overlays)
                {
                    occupiedZones.Add((overlay.StartTime, overlay.EndTime, "Overlay"));
                }
            }
            if (textClips != null)
            {
                foreach (var textClip in textClips)
                {
                    if (textClip.SourceData is SrtSubtitleLine textLine)
                    {
                        occupiedZones.Add((textLine.StartTime, textLine.EndTime, "TextClip"));
                    }
                }
            }
            if (audioClips != null)
            {
                foreach (var audio in audioClips)
                {
                    if (!string.IsNullOrEmpty(audio.FilePath) && File.Exists(audio.FilePath))
                    {
                        occupiedZones.Add((audio.StartTime, audio.EndTime, "Audio"));
                    }
                }
            }
            occupiedZones = occupiedZones.OrderBy(z => z.Start).ToList();
            var mergedZones = MergeNearbyZones(occupiedZones, TimeSpan.FromSeconds(1.0));
            while (currentStart < videoDuration)
            {
                var targetEnd = currentStart + TimeSpan.FromMinutes(targetSegmentMinutes);
                var maxEnd = currentStart + TimeSpan.FromMinutes(maxSegmentMinutes);
                var minEnd = currentStart + TimeSpan.FromMinutes(minSegmentMinutes);
                if (targetEnd >= videoDuration || maxEnd >= videoDuration)
                {
                    cutPoints.Add(new SmartCutPoint
                    {
                        CutTime = videoDuration,
                        OriginalCutTime = videoDuration,
                        WasAdjusted = false,
                        AdjustmentReason = "Final segment"
                    });
                    break;
                }
                var safeCutTime = FindSafeCutPoint(
                    targetEnd,
                    minEnd,
                    maxEnd,
                    mergedZones,
                    out bool wasAdjusted,
                    out string adjustmentReason);
                if ((safeCutTime - currentStart).TotalMinutes < minSegmentMinutes)
                {
                    safeCutTime = FindNextGapAfter(minEnd, maxEnd, mergedZones);
                    wasAdjusted = true;
                    adjustmentReason = "Extended to minimum length";
                }

                cutPoints.Add(new SmartCutPoint
                {
                    CutTime = safeCutTime,
                    OriginalCutTime = targetEnd,
                    WasAdjusted = wasAdjusted,
                    AdjustmentReason = adjustmentReason
                });

                currentStart = safeCutTime;
            }

            return cutPoints;
        }
        private List<(TimeSpan Start, TimeSpan End, string Type)> MergeNearbyZones(
           List<(TimeSpan Start, TimeSpan End, string Type)> zones,
           TimeSpan mergeThreshold)
        {
            if (zones == null || zones.Count == 0) return new List<(TimeSpan, TimeSpan, string)>();

            var merged = new List<(TimeSpan Start, TimeSpan End, string Type)>();
            var current = zones[0];

            for (int i = 1; i < zones.Count; i++)
            {
                var next = zones[i];
                if (next.Start - current.End <= mergeThreshold)
                {
                    current = (current.Start,
                               next.End > current.End ? next.End : current.End,
                               current.Type + "+" + next.Type);
                }
                else
                {
                    merged.Add(current);
                    current = next;
                }
            }
            merged.Add(current);

            return merged;
        }
        private TimeSpan FindSafeCutPoint(
            TimeSpan targetTime,
            TimeSpan minTime,
            TimeSpan maxTime,
            List<(TimeSpan Start, TimeSpan End, string Type)> zones,
            out bool wasAdjusted,
            out string adjustmentReason)
        {
            wasAdjusted = false;
            adjustmentReason = "";
            var buffer = TimeSpan.FromSeconds(0.5);
            foreach (var zone in zones)
            {
                if (targetTime >= zone.Start - buffer && targetTime <= zone.End + buffer)
                {
                    var beforeZone = zone.Start - buffer;
                    if (beforeZone >= minTime && beforeZone <= maxTime)
                    {
                        wasAdjusted = true;
                        adjustmentReason = $"Moved before {zone.Type} zone";
                        return beforeZone;
                    }
                    var afterZone = zone.End + buffer;
                    if (afterZone >= minTime && afterZone <= maxTime)
                    {
                        wasAdjusted = true;
                        adjustmentReason = $"Moved after {zone.Type} zone";
                        return afterZone;
                    }
                    wasAdjusted = true;
                    adjustmentReason = $"Forced cut after {zone.Type} zone";
                    return zone.End + buffer;
                }
            }
            return targetTime;
        }
        private TimeSpan FindNextGapAfter(
            TimeSpan afterTime,
            TimeSpan maxTime,
            List<(TimeSpan Start, TimeSpan End, string Type)> zones)
        {
            var buffer = TimeSpan.FromSeconds(0.5);

            foreach (var zone in zones.OrderBy(z => z.Start))
            {
                if (zone.Start > afterTime && zone.Start <= maxTime)
                {
                    return zone.Start - buffer;
                }
                if (zone.End > afterTime && zone.End + buffer <= maxTime)
                {
                    var nextZone = zones.FirstOrDefault(z => z.Start > zone.End && z.Start <= maxTime);
                    if (nextZone == default || nextZone.Start - zone.End > TimeSpan.FromSeconds(1))
                    {
                        return zone.End + buffer;
                    }
                }
            }

            return maxTime;
        }
        private async Task<string> ProcessSingleVideoSegmentAsync(
            string ffmpegPath,
            MediaAsset mainVideoAsset,
            LongVideoSegmentMetadata segmentMeta,
            VideoExportSettings settings,
            GenerateVideoWindow progressWindow,
            CancellationToken cancellationToken)
        {
            var segIndex = segmentMeta.SegmentIndex;
            progressWindow.UpdateProgress(
                10 + (segIndex * 60 / 10), 
                $"Đang xử lý segment {segIndex + 1}..."
            );
            var segments = await BuildSegmentListForParallelProcessing(
                mainVideoAsset,
                segmentMeta.MapItems,
                cancellationToken,
                alignToKeyframes: false
            );

            if (segments == null || segments.Count == 0)
            {
                throw new InvalidOperationException($"Không thể tạo segments cho đoạn {segIndex}");
            }

            var adjustedSegments = new List<VideoSegmentInfo>();
            foreach (var seg in segments)
            {
                var newStart = TimeSpan.FromSeconds(Math.Max(
                    segmentMeta.SourceStart.TotalSeconds,
                    seg.SourceStart.TotalSeconds
                ));
                var newEnd = TimeSpan.FromSeconds(Math.Min(
                    segmentMeta.SourceEnd.TotalSeconds,
                    seg.SourceEnd.TotalSeconds
                ));

                if (newEnd <= newStart) continue;

                adjustedSegments.Add(new VideoSegmentInfo
                {
                    SegmentIndex = seg.SegmentIndex,
                    SourceStart = newStart,
                    SourceEnd = newEnd,
                    SourceStartExact = newStart.TotalSeconds,
                    SourceEndExact = newEnd.TotalSeconds,
                    TargetDuration = seg.TargetDuration,
                    TargetDurationExact = seg.TargetDurationExact,
                    RequiredSpeed = seg.RequiredSpeed,
                    VoiceClip = seg.VoiceClip,
                    SubtitleLine = seg.SubtitleLine,
                    IsSilenceGap = seg.IsSilenceGap,
                    OutputStart = seg.OutputStart,
                    OutputEnd = seg.OutputEnd
                });
            }
            var subtitleTimeline = new List<(SrtSubtitleLine Line, TimeSpan FinalStart, TimeSpan FinalEnd)>();
            var contentSegments = adjustedSegments.Where(s => !s.IsSilenceGap).OrderBy(s => s.SegmentIndex).ToList();
            var orderedMapItems = segmentMeta.MapItems.OrderBy(m => m.FinalStart).ToList();
            int segIdx = 0;
            for (int i = 0; i < orderedMapItems.Count && segIdx < contentSegments.Count; i++)
            {
                var item = orderedMapItems[i];
                var seg = contentSegments[segIdx];
                double timeDiff = Math.Abs(seg.SourceStart.TotalSeconds - item.Line.StartTime.TotalSeconds);

                if (timeDiff < 3.0)
                {
                    subtitleTimeline.Add((item.Line, seg.OutputStart, seg.OutputEnd));
                    segIdx++;
                }
            }

            // Check if there are subtitles/text to burn into the video
            // Priority: check timeline first (user may have deleted subtitles from timeline)
            bool hasSubtitlesToBurn = HasSubtitlesOrTextOnTimeline() || HasSubtitlesForSmartCutExport(subtitleTimeline);
            
            string tempAssPath = null;
            if (hasSubtitlesToBurn)
            {
                string assContent = GenerateAssFileContentForSmartCut(
                    settings.ResolutionWidth,
                    settings.ResolutionHeight,
                    subtitleTimeline
                );
                tempAssPath = TempFileManager.CreateTempFile(".ass");
                await File.WriteAllTextAsync(tempAssPath, assContent, Encoding.UTF8, cancellationToken);
                TempFileManager.RegisterForCleanup(tempAssPath);
            }
            
            string segmentOutputPath = TempFileManager.CreateTempFile(".mp4");
            TempFileManager.RegisterForCleanup(segmentOutputPath);
            segmentMeta.OutputPath = segmentOutputPath;
            var argsBuilder = new StringBuilder();
            argsBuilder.Append("-y -hide_banner ");
            string finalGpuAccel = "none";
            string finalVideoCodec = settings.VideoCodec;
            if (settings.GpuAcceleration == "auto")
            {
                var allGpus = await FfmpegGpuDetector.GetAvailableGpusAsync();
                var bestGpu = FfmpegGpuDetector.GetBestAvailableGpu(allGpus);
                if (bestGpu != null && bestGpu.FfmpegValue != "none")
                {
                    finalGpuAccel = bestGpu.FfmpegValue;
                    finalVideoCodec = bestGpu.RecommendedCodec;
                }
            }
            else if (!string.IsNullOrEmpty(settings.GpuAcceleration) && settings.GpuAcceleration != "none")
            {
                finalGpuAccel = settings.GpuAcceleration;
            }

            if (finalGpuAccel != "none")
            {
                argsBuilder.Append($"-hwaccel {finalGpuAccel} ");
            }
            argsBuilder.Append($"-i \"{mainVideoAsset.FilePath}\" ");
            var filterComplex = BuildFilterComplexForSegment(
                adjustedSegments,
                mainVideoAsset,
                settings,
                tempAssPath,
                segmentMeta.Overlays,
                hasSubtitlesToBurn
            );
            var filterScriptPath = TempFileManager.CreateTempFile(".txt");
            await WriteTextNoBomAsync(filterScriptPath, filterComplex, cancellationToken);
            TempFileManager.RegisterForCleanup(filterScriptPath);
            argsBuilder.Append($" -filter_complex_script \"{filterScriptPath}\" -filter_threads 0 ");
            argsBuilder.Append("-map \"[video_out]\" -map \"[final_audio]\" ");
            bool isHardwareEncoder = false;
            if (!string.IsNullOrWhiteSpace(finalVideoCodec))
            {
                string lowerCodec = finalVideoCodec.ToLowerInvariant();
                if (lowerCodec.Contains("_nvenc") || lowerCodec.Contains("_qsv") || lowerCodec.Contains("_amf"))
                {
                    isHardwareEncoder = true;
                }
            }

            if (isHardwareEncoder)
            {
                argsBuilder.Append($"-c:v {finalVideoCodec} ");
                argsBuilder.Append($"-cq {settings.Crf} ");
                string hwPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "p4";
                argsBuilder.Append($"-preset {hwPreset} ");
                argsBuilder.Append($"-vsync cfr -r 30 ");
            }
            else
            {
                string cpuCodec = !string.IsNullOrWhiteSpace(finalVideoCodec) ? finalVideoCodec : "libx264";
                argsBuilder.Append($"-c:v {cpuCodec} ");
                argsBuilder.Append($"-crf {settings.Crf} ");
                string cpuPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "medium";
                argsBuilder.Append($"-preset {cpuPreset} ");
                argsBuilder.Append($"-vsync cfr -r 30 ");
            }

            if (settings.IsThreadLimitEnabled && !isHardwareEncoder)
            {
                argsBuilder.Append($"-threads {settings.ThreadLimit} ");
            }
            if (!string.IsNullOrEmpty(settings.Tune)) argsBuilder.Append($"-tune {settings.Tune} ");
            if (!string.IsNullOrEmpty(settings.PixelFormat)) argsBuilder.Append($"-pix_fmt {settings.PixelFormat} ");

            argsBuilder.Append($"-c:a aac -b:a {settings.AudioBitrate} -ar 44100 ");
            if (settings.ForceStereo) argsBuilder.Append("-ac 2 ");
            argsBuilder.Append("-movflags +faststart ");
            argsBuilder.Append("-shortest ");
            argsBuilder.Append($"\"{segmentOutputPath}\"");
            var actualDuration = adjustedSegments.Last().OutputEnd.TotalSeconds;
            await ExecuteFfmpegWithProgress(
                ffmpegPath,
                argsBuilder.ToString(),
                progressWindow,
                segmentOutputPath,
                cancellationToken,
                actualDuration
            );

            return segmentOutputPath;
        }
        private string BuildFilterComplexForSegment(
            List<VideoSegmentInfo> segments,
            MediaAsset mainVideoAsset,
            VideoExportSettings settings,
            string assPath,
            List<TimelineClipViewModel> overlays,
            bool burnSubtitles = true)
        {
            var filterComplex = new StringBuilder();
            var videoSegments = new List<string>();
            var voiceAudioLabels = new List<string>();
            var videoAudioLabels = new List<string>();

            double mainVideoVolumeDb = ResolveDbOrDefault(mainVideoAsset.VolumeDb, 0.0);
            int W = settings.ResolutionWidth;
            int H = settings.ResolutionHeight;

            double zoom = Math.Max(mainVideoAsset.Scale, 0.0001);
            double posX = mainVideoAsset.PositionX;
            double posY = mainVideoAsset.PositionY;
            string cover = $"max({W}/iw\\,{H}/ih)";
            string zoomExpr = $"max({zoom.ToString(CultureInfo.InvariantCulture)}\\,1)";
            string eff = $"({cover})*({zoomExpr})";
            string scaleFilter = $"scale=w=ceil(iw*{eff}):h=ceil(ih*{eff})";
            string cx = $"(iw - {W})/2 - ({posX.ToString(CultureInfo.InvariantCulture)} - 0.5)*{W}";
            string cy = $"(ih - {H})/2 - ({posY.ToString(CultureInfo.InvariantCulture)} - 0.5)*{H}";
            string cropX = $"x='max(0\\,min(iw-{W}\\,({cx})))'";
            string cropY = $"y='max(0\\,min(ih-{H}\\,({cy})))'";
            string panZoomFilter = $"{scaleFilter},crop={W}:{H}:{cropX}:{cropY},scale='trunc(iw/2)*2:trunc(ih/2)*2'";

            int segIndex = 0;
            foreach (var segment in segments.OrderBy(s => s.OutputStart))
            {
                double startSrc = segment.SourceStartExact > 0 ? segment.SourceStartExact : segment.SourceStart.TotalSeconds;
                double endSrc = segment.SourceEndExact > 0 ? segment.SourceEndExact : segment.SourceEnd.TotalSeconds;
                double targetDur = segment.TargetDurationExact > 0 ? segment.TargetDurationExact : segment.TargetDuration.TotalSeconds;
                double speed = segment.RequiredSpeed;
                if (speed <= 0.0001) speed = 1.0;

                const double fps = 30.0;
                double startSrcQ = SnapToFps(startSrc, fps);
                double endSrcQ = SnapToFps(endSrc, fps);
                double targetDurQ = Math.Max(1.0 / fps, SnapToFps(targetDur, fps));

                string startStr = Fmt6(startSrcQ);
                string endStr = Fmt6(endSrcQ);
                string speedStr = speed.ToString("0.################", CultureInfo.InvariantCulture);
                string targetDurStr = Fmt6(targetDurQ);
                double minPad = 1.0 / fps + 1e-9;           
                                                             
                double srcDurQ = Math.Max(endSrcQ - startSrcQ, 0.0);
                double speedEff = Math.Abs(speed - 1.0) <= 0.0001 ? 1.0 : speed;
                double afterSpeedQ = srcDurQ / speedEff;    
                double padNeeded = Math.Max(targetDurQ - afterSpeedQ, 0.0);
                bool needPad = padNeeded > minPad;

                filterComplex.Append($"[0:v]trim=start={startStr}:end={endStr},setpts=PTS-STARTPTS");
                
                if (Math.Abs(speedEff - 1.0) > 0.0001)
                {
                    filterComplex.Append($",setpts=PTS/{speedStr}");
                }
                if (needPad)
                {
                    string padStr = Fmt6(padNeeded);
                    filterComplex.Append($",tpad=stop_mode=clone:stop_duration={padStr}");
                }
                filterComplex.Append($",trim=duration={targetDurStr},setpts=PTS-STARTPTS");
                filterComplex.Append($",{panZoomFilter}[v{segIndex}];");
                videoSegments.Add($"[v{segIndex}]");

                bool hasVoice = segment.VoiceClip != null && !string.IsNullOrWhiteSpace(segment.VoiceClip.FilePath) && File.Exists(segment.VoiceClip.FilePath);
                if (hasVoice)
                {
                    double ttsDb = DbToGain(ResolveDbOrDefault(segment.VoiceClip.VolumeDb, +3.0));
                    filterComplex.Append($"amovie='{EscapePathForFilterScript(segment.VoiceClip.FilePath)}'");
                    if (Math.Abs(segment.VoiceClip.Speed - 1.0) > 0.01)
                    {
                        var ttsAtempo = BuildAtempoChain(segment.VoiceClip.Speed);
                        if (!string.IsNullOrEmpty(ttsAtempo))
                        {
                            filterComplex.Append($",{ttsAtempo}");
                        }
                    }
                    filterComplex.Append($",atrim=duration={targetDurStr},asetpts=PTS-STARTPTS,apad=pad_dur={targetDurStr},atrim=duration={targetDurStr},asetpts=PTS-STARTPTS,volume={ttsDb.ToString(CultureInfo.InvariantCulture)},aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a_voice{segIndex}];");
                    voiceAudioLabels.Add($"[a_voice{segIndex}]");
                }
                else
                {
                    filterComplex.Append($"anullsrc=r=44100:cl=stereo,atrim=duration={targetDurStr},asetpts=PTS-STARTPTS[a_voice{segIndex}];");
                    voiceAudioLabels.Add($"[a_voice{segIndex}]");
                }

                filterComplex.Append($"[0:a]atrim=start={startStr}:end={endStr},asetpts=PTS-STARTPTS");
                filterComplex.Append($",volume={DbToGain(mainVideoVolumeDb).ToString(CultureInfo.InvariantCulture)}");

                string videoAtempoChain = BuildAtempoChain(speed);
                if (!string.IsNullOrEmpty(videoAtempoChain))
                {
                    filterComplex.Append($",{videoAtempoChain}");
                    filterComplex.Append(",asetpts=PTS-STARTPTS");
                }

                filterComplex.Append(",aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo");
                filterComplex.Append(",apad");
                filterComplex.Append($",atrim=duration={targetDurStr}");
                filterComplex.Append($",asetpts=PTS-STARTPTS[a_vid{segIndex}];");
                videoAudioLabels.Add($"[a_vid{segIndex}]");

                segIndex++;
            }
            filterComplex.Append($"{string.Join("", videoSegments)}concat=n={videoSegments.Count}:v=1:a=0[v_concat];");
            filterComplex.Append($"{string.Join("", voiceAudioLabels)}concat=n={voiceAudioLabels.Count}:v=0:a=1[a_voice];");
            filterComplex.Append($"{string.Join("", videoAudioLabels)}concat=n={videoAudioLabels.Count}:v=0:a=1[a_vid];");
            string currentVideoTag = "v_concat";
            var actualContentDuration = segments.Last().OutputEnd;
            bool burnSubs = true;
            string blurChain = BuildBlurBoxFilter(
                currentVideoTag,
                "video_blur_e",
                CurrentProject,
                burnSubs,
                actualContentDuration
            );
            filterComplex.Append(blurChain + ";");
            currentVideoTag = "video_blur_e";
            if (_isVideoFlipEnabled)
            {
                filterComplex.Append($"[{currentVideoTag}]hflip[video_flipped];");
                currentVideoTag = "video_flipped";
            }
            string fontsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Fonts");
            if (!Directory.Exists(fontsDir))
                fontsDir = @"C:\Windows\Fonts";
            
            // Conditionally apply subtitle filter based on burnSubtitles parameter
            if (burnSubtitles && !string.IsNullOrEmpty(assPath) && File.Exists(assPath))
            {
                string escapedAss = EscapePathForFilterScript(assPath);
                string escapedFonts = EscapePathForFilterScript(fontsDir);

                filterComplex.Append(
                    $"[{currentVideoTag}]setsar=1[video_out_scaled];" +
                    $"[video_out_scaled]subtitles=filename='{escapedAss}':fontsdir='{escapedFonts}':charenc=UTF-8[video_out];"
                );
            }
            else
            {
                // No subtitles to burn - just set SAR and output
                filterComplex.Append($"[{currentVideoTag}]setsar=1[video_out];");
            }
            string finalDurStr = actualContentDuration.TotalSeconds.ToString(CultureInfo.InvariantCulture);
            filterComplex.Append($"[a_voice]atrim=duration={finalDurStr},apad=pad_dur={finalDurStr}[a_voice_trimmed];");
            filterComplex.Append($"[a_vid]atrim=duration={finalDurStr},apad=pad_dur={finalDurStr}[a_vid_trimmed];");
            filterComplex.Append($"[a_voice_trimmed][a_vid_trimmed]amix=inputs=2:duration=first:normalize=0:dropout_transition=0,alimiter=limit=0.95[final_audio]");

            return filterComplex.ToString();
        }
        private async Task ConcatenateVideoSegmentsAsync(
            string ffmpegPath,
            List<LongVideoSegmentMetadata> segments,
            List<TimelineAudioClip> bgAudioClips,
            VideoExportSettings settings,
            GenerateVideoWindow progressWindow,
            CancellationToken cancellationToken)
        {
            progressWindow.UpdateProgress(75, "Đang ghép các đoạn video...");
            string concatListPath = TempFileManager.CreateTempFile(".txt");
            var concatLines = new StringBuilder();

            foreach (var seg in segments.OrderBy(s => s.SegmentIndex))
            {
                if (!string.IsNullOrEmpty(seg.OutputPath) && File.Exists(seg.OutputPath))
                {
                    var p = seg.OutputPath.Replace("\\", "/").Replace("'", "'\\''");
                    concatLines.AppendLine($"file '{p}'");
                }
            }
            var utf8NoBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
            await File.WriteAllTextAsync(concatListPath, concatLines.ToString(), utf8NoBom, cancellationToken);
            TempFileManager.RegisterForCleanup(concatListPath);
            string tempConcatenatedPath = TempFileManager.CreateTempFile(".mp4");
            TempFileManager.RegisterForCleanup(tempConcatenatedPath);

            var concatArgs = new StringBuilder();
            concatArgs.Append($"-y -hide_banner -f concat -safe 0 -i \"{concatListPath}\" ");
            concatArgs.Append("-c copy ");
            concatArgs.Append($"\"{tempConcatenatedPath}\"");

            await ExecuteFfmpegWithProgress(
                ffmpegPath,
                concatArgs.ToString(),
                progressWindow,
                tempConcatenatedPath,
                cancellationToken,
                0 
            );
            progressWindow.UpdateProgress(85, "Đang thêm nhạc nền...");
            if (bgAudioClips != null && bgAudioClips.Any(a => !string.IsNullOrEmpty(a.FilePath) && File.Exists(a.FilePath)))
            {
                var mixArgs = new StringBuilder();
                mixArgs.Append($"-y -hide_banner -i \"{tempConcatenatedPath}\" ");

                var inputMap = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase)
                {
                    [tempConcatenatedPath] = 0
                };
                int inputIndex = 1;

                foreach (var bg in bgAudioClips)
                {
                    if (bg == null || string.IsNullOrWhiteSpace(bg.FilePath) || !File.Exists(bg.FilePath))
                        continue;
                    if (inputMap.ContainsKey(bg.FilePath))
                        continue;

                    mixArgs.Append($"-i \"{bg.FilePath}\" ");
                    inputMap[bg.FilePath] = inputIndex++;
                }
                var filterComplex = new StringBuilder();
                var audioInputs = new List<string> { "[0:a]" };

                int bgIndex = 0;
                foreach (var bg in bgAudioClips)
                {
                    if (bg == null || !inputMap.TryGetValue(bg.FilePath, out int bgInputIndex) || bgInputIndex == 0)
                        continue;

                    string processedLabel = $"bg_{bgIndex}";
                    double bgVolume = DbToGain(bg.VolumeDb);
                    filterComplex.Append($"[{bgInputIndex}:a]volume={bgVolume.ToString(CultureInfo.InvariantCulture)},aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[{processedLabel}];");
                    audioInputs.Add($"[{processedLabel}]");
                    bgIndex++;
                }

                filterComplex.Append($"{string.Join("", audioInputs)}amix=inputs={audioInputs.Count}:duration=first:normalize=0,alimiter=limit=0.95[final_audio]");

                mixArgs.Append($"-filter_complex \"{filterComplex}\" ");
                mixArgs.Append("-map \"[0:v]\" -map \"[final_audio]\" ");
                mixArgs.Append("-c:v copy ");
                mixArgs.Append($"-c:a aac -b:a {settings.AudioBitrate} -ar 44100 ");
                if (settings.ForceStereo) mixArgs.Append("-ac 2 ");
                mixArgs.Append("-movflags +faststart ");
                mixArgs.Append($"\"{settings.OutputPath}\"");

                await ExecuteFfmpegWithProgress(
                    ffmpegPath,
                    mixArgs.ToString(),
                    progressWindow,
                    settings.OutputPath,
                    cancellationToken,
                    0
                );
            }
            else
            {
                File.Copy(tempConcatenatedPath, settings.OutputPath, true);
            }

            progressWindow.UpdateProgress(100, "Hoàn tất!");
        }
        private async Task ExecuteStaticSmartCutExportWithSegmentationAsync(
            string ffmpegPath,
            VideoExportSettings settings,
            GenerateVideoWindow progressWindow,
            CancellationToken cancellationToken)
        {
            progressWindow.UpdateProgress(1, "Đang phân tích video dài và tính toán điểm cắt thông minh...");
            var mainVideoClip = TimelineClips.FirstOrDefault(c => c.ClipType == TimelineClipType.Video);
            if (mainVideoClip == null || mainVideoClip.SourceData is not MediaAsset mainVideoAsset
                || string.IsNullOrWhiteSpace(mainVideoAsset.FilePath) || !File.Exists(mainVideoAsset.FilePath))
            {
                throw new Exception("Không tìm thấy video chính để xuất ở chế độ Static");
            }
            try
            {
                var probeInfo = await FFProbe.AnalyseAsync(mainVideoAsset.FilePath);
                System.Diagnostics.Debug.WriteLine($"FFProbe Duration: {probeInfo.Duration}");
                System.Diagnostics.Debug.WriteLine($"FFProbe Duration.TotalSeconds: {probeInfo.Duration.TotalSeconds:F3}s");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"FFProbe failed: {ex.Message}");
            }
            var allMapItems = await BuildSmartCutMapItemsAsync();
            if (allMapItems == null || allMapItems.Count == 0)
            {
                throw new InvalidOperationException("Không tìm thấy dữ liệu Smart Cut (Voice/Subtitle).");
            }
            var imageOverlayClips = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Image)
                .ToList();

            var textClips = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Text)
                .ToList();

            var (ttsClips, bgFxClips) = ClassifyAudioClipsForExport();
            var videoDuration = mainVideoAsset.Duration;
            var smartCutPoints = CalculateSmartCutPoints(
                videoDuration,
                allMapItems,
                imageOverlayClips,
                textClips,
                bgFxClips,
                targetSegmentMinutes: 3.0,
                maxSegmentMinutes: 5.0,
                minSegmentMinutes: 1.5
            );
            for (int i = 0; i < smartCutPoints.Count; i++)
            {
                var cp = smartCutPoints[i];
            }
            var cutRanges = new List<(TimeSpan Start, TimeSpan End)>();
            var prevCut = TimeSpan.Zero;
            foreach (var cutPoint in smartCutPoints)
            {
                cutRanges.Add((prevCut, cutPoint.CutTime));
                prevCut = cutPoint.CutTime;
            }
            progressWindow.UpdateProgress(3, $"Chia video thành {cutRanges.Count} đoạn thông minh...");
            for (int i = 0; i < cutRanges.Count; i++)
            {
                var (s, e) = cutRanges[i];
                var duration = e - s;
            }
            var segmentMetadatas = new List<LongVideoSegmentMetadata>();
            TimeSpan cumulativeOutputOffset = TimeSpan.Zero;

            for (int i = 0; i < cutRanges.Count; i++)
            {
                var (start, end) = cutRanges[i];
                var segmentMapItems = allMapItems
                    .Where(m => m.Line.StartTime >= start && m.Line.StartTime < end)
                    .ToList();
                var segmentOverlays = imageOverlayClips
                    .Where(o => o.StartTime < end && o.EndTime > start)
                    .ToList();
                var segMeta = new LongVideoSegmentMetadata
                {
                    SegmentIndex = i,
                    SourceStart = start,
                    SourceEnd = end,
                    MapItems = segmentMapItems,
                    Overlays = segmentOverlays,
                    SourceOffsetFromStart = start,              
                    OutputTimelineOffset = cumulativeOutputOffset  
                };
                segMeta.EstimatedOutputDuration = await EstimateSegmentOutputDuration(
                    mainVideoAsset, segmentMapItems, cancellationToken);

                cumulativeOutputOffset += segMeta.EstimatedOutputDuration;
               
                if (segmentMapItems.Count > 0)
                {
                    var firstMI = segmentMapItems.OrderBy(m => m.Line.StartTime).First();
                    var lastMI = segmentMapItems.OrderBy(m => m.Line.EndTime).Last();
                    if (lastMI.Line.EndTime > end)
                    {
                        System.Diagnostics.Debug.WriteLine(
                            $"  ⚠️ WARNING: Last MapItem EndTime ({lastMI.Line.EndTime:hh\\:mm\\:ss\\.fff}) " +
                            $"> Segment End ({end:hh\\:mm\\:ss\\.fff})!");
                    }
                }
                segmentMetadatas.Add(segMeta);
            }
            var allAssignedIndices = segmentMetadatas
                .SelectMany(s => s.MapItems.Select(m => m.Line.Index))
                .ToHashSet();
            
            var missingItems = allMapItems
                .Where(m => !allAssignedIndices.Contains(m.Line.Index))
                .ToList();

            if (missingItems.Count > 0)
            {
                foreach (var item in missingItems)
                {

                }
            }
            else
            {
            }

            for (int i = 0; i < segmentMetadatas.Count; i++)
            {
                var segMeta = segmentMetadatas[i];

                if (segMeta.MapItems.Count == 0)
                {
                    progressWindow.UpdateProgress(
                        10 + (i * 60 / segmentMetadatas.Count),
                        $"Bỏ qua segment {i + 1} (không có nội dung)..."
                    );
                    continue;
                }

                try
                {
                    var outputPath = await ProcessSingleVideoSegmentAsync_FIXED(
                        ffmpegPath,
                        mainVideoAsset,
                        segMeta,
                        settings,
                        progressWindow,
                        cancellationToken
                    );

                    segMeta.OutputPath = outputPath;
                    if (File.Exists(outputPath))
                    {
                        var info = await FFProbe.AnalyseAsync(outputPath);
                        segMeta.ActualOutputDuration = info.Duration;
                    }
                }
                catch (Exception ex)
                {
                    throw new Exception($"Lỗi khi xử lý segment {i + 1}: {ex.Message}", ex);
                }
            }
            var validSegments = segmentMetadatas
                .Where(s => !string.IsNullOrEmpty(s.OutputPath) && File.Exists(s.OutputPath))
                .ToList();

            if (validSegments.Count == 0)
            {
                throw new Exception("Không có segment nào được xử lý thành công");
            }

            await ConcatenateVideoSegmentsAsync_FIXED(
                ffmpegPath,
                validSegments,
                bgFxClips,
                settings,
                progressWindow,
                cancellationToken
            );
        }


        #endregion
        #region FIXED: ProcessSingleVideoSegmentAsync

        private async Task<string> ProcessSingleVideoSegmentAsync_FIXED(
            string ffmpegPath,
            MediaAsset mainVideoAsset,
            LongVideoSegmentMetadata segmentMeta,
            VideoExportSettings settings,
            GenerateVideoWindow progressWindow,
            CancellationToken cancellationToken)
        {
            var segIndex = segmentMeta.SegmentIndex;
            progressWindow.UpdateProgress(
                10 + (segIndex * 60 / 10),
                $"Đang xử lý segment {segIndex + 1}..."
            );
            var adjustedMapItems = new List<SmartCutMapItem>();
            foreach (var item in segmentMeta.MapItems)
            {
                var adjustedItem = new SmartCutMapItem
                {
                    Line = new SrtSubtitleLine
                    {
                        Index = item.Line.Index,
                        StartTime = item.Line.StartTime - segmentMeta.SourceStart,
                        EndTime = item.Line.EndTime - segmentMeta.SourceStart,
                        IsVoiced = item.Line.IsVoiced,
                        IsTextClip = item.Line.IsTextClip,
                        VoicedAudioPath = item.Line.VoicedAudioPath,
                        OriginalText = item.Line.OriginalText,
                        TranslatedText = item.Line.TranslatedText,
                        Style = item.Line.Style
                    },
                    FinalStart = item.FinalStart - segmentMeta.SourceStart,
                    FinalEnd = item.FinalEnd - segmentMeta.SourceStart
                };

                if (adjustedItem.Line.StartTime < TimeSpan.Zero)
                    adjustedItem.Line.StartTime = TimeSpan.Zero;
                if (adjustedItem.Line.EndTime > segmentMeta.Duration)
                    adjustedItem.Line.EndTime = segmentMeta.Duration;

                adjustedMapItems.Add(adjustedItem);
            }
            var segments = await BuildSegmentListForSegmentProcessing(
                mainVideoAsset,
                adjustedMapItems,
                segmentMeta.SourceStart,  
                segmentMeta.Duration,      
                cancellationToken
            );

            if (segments == null || segments.Count == 0)
            {
                throw new InvalidOperationException($"Không thể tạo segments cho đoạn {segIndex}");
            }
            double maxSourceEndFromSegments = 0;
            if (segments.Count > 0)
            {
                maxSourceEndFromSegments = segments.Max(s => s.SourceEndExact);
            }
            double requiredInputDuration = Math.Max(
                segmentMeta.Duration.TotalSeconds,
                maxSourceEndFromSegments
            ) + 5.0;
            var subtitleTimeline = new List<(SrtSubtitleLine Line, TimeSpan FinalStart, TimeSpan FinalEnd)>();
            foreach (var seg in segments.Where(s => !s.IsSilenceGap && s.SubtitleLine != null))
            {
                var lineForExport = new SrtSubtitleLine
                {
                    Index = seg.SubtitleLine.Index,
                    StartTime = seg.OutputStart, 
                    EndTime = seg.OutputEnd,
                    IsVoiced = seg.SubtitleLine.IsVoiced,
                    OriginalText = seg.SubtitleLine.OriginalText,
                    TranslatedText = seg.SubtitleLine.TranslatedText,
                    Style = seg.SubtitleLine.Style
                };
                subtitleTimeline.Add((lineForExport, seg.OutputStart, seg.OutputEnd));
            }
            
            // Check if there are subtitles/text to burn into the video
            // Priority: check timeline first (user may have deleted subtitles from timeline)
            bool hasSubtitlesToBurn = HasSubtitlesOrTextOnTimeline() || HasSubtitlesForSmartCutExport(subtitleTimeline);
            
            string tempAssPath = null;
            if (hasSubtitlesToBurn)
            {
                string assContent = GenerateAssFileContentForSmartCut(
                    settings.ResolutionWidth,
                    settings.ResolutionHeight,
                    subtitleTimeline
                );
                tempAssPath = TempFileManager.CreateTempFile(".ass");
                await File.WriteAllTextAsync(tempAssPath, assContent, Encoding.UTF8, cancellationToken);
                TempFileManager.RegisterForCleanup(tempAssPath);
            }
            
            string segmentOutputPath = TempFileManager.CreateTempFile(".mp4");
            TempFileManager.RegisterForCleanup(segmentOutputPath);
            var filterComplex = BuildFilterComplexForSegment_FIXED(
                segments,
                mainVideoAsset,
                settings,
                tempAssPath,
                segmentMeta.SourceStart,  
                segmentMeta.Overlays,
                segmentMeta.SourceStart,
                hasSubtitlesToBurn
            );

            var filterScriptPath = TempFileManager.CreateTempFile(".txt");
            await WriteTextNoBomAsync(filterScriptPath, filterComplex, cancellationToken);
            TempFileManager.RegisterForCleanup(filterScriptPath);
            var argsBuilder = new StringBuilder();
            argsBuilder.Append("-y -hide_banner ");
            string finalGpuAccel = "none";
            string finalVideoCodec = settings.VideoCodec;
            if (settings.GpuAcceleration == "auto")
            {
                var allGpus = await FfmpegGpuDetector.GetAvailableGpusAsync();
                var bestGpu = FfmpegGpuDetector.GetBestAvailableGpu(allGpus);
                if (bestGpu != null && bestGpu.FfmpegValue != "none")
                {
                    finalGpuAccel = bestGpu.FfmpegValue;
                    finalVideoCodec = bestGpu.RecommendedCodec;
                }
            }
            else if (!string.IsNullOrEmpty(settings.GpuAcceleration) && settings.GpuAcceleration != "none")
            {
                finalGpuAccel = settings.GpuAcceleration;
            }

            if (finalGpuAccel != "none")
            {
                argsBuilder.Append($"-hwaccel {finalGpuAccel} ");
            }
            argsBuilder.Append($"-ss {segmentMeta.SourceStart.TotalSeconds.ToString(CultureInfo.InvariantCulture)} ");
            argsBuilder.Append($"-t {requiredInputDuration.ToString(CultureInfo.InvariantCulture)} ");
            argsBuilder.Append($"-i \"{mainVideoAsset.FilePath}\" ");
            argsBuilder.Append($" -filter_complex_script \"{filterScriptPath}\" -filter_threads 0 ");
            argsBuilder.Append("-map \"[video_out]\" -map \"[final_audio]\" ");
            bool isHardwareEncoder = false;
            if (!string.IsNullOrWhiteSpace(finalVideoCodec))
            {
                string lowerCodec = finalVideoCodec.ToLowerInvariant();
                if (lowerCodec.Contains("_nvenc") || lowerCodec.Contains("_qsv") || lowerCodec.Contains("_amf"))
                {
                    isHardwareEncoder = true;
                }
            }

            if (isHardwareEncoder)
            {
                argsBuilder.Append($"-c:v {finalVideoCodec} ");
                argsBuilder.Append($"-cq {settings.Crf} ");
                string hwPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "p4";
                argsBuilder.Append($"-preset {hwPreset} ");
                argsBuilder.Append($"-vsync cfr -r 30 ");
            }
            else
            {
                argsBuilder.Append($"-c:v {finalVideoCodec} ");
                argsBuilder.Append($"-crf {settings.Crf} ");
                string cpuPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "medium";
                argsBuilder.Append($"-preset {cpuPreset} ");
            }

            argsBuilder.Append($"-c:a aac -b:a {settings.AudioBitrate} -ar 44100 ");
            if (settings.ForceStereo) argsBuilder.Append("-ac 2 ");
            argsBuilder.Append("-movflags +faststart ");
            argsBuilder.Append($"\"{segmentOutputPath}\"");
            await ExecuteFfmpegWithProgress(
                ffmpegPath,
                argsBuilder.ToString(),
                progressWindow,
                segmentOutputPath,
                cancellationToken,
                null
            );

            return segmentOutputPath;
        }


        #endregion

        #region NEW: Build Segment List for Segment Processing
        private async Task<List<VideoSegmentInfo>> BuildSegmentListForSegmentProcessing(
            MediaAsset mainVideoAsset,
            List<SmartCutMapItem> mapItems,
            TimeSpan sourceOffset,   
            TimeSpan segmentDuration, 
            CancellationToken cancellationToken)
        {
            var segments = new List<VideoSegmentInfo>();

            if (mapItems == null || mapItems.Count == 0)
                return segments;

            double videoFps = 30.0;
            try
            {
                var videoInfo = await FFProbe.AnalyseAsync(mainVideoAsset.FilePath);
                if (videoInfo?.PrimaryVideoStream != null)
                {
                    videoFps = videoInfo.PrimaryVideoStream.FrameRate;
                }
            }
            catch
            {
            }

            var (ttsClips, _) = ClassifyAudioClipsForExport();
            var segmentTtsClips = ttsClips.Where(c =>
            {
                var clipStart = c.StartTime - sourceOffset;
                return clipStart >= TimeSpan.Zero && clipStart < segmentDuration;
            }).ToList();

            int segmentIndex = 1;
            TimeSpan outputCursor = TimeSpan.Zero;
            TimeSpan previousSourceEnd = TimeSpan.Zero;

            foreach (var mapItem in mapItems.OrderBy(m => m.FinalStart))
            {
                var line = mapItem.Line;
                double sourceStartSec = Math.Max(0, line.StartTime.TotalSeconds);
                double sourceEndSec = Math.Min(segmentDuration.TotalSeconds, line.EndTime.TotalSeconds);
                if (sourceEndSec <= sourceStartSec) continue;
                if (TimeSpan.FromSeconds(sourceStartSec) > previousSourceEnd + TimeSpan.FromMilliseconds(50))
                {
                    var gapDur = sourceStartSec - previousSourceEnd.TotalSeconds;
                    if (gapDur > 0.05)
                    {
                        var gapSegment = new VideoSegmentInfo
                        {
                            SegmentIndex = segmentIndex++,
                            SourceStart = previousSourceEnd,
                            SourceEnd = TimeSpan.FromSeconds(sourceStartSec),
                            SourceStartExact = previousSourceEnd.TotalSeconds,
                            SourceEndExact = sourceStartSec,
                            TargetDuration = TimeSpan.FromSeconds(gapDur),
                            TargetDurationExact = gapDur,
                            RequiredSpeed = 1.0,
                            IsSilenceGap = true,
                            OutputStart = outputCursor,
                            OutputEnd = outputCursor + TimeSpan.FromSeconds(gapDur)
                        };
                        segments.Add(gapSegment);
                        outputCursor += TimeSpan.FromSeconds(gapDur);
                    }
                }
                TimelineAudioClip voiceClip = null;
                double voiceDurationSec = 0;

                if (!string.IsNullOrWhiteSpace(line.VoicedAudioPath) && File.Exists(line.VoicedAudioPath))
                {
                    voiceClip = segmentTtsClips.FirstOrDefault(c =>
                        string.Equals(c.FilePath, line.VoicedAudioPath, StringComparison.OrdinalIgnoreCase));
                    if (voiceClip == null)
                    {
                        voiceClip = ttsClips.FirstOrDefault(c =>
                            string.Equals(c.FilePath, line.VoicedAudioPath, StringComparison.OrdinalIgnoreCase));
                    }

                    if (voiceClip != null)
                    {
                        try
                        {
                            var info = await FFProbe.AnalyseAsync(voiceClip.FilePath);
                            voiceDurationSec = info?.Duration.TotalSeconds ?? 0;
                            if (Math.Abs(voiceClip.Speed - 1.0) > 0.01)
                            {
                                voiceDurationSec = voiceDurationSec / voiceClip.Speed;
                            }
                        }
                        catch
                        {
                            voiceDurationSec = voiceClip.EffectiveDuration.TotalSeconds;
                        }
                    }
                }
                double sourceSegmentDurSec = sourceEndSec - sourceStartSec;
                double requiredSpeed = 1.0;
                double targetDurSec = sourceSegmentDurSec;

                if (voiceDurationSec > 0.01)
                {
                    if (voiceDurationSec > sourceSegmentDurSec)
                    {
                        requiredSpeed = sourceSegmentDurSec / voiceDurationSec;
                        requiredSpeed = Math.Clamp(requiredSpeed, 0.25, 4.0);
                        targetDurSec = sourceSegmentDurSec / requiredSpeed;
                    }
                }
                int targetFrames = (int)Math.Round(targetDurSec * videoFps);
                targetDurSec = targetFrames / videoFps;

                var subtitleSegment = new VideoSegmentInfo
                {
                    SegmentIndex = segmentIndex++,
                    SourceStart = TimeSpan.FromSeconds(sourceStartSec),
                    SourceEnd = TimeSpan.FromSeconds(sourceEndSec),
                    SourceStartExact = sourceStartSec,
                    SourceEndExact = sourceEndSec,
                    TargetDuration = TimeSpan.FromSeconds(targetDurSec),
                    TargetDurationExact = targetDurSec,
                    RequiredSpeed = requiredSpeed,
                    IsSilenceGap = false,
                    SubtitleLine = line,
                    VoiceClip = voiceClip,
                    OutputStart = outputCursor,
                    OutputEnd = outputCursor + TimeSpan.FromSeconds(targetDurSec)
                };

                segments.Add(subtitleSegment);
                outputCursor += TimeSpan.FromSeconds(targetDurSec);
                previousSourceEnd = TimeSpan.FromSeconds(sourceEndSec);
            }
            if (previousSourceEnd < segmentDuration - TimeSpan.FromMilliseconds(50))
            {
                var tailGapDur = (segmentDuration - previousSourceEnd).TotalSeconds;
                if (tailGapDur > 0.05)
                {
                    var tailGapSegment = new VideoSegmentInfo
                    {
                        SegmentIndex = segmentIndex++,
                        SourceStart = previousSourceEnd,
                        SourceEnd = segmentDuration,
                        SourceStartExact = previousSourceEnd.TotalSeconds,
                        SourceEndExact = segmentDuration.TotalSeconds,
                        TargetDuration = TimeSpan.FromSeconds(tailGapDur),
                        TargetDurationExact = tailGapDur,
                        RequiredSpeed = 1.0,
                        IsSilenceGap = true,
                        OutputStart = outputCursor,
                        OutputEnd = outputCursor + TimeSpan.FromSeconds(tailGapDur)
                    };
                    segments.Add(tailGapSegment);
                }
            }

            return segments;
        }

        #endregion

        #region FIXED: BuildFilterComplexForSegment
        private string BuildFilterComplexForSegment_FIXED(
            List<VideoSegmentInfo> segments,
            MediaAsset mainVideoAsset,
            VideoExportSettings settings,
            string assPath,
            TimeSpan segmentSourceOffset, 
            List<TimelineClipViewModel> overlays,
            TimeSpan overlayOffset,
            bool burnSubtitles = true)       
        {
            var filterComplex = new StringBuilder();
            var videoSegments = new List<string>();
            var voiceAudioLabels = new List<string>();
            var videoAudioLabels = new List<string>();
            double mainVideoVolumeDb = ResolveDbOrDefault(mainVideoAsset.VolumeDb, 0.0);
            int W = settings.ResolutionWidth;
            int H = settings.ResolutionHeight;
            double zoom = Math.Max(mainVideoAsset.Scale, 0.0001);
            double posX = mainVideoAsset.PositionX;
            double posY = mainVideoAsset.PositionY;
            string cover = $"max({W}/iw\\,{H}/ih)";
            string zoomExpr = $"max({zoom.ToString(CultureInfo.InvariantCulture)}\\,1)";
            string eff = $"({cover})*({zoomExpr})";
            string scaleFilter = $"scale=w=ceil(iw*{eff}):h=ceil(ih*{eff})";
            string cx = $"(iw - {W})/2 - ({posX.ToString(CultureInfo.InvariantCulture)} - 0.5)*{W}";
            string cy = $"(ih - {H})/2 - ({posY.ToString(CultureInfo.InvariantCulture)} - 0.5)*{H}";
            string cropX = $"x='max(0\\,min(iw-{W}\\,({cx})))'";
            string cropY = $"y='max(0\\,min(ih-{H}\\,({cy})))'";
            string panZoomFilter = $"{scaleFilter},crop={W}:{H}:{cropX}:{cropY}";

            int segIndex = 0;
            const double fps = 30.0;

            foreach (var segment in segments.OrderBy(s => s.OutputStart))
            {
                double startSrc = segment.SourceStartExact;
                double endSrc = segment.SourceEndExact;
                double targetDur = segment.TargetDurationExact;
                double speed = segment.RequiredSpeed;

                if (speed <= 0.0001) speed = 1.0;

                double startSrcQ = SnapToFps(startSrc, fps);
                double endSrcQ = SnapToFps(endSrc, fps);
                double targetDurQ = Math.Max(1.0 / fps, SnapToFps(targetDur, fps));

                string startStr = Fmt6(startSrcQ);
                string endStr = Fmt6(endSrcQ);
                string speedStr = speed.ToString("0.################", CultureInfo.InvariantCulture);
                string targetDurStr = Fmt6(targetDurQ);

                double minPad = 1.0 / fps + 1e-9;
                double srcDurQ = Math.Max(endSrcQ - startSrcQ, 0.0);
                double speedEff = Math.Abs(speed - 1.0) <= 0.0001 ? 1.0 : speed;
                double afterSpeedQ = srcDurQ / speedEff;
                double padNeeded = Math.Max(targetDurQ - afterSpeedQ, 0.0);
                bool needPad = padNeeded > minPad;
                filterComplex.Append($"[0:v]trim=start={startStr}:end={endStr},setpts=PTS-STARTPTS");

                if (Math.Abs(speedEff - 1.0) > 0.0001)
                {
                    filterComplex.Append($",setpts=PTS/{speedStr}");
                }
                if (needPad)
                {
                    string padStr = Fmt6(padNeeded);
                    filterComplex.Append($",tpad=stop_mode=clone:stop_duration={padStr}");
                }
                filterComplex.Append($",trim=duration={targetDurStr},setpts=PTS-STARTPTS");
                filterComplex.Append($",{panZoomFilter}[v{segIndex}];");
                videoSegments.Add($"[v{segIndex}]");
                bool hasVoice = segment.VoiceClip != null &&
                               !string.IsNullOrWhiteSpace(segment.VoiceClip.FilePath) &&
                               File.Exists(segment.VoiceClip.FilePath);

                if (hasVoice)
                {
                    double ttsDb = DbToGain(ResolveDbOrDefault(segment.VoiceClip.VolumeDb, +3.0));
                    filterComplex.Append($"amovie='{EscapePathForFilterScript(segment.VoiceClip.FilePath)}'");

                    if (Math.Abs(segment.VoiceClip.Speed - 1.0) > 0.01)
                    {
                        var ttsAtempo = BuildAtempoChain(segment.VoiceClip.Speed);
                        if (!string.IsNullOrEmpty(ttsAtempo))
                        {
                            filterComplex.Append($",{ttsAtempo}");
                        }
                    }

                    filterComplex.Append($",atrim=duration={targetDurStr},asetpts=PTS-STARTPTS");
                    filterComplex.Append($",apad=pad_dur={targetDurStr},atrim=duration={targetDurStr},asetpts=PTS-STARTPTS");
                    filterComplex.Append($",volume={ttsDb.ToString(CultureInfo.InvariantCulture)}");
                    filterComplex.Append(",aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo");
                    filterComplex.Append($"[a_voice{segIndex}];");
                    voiceAudioLabels.Add($"[a_voice{segIndex}]");
                }
                else
                {
                    filterComplex.Append($"anullsrc=r=44100:cl=stereo,atrim=duration={targetDurStr},asetpts=PTS-STARTPTS[a_voice{segIndex}];");
                    voiceAudioLabels.Add($"[a_voice{segIndex}]");
                }
                filterComplex.Append($"[0:a]atrim=start={startStr}:end={endStr},asetpts=PTS-STARTPTS");
                filterComplex.Append($",volume={DbToGain(mainVideoVolumeDb).ToString(CultureInfo.InvariantCulture)}");

                string videoAtempoChain = BuildAtempoChain(speed);
                if (!string.IsNullOrEmpty(videoAtempoChain))
                {
                    filterComplex.Append($",{videoAtempoChain}");
                    filterComplex.Append(",asetpts=PTS-STARTPTS");
                }

                filterComplex.Append(",aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo");
                filterComplex.Append(",apad");
                filterComplex.Append($",atrim=duration={targetDurStr}");
                filterComplex.Append($",asetpts=PTS-STARTPTS[a_vid{segIndex}];");
                videoAudioLabels.Add($"[a_vid{segIndex}]");

                segIndex++;
            }
            filterComplex.Append($"{string.Join("", videoSegments)}concat=n={videoSegments.Count}:v=1:a=0[v_concat];");
            filterComplex.Append($"{string.Join("", voiceAudioLabels)}concat=n={voiceAudioLabels.Count}:v=0:a=1[a_voice];");
            filterComplex.Append($"{string.Join("", videoAudioLabels)}concat=n={videoAudioLabels.Count}:v=0:a=1[a_vid];");

            string currentVideoTag = "v_concat";

            // Overlay processing với offset điều chỉnh
            // TODO: Thêm xử lý overlay nếu cần
            var actualContentDuration = segments.Last().OutputEnd;
            bool burnSubs = true;
            string blurChain = BuildBlurBoxFilter(
                currentVideoTag,
                "video_blur_e",
                CurrentProject,
                burnSubs,
                actualContentDuration
            );
            filterComplex.Append(blurChain + ";");
            currentVideoTag = "video_blur_e";
            if (_isVideoFlipEnabled)
            {
                filterComplex.Append($"[{currentVideoTag}]hflip[video_flipped];");
                currentVideoTag = "video_flipped";
            }
            string fontsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Fonts");
            if (!Directory.Exists(fontsDir))
                fontsDir = @"C:\Windows\Fonts";

            // Conditionally apply subtitle filter based on burnSubtitles parameter
            if (burnSubtitles && !string.IsNullOrEmpty(assPath) && File.Exists(assPath))
            {
                string escapedAss = EscapePathForFilterScript(assPath);
                string escapedFonts = EscapePathForFilterScript(fontsDir);

                filterComplex.Append(
                    $"[{currentVideoTag}]setsar=1[video_out_scaled];" +
                    $"[video_out_scaled]subtitles=filename='{escapedAss}':fontsdir='{escapedFonts}':charenc=UTF-8[video_out];"
                );
            }
            else
            {
                // No subtitles to burn - just set SAR and output
                filterComplex.Append($"[{currentVideoTag}]setsar=1[video_out];");
            }

            string finalDurStr = actualContentDuration.TotalSeconds.ToString(CultureInfo.InvariantCulture);
            filterComplex.Append($"[a_voice]apad=whole_dur={finalDurStr},atrim=duration={finalDurStr}[a_voice_trimmed];");
            filterComplex.Append($"[a_vid]apad=whole_dur={finalDurStr},atrim=duration={finalDurStr}[a_vid_trimmed];");
            filterComplex.Append($"[a_voice_trimmed][a_vid_trimmed]amix=inputs=2:duration=first:normalize=0:dropout_transition=0,alimiter=limit=0.95[final_audio]");

            return filterComplex.ToString();
        }

        #endregion

        #region Helper: Estimate Segment Output Duration
        private async Task<TimeSpan> EstimateSegmentOutputDuration(
            MediaAsset mainVideoAsset,
            List<SmartCutMapItem> mapItems,
            CancellationToken cancellationToken)
        {
            if (mapItems == null || mapItems.Count == 0)
                return TimeSpan.Zero;

            var (ttsClips, _) = ClassifyAudioClipsForExport();
            TimeSpan totalOutputDuration = TimeSpan.Zero;
            TimeSpan previousSourceEnd = TimeSpan.Zero;

            foreach (var item in mapItems.OrderBy(m => m.Line.StartTime))
            {
                if (item.Line.StartTime > previousSourceEnd)
                {
                    totalOutputDuration += item.Line.StartTime - previousSourceEnd;
                }

                var sourceDuration = item.Line.EndTime - item.Line.StartTime;
                TimeSpan segmentOutputDuration = sourceDuration;

                if (!string.IsNullOrWhiteSpace(item.Line.VoicedAudioPath) && File.Exists(item.Line.VoicedAudioPath))
                {
                    var voiceClip = ttsClips.FirstOrDefault(c =>
                        string.Equals(c.FilePath, item.Line.VoicedAudioPath, StringComparison.OrdinalIgnoreCase));

                    if (voiceClip != null)
                    {
                        try
                        {
                            var info = await FFProbe.AnalyseAsync(voiceClip.FilePath);
                            var voiceDuration = info?.Duration ?? TimeSpan.Zero;
                            if (Math.Abs(voiceClip.Speed - 1.0) > 0.01)
                            {
                                voiceDuration = TimeSpan.FromSeconds(voiceDuration.TotalSeconds / voiceClip.Speed);
                            }
                            if (voiceDuration > sourceDuration)
                            {
                                segmentOutputDuration = voiceDuration;
                            }
                        }
                        catch { }
                    }
                }

                totalOutputDuration += segmentOutputDuration;
                previousSourceEnd = item.Line.EndTime;
            }

            return totalOutputDuration;
        }

        #endregion

        #region FIXED: ConcatenateVideoSegmentsAsync

        private async Task ConcatenateVideoSegmentsAsync_FIXED(
            string ffmpegPath,
            List<LongVideoSegmentMetadata> segments,
            List<TimelineAudioClip> bgAudioClips,
            VideoExportSettings settings,
            GenerateVideoWindow progressWindow,
            CancellationToken cancellationToken)
        {
            progressWindow.UpdateProgress(75, "Đang ghép các đoạn video...");
            string concatListPath = TempFileManager.CreateTempFile(".txt");
            var concatLines = new StringBuilder();

            foreach (var seg in segments.OrderBy(s => s.SegmentIndex))
            {
                if (!string.IsNullOrEmpty(seg.OutputPath) && File.Exists(seg.OutputPath))
                {
                    var p = seg.OutputPath.Replace("\\", "/").Replace("'", "'\\''");
                    concatLines.AppendLine($"file '{p}'");
                }
            }
            var utf8NoBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
            await File.WriteAllTextAsync(concatListPath, concatLines.ToString(), utf8NoBom, cancellationToken);
            TempFileManager.RegisterForCleanup(concatListPath);
            string tempConcatenatedPath = TempFileManager.CreateTempFile(".mp4");
            TempFileManager.RegisterForCleanup(tempConcatenatedPath);
            var concatArgs = new StringBuilder();
            concatArgs.Append($"-y -hide_banner -f concat -safe 0 -i \"{concatListPath}\" ");
            concatArgs.Append("-c copy ");
            concatArgs.Append($"\"{tempConcatenatedPath}\"");

            await ExecuteFfmpegWithProgress(
                ffmpegPath,
                concatArgs.ToString(),
                progressWindow,
                tempConcatenatedPath,
                cancellationToken,
                0
            );

            progressWindow.UpdateProgress(85, "Đang thêm nhạc nền...");
            if (bgAudioClips != null && bgAudioClips.Any(a => !string.IsNullOrEmpty(a.FilePath) && File.Exists(a.FilePath)))
            {
                TimeSpan totalOutputDuration = TimeSpan.Zero;
                foreach (var seg in segments.OrderBy(s => s.SegmentIndex))
                {
                    if (seg.ActualOutputDuration > TimeSpan.Zero)
                        totalOutputDuration = seg.OutputTimelineOffset + seg.ActualOutputDuration;
                }
                var segmentMaps = BuildSegmentMapsFromMetadata(segments);

                var mixArgs = new StringBuilder();
                mixArgs.Append($"-y -hide_banner -i \"{tempConcatenatedPath}\" ");

                var inputMap = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase)
                {
                    [tempConcatenatedPath] = 0
                };
                int inputIndex = 1;

                foreach (var bg in bgAudioClips)
                {
                    if (bg == null || string.IsNullOrWhiteSpace(bg.FilePath) || !File.Exists(bg.FilePath))
                        continue;
                    if (inputMap.ContainsKey(bg.FilePath))
                        continue;

                    mixArgs.Append($"-i \"{bg.FilePath}\" ");
                    inputMap[bg.FilePath] = inputIndex++;
                }

                var filterComplex = new StringBuilder();
                var audioInputs = new List<string> { "[0:a]" };

                int bgIndex = 0;
                foreach (var bg in bgAudioClips)
                {
                    if (bg == null || !inputMap.TryGetValue(bg.FilePath, out int bgInputIndex) || bgInputIndex == 0)
                        continue;

                    string processedLabel = $"bg_{bgIndex}";
                    double bgVolume = DbToGain(bg.VolumeDb);
                    double mappedStartSec = MapSourceTimeToOutputTimelineSeconds_Fixed(
                        bg.StartTime.TotalSeconds,
                        segmentMaps);

                    long delay = (long)(mappedStartSec * 1000);

                    filterComplex.Append($"[{bgInputIndex}:a]volume={bgVolume.ToString(CultureInfo.InvariantCulture)},adelay={delay}|{delay},aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[{processedLabel}];");
                    audioInputs.Add($"[{processedLabel}]");
                    bgIndex++;
                }

                filterComplex.Append($"{string.Join("", audioInputs)}amix=inputs={audioInputs.Count}:duration=first:normalize=0,alimiter=limit=0.95[final_audio]");

                mixArgs.Append($"-filter_complex \"{filterComplex}\" ");
                mixArgs.Append("-map \"[0:v]\" -map \"[final_audio]\" ");
                mixArgs.Append("-c:v copy ");
                mixArgs.Append($"-c:a aac -b:a {settings.AudioBitrate} -ar 44100 ");
                if (settings.ForceStereo) mixArgs.Append("-ac 2 ");
                mixArgs.Append("-movflags +faststart ");
                mixArgs.Append($"\"{settings.OutputPath}\"");

                await ExecuteFfmpegWithProgress(
                    ffmpegPath,
                    mixArgs.ToString(),
                    progressWindow,
                    settings.OutputPath,
                    cancellationToken,
                    0
                );
            }
            else
            {
                File.Copy(tempConcatenatedPath, settings.OutputPath, true);
            }

            progressWindow.UpdateProgress(100, "Hoàn tất!");
            progressWindow.MarkAsComplete(true);
        }
        private List<SmartCutSegmentMap> BuildSegmentMapsFromMetadata(List<LongVideoSegmentMetadata> segments)
        {
            var maps = new List<SmartCutSegmentMap>();

            foreach (var seg in segments.OrderBy(s => s.SegmentIndex))
            {
                var outputDuration = seg.ActualOutputDuration > TimeSpan.Zero
                    ? seg.ActualOutputDuration
                    : seg.EstimatedOutputDuration;

                maps.Add(new SmartCutSegmentMap
                {
                    SourceStart = seg.SourceStart,
                    SourceEnd = seg.SourceEnd,
                    FinalStart = seg.OutputTimelineOffset,
                    FinalEnd = seg.OutputTimelineOffset + outputDuration,
                    Scale = seg.Duration.TotalSeconds > 0
                        ? outputDuration.TotalSeconds / seg.Duration.TotalSeconds
                        : 1.0
                });
            }

            return maps;
        }
        private double MapSourceTimeToOutputTimelineSeconds_Fixed(
            double sourceTimeSec,
            List<SmartCutSegmentMap> segments)
        {
            foreach (var seg in segments.OrderBy(s => s.SourceStart))
            {
                if (sourceTimeSec >= seg.SourceStart.TotalSeconds && sourceTimeSec < seg.SourceEnd.TotalSeconds)
                {
                    double progressInSegment = sourceTimeSec - seg.SourceStart.TotalSeconds;
                    double outputOffset = progressInSegment * seg.Scale;
                    return seg.FinalStart.TotalSeconds + outputOffset;
                }
            }

            return sourceTimeSec;
        }

        #endregion

        #region Normal Export With Segmentation (for videos > 1 hour)

        /// <summary>
        /// Metadata class for normal video segments (used when exporting long videos in normal mode)
        /// </summary>
        private sealed class NormalVideoSegmentMetadata
        {
            public int SegmentIndex { get; set; }
            public TimeSpan SourceStart { get; set; }
            public TimeSpan SourceEnd { get; set; }
            public TimeSpan Duration => SourceEnd - SourceStart;
            public string OutputPath { get; set; }
            public List<TimelineClipViewModel> SubtitleClips { get; set; } = new();
            public List<TimelineClipViewModel> AudioClips { get; set; } = new();
            public List<TimelineClipViewModel> ImageOverlayClips { get; set; } = new();
            /// <summary>
            /// Video clips that fall within or overlap this segment (for multi-clip support)
            /// </summary>
            public List<TimelineClipViewModel> VideoClips { get; set; } = new();
            public TimeSpan OutputTimelineOffset { get; set; }
            public TimeSpan ActualOutputDuration { get; set; }
        }

        /// <summary>
        /// Calculate smart cut points for normal export that don't cut subtitles, TTS audio, or overlays in the middle
        /// </summary>
        private List<SmartCutPoint> CalculateSmartCutPointsForNormalExport(
            TimeSpan totalDuration,
            double targetSegmentMinutes = 30.0,
            double maxSegmentMinutes = 35.0,
            double minSegmentMinutes = 25.0)
        {
            var cutPoints = new List<SmartCutPoint>();
            var currentStart = TimeSpan.Zero;
            
            // Build occupied zones from subtitles, audio clips (TTS), and image overlays
            var occupiedZones = new List<(TimeSpan Start, TimeSpan End, string Type)>();
            
            // Get all subtitle clips
            var subtitleClips = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Subtitle || c.ClipType == TimelineClipType.Text)
                .ToList();
            foreach (var clip in subtitleClips)
            {
                occupiedZones.Add((clip.StartTime, clip.EndTime, "Subtitle"));
            }
            
            // Get all audio clips (TTS/voiceover)
            var audioClips = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Audio)
                .ToList();
            foreach (var clip in audioClips)
            {
                occupiedZones.Add((clip.StartTime, clip.EndTime, "Audio/TTS"));
            }
            
            // Get all image overlay clips
            var imageOverlays = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Image && c.TrackIndex != 0)
                .ToList();
            foreach (var clip in imageOverlays)
            {
                occupiedZones.Add((clip.StartTime, clip.EndTime, "ImageOverlay"));
            }
            
            occupiedZones = occupiedZones.OrderBy(z => z.Start).ToList();
            var mergedZones = MergeNearbyZones(occupiedZones, TimeSpan.FromSeconds(1.0));
            
            while (currentStart < totalDuration)
            {
                var targetEnd = currentStart + TimeSpan.FromMinutes(targetSegmentMinutes);
                var maxEnd = currentStart + TimeSpan.FromMinutes(maxSegmentMinutes);
                var minEnd = currentStart + TimeSpan.FromMinutes(minSegmentMinutes);
                
                if (targetEnd >= totalDuration || maxEnd >= totalDuration)
                {
                    cutPoints.Add(new SmartCutPoint
                    {
                        CutTime = totalDuration,
                        OriginalCutTime = totalDuration,
                        WasAdjusted = false,
                        AdjustmentReason = "Final segment"
                    });
                    break;
                }
                
                var safeCutTime = FindSafeCutPoint(
                    targetEnd,
                    minEnd,
                    maxEnd,
                    mergedZones,
                    out bool wasAdjusted,
                    out string adjustmentReason);
                    
                if ((safeCutTime - currentStart).TotalMinutes < minSegmentMinutes)
                {
                    safeCutTime = FindNextGapAfter(minEnd, maxEnd, mergedZones);
                    wasAdjusted = true;
                    adjustmentReason = "Extended to minimum length";
                }
                
                cutPoints.Add(new SmartCutPoint
                {
                    CutTime = safeCutTime,
                    OriginalCutTime = targetEnd,
                    WasAdjusted = wasAdjusted,
                    AdjustmentReason = adjustmentReason
                });
                
                currentStart = safeCutTime;
            }
            
            return cutPoints;
        }

        /// <summary>
        /// Execute normal video export with segmentation for videos > 1 hour
        /// Splits video into 30 minute segments to avoid "too large filter complex" error
        /// </summary>
        private async Task ExecuteNormalExportWithSegmentationAsync(
            string ffmpegPath,
            VideoExportSettings settings,
            GenerateVideoWindow progressWindow,
            CancellationToken cancellationToken)
        {
            progressWindow.UpdateProgress(1, "Đang phân tích video dài và tính toán điểm cắt thông minh...");
            
            // Get all video clips on track 0 (main track) sorted by start time
            var allVideoClips = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Video && c.TrackIndex == 0)
                .OrderBy(c => c.StartTime)
                .ToList();
            
            if (!allVideoClips.Any())
            {
                throw new Exception("Không tìm thấy video chính để xuất");
            }
            
            // Validate all video clips have valid files
            foreach (var videoClip in allVideoClips)
            {
                if (videoClip.SourceData is not MediaAsset videoAsset
                    || string.IsNullOrWhiteSpace(videoAsset.FilePath) 
                    || !File.Exists(videoAsset.FilePath))
                {
                    throw new Exception($"Video clip không hợp lệ hoặc file không tồn tại: {(videoClip.SourceData as MediaAsset)?.FilePath ?? "unknown"}");
                }
            }
            
            // Calculate smart cut points (30 min segments)
            var smartCutPoints = CalculateSmartCutPointsForNormalExport(
                _actualContentDuration,
                targetSegmentMinutes: 30.0,
                maxSegmentMinutes: 35.0,
                minSegmentMinutes: 25.0
            );
            
            // Build cut ranges
            var cutRanges = new List<(TimeSpan Start, TimeSpan End)>();
            var prevCut = TimeSpan.Zero;
            foreach (var cutPoint in smartCutPoints)
            {
                cutRanges.Add((prevCut, cutPoint.CutTime));
                prevCut = cutPoint.CutTime;
            }
            
            progressWindow.UpdateProgress(3, $"Chia video thành {cutRanges.Count} đoạn thông minh...");
            
            // Get all subtitle clips sorted by time
            var allSubtitleClips = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Subtitle || c.ClipType == TimelineClipType.Text)
                .OrderBy(c => c.StartTime)
                .ToList();
            
            // Get all audio clips (includes TTS and background music)
            var allAudioClips = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Audio)
                .OrderBy(c => c.StartTime)
                .ToList();
            
            // Get all image overlay clips
            var allImageOverlays = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Image && c.TrackIndex != 0)
                .OrderBy(c => c.StartTime)
                .ToList();
            
            // Build segment metadata
            var segmentMetadatas = new List<NormalVideoSegmentMetadata>();
            TimeSpan cumulativeOutputOffset = TimeSpan.Zero;
            
            for (int i = 0; i < cutRanges.Count; i++)
            {
                var (start, end) = cutRanges[i];
                var segDuration = end - start;
                
                // Get video clips that fall within or overlap this segment
                var segmentVideoClips = allVideoClips
                    .Where(c => c.StartTime < end && c.EndTime > start)
                    .OrderBy(c => c.StartTime)
                    .ToList();
                
                // Get subtitles that fall within or overlap this segment
                var segmentSubtitles = allSubtitleClips
                    .Where(c => c.StartTime < end && c.EndTime > start)
                    .ToList();
                
                // Get audio clips that fall within or overlap this segment
                var segmentAudio = allAudioClips
                    .Where(c => c.StartTime < end && c.EndTime > start)
                    .ToList();
                
                // Get image overlays that fall within or overlap this segment
                var segmentOverlays = allImageOverlays
                    .Where(c => c.StartTime < end && c.EndTime > start)
                    .ToList();
                
                var segMeta = new NormalVideoSegmentMetadata
                {
                    SegmentIndex = i,
                    SourceStart = start,
                    SourceEnd = end,
                    VideoClips = segmentVideoClips,
                    SubtitleClips = segmentSubtitles,
                    AudioClips = segmentAudio,
                    ImageOverlayClips = segmentOverlays,
                    OutputTimelineOffset = cumulativeOutputOffset,
                    ActualOutputDuration = segDuration
                };
                
                cumulativeOutputOffset += segDuration;
                segmentMetadatas.Add(segMeta);
            }
            
            // Process each segment
            for (int i = 0; i < segmentMetadatas.Count; i++)
            {
                var segMeta = segmentMetadatas[i];
                
                // Skip segments with no video clips (should not happen since we validate video clips exist, but safety check)
                if (!segMeta.VideoClips.Any())
                {
                    System.Diagnostics.Debug.WriteLine($"[Warning] Segment {i + 1} has no video clips, skipping...");
                    continue;
                }
                
                try
                {
                    progressWindow.UpdateProgress(
                        5 + (i * 70 / segmentMetadatas.Count),
                        $"Đang xử lý segment {i + 1}/{segmentMetadatas.Count}..."
                    );
                    
                    var outputPath = await ProcessSingleNormalVideoSegmentWithMultiClipsAsync(
                        ffmpegPath,
                        segMeta,
                        settings,
                        progressWindow,
                        cancellationToken
                    );
                    
                    segMeta.OutputPath = outputPath;
                    
                    if (File.Exists(outputPath))
                    {
                        var info = await FFProbe.AnalyseAsync(outputPath);
                        segMeta.ActualOutputDuration = info.Duration;
                    }
                }
                catch (Exception ex)
                {
                    throw new Exception($"Lỗi khi xử lý segment {i + 1}: {ex.Message}", ex);
                }
            }
            
            // Concatenate all segments
            var validSegments = segmentMetadatas
                .Where(s => !string.IsNullOrEmpty(s.OutputPath) && File.Exists(s.OutputPath))
                .ToList();
            
            if (validSegments.Count == 0)
            {
                throw new Exception("Không có segment nào được xử lý thành công");
            }
            
            await ConcatenateNormalVideoSegmentsAsync(
                ffmpegPath,
                validSegments,
                allAudioClips,
                settings,
                progressWindow,
                cancellationToken
            );
        }

        /// <summary>
        /// Process a single segment for normal video export
        /// </summary>
        private async Task<string> ProcessSingleNormalVideoSegmentAsync(
            string ffmpegPath,
            MediaAsset mainVideoAsset,
            NormalVideoSegmentMetadata segMeta,
            VideoExportSettings settings,
            GenerateVideoWindow progressWindow,
            CancellationToken cancellationToken)
        {
            // Generate ASS file for subtitles in this segment (with adjusted timing)
            string assContent = GenerateAssFileContentForSegment(
                settings.ResolutionWidth,
                settings.ResolutionHeight,
                segMeta.SubtitleClips,
                segMeta.SourceStart
            );
            string tempAssPath = TempFileManager.CreateTempFile(".ass");
            await File.WriteAllTextAsync(tempAssPath, assContent, Encoding.UTF8, cancellationToken);
            TempFileManager.RegisterForCleanup(tempAssPath);
            
            string segmentOutputPath = TempFileManager.CreateTempFile(".mp4");
            TempFileManager.RegisterForCleanup(segmentOutputPath);
            
            // Build filter complex for this segment
            var filterComplex = BuildFilterComplexForNormalSegment(
                mainVideoAsset,
                segMeta,
                settings,
                tempAssPath
            );
            
            // Write filter script to file
            var filterScriptPath = TempFileManager.CreateTempFile(".txt");
            await WriteTextNoBomAsync(filterScriptPath, filterComplex, cancellationToken);
            TempFileManager.RegisterForCleanup(filterScriptPath);
            
            // Build ffmpeg arguments
            var argsBuilder = new StringBuilder();
            argsBuilder.Append("-y -hide_banner ");
            
            // GPU acceleration
            string finalGpuAccel = "none";
            string finalVideoCodec = settings.VideoCodec;
            if (settings.GpuAcceleration == "auto")
            {
                var allGpus = await FfmpegGpuDetector.GetAvailableGpusAsync();
                var bestGpu = FfmpegGpuDetector.GetBestAvailableGpu(allGpus);
                if (bestGpu != null && bestGpu.FfmpegValue != "none")
                {
                    finalGpuAccel = bestGpu.FfmpegValue;
                    finalVideoCodec = bestGpu.RecommendedCodec;
                }
            }
            else if (!string.IsNullOrEmpty(settings.GpuAcceleration) && settings.GpuAcceleration != "none")
            {
                finalGpuAccel = settings.GpuAcceleration;
            }
            
            if (finalGpuAccel != "none")
            {
                argsBuilder.Append($"-hwaccel {finalGpuAccel} ");
            }
            
            // Input: main video with seek and duration
            double trimStart = mainVideoAsset?.TrimStartOffset.TotalSeconds ?? 0;
            double seekPosition = segMeta.SourceStart.TotalSeconds + trimStart;
            double duration = segMeta.Duration.TotalSeconds + 2.0; // Small buffer
            
            argsBuilder.Append($"-ss {seekPosition.ToString(CultureInfo.InvariantCulture)} ");
            argsBuilder.Append($"-t {duration.ToString(CultureInfo.InvariantCulture)} ");
            argsBuilder.Append($"-i \"{mainVideoAsset.FilePath}\" ");
            
            // Add audio clip inputs if any
            var inputMap = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            inputMap[mainVideoAsset.FilePath] = 0;
            int inputIndex = 1;
            
            // Classify audio clips - only include TTS clips in segment, background music handled at concatenation
            var (ttsClips, _) = ClassifyAudioClipsForExport();
            var segmentTtsClips = segMeta.AudioClips
                .Where(ac => ac.SourceData is TimelineAudioClip tac && 
                            ttsClips.Any(t => t.FilePath == tac.FilePath))
                .ToList();
            
            foreach (var audioClip in segmentTtsClips)
            {
                if (audioClip.SourceData is TimelineAudioClip tac && 
                    !string.IsNullOrEmpty(tac.FilePath) && 
                    File.Exists(tac.FilePath) &&
                    !inputMap.ContainsKey(tac.FilePath))
                {
                    argsBuilder.Append($"-i \"{tac.FilePath}\" ");
                    inputMap[tac.FilePath] = inputIndex++;
                }
            }
            
            // Add image overlay inputs
            foreach (var imgClip in segMeta.ImageOverlayClips)
            {
                if (imgClip.SourceData is MediaAsset imgAsset &&
                    !string.IsNullOrEmpty(imgAsset.FilePath) &&
                    File.Exists(imgAsset.FilePath) &&
                    !inputMap.ContainsKey(imgAsset.FilePath))
                {
                    argsBuilder.Append($"-stream_loop -1 -i \"{imgAsset.FilePath}\" ");
                    inputMap[imgAsset.FilePath] = inputIndex++;
                }
            }
            
            // Build filter complex with proper handling
            var segmentFilter = BuildFilterComplexForNormalSegmentWithInputs(
                mainVideoAsset,
                segMeta,
                settings,
                tempAssPath,
                inputMap,
                segmentTtsClips
            );
            
            filterScriptPath = TempFileManager.CreateTempFile(".txt");
            await WriteTextNoBomAsync(filterScriptPath, segmentFilter, cancellationToken);
            TempFileManager.RegisterForCleanup(filterScriptPath);
            
            argsBuilder.Append($"-filter_complex_script \"{filterScriptPath}\" -filter_threads 0 ");
            argsBuilder.Append("-map \"[video_out]\" -map \"[final_audio]\" ");
            
            // Codec settings
            bool isHardwareEncoder = false;
            if (!string.IsNullOrWhiteSpace(finalVideoCodec))
            {
                string lowerCodec = finalVideoCodec.ToLowerInvariant();
                if (lowerCodec.Contains("_nvenc") || lowerCodec.Contains("_qsv") || lowerCodec.Contains("_amf"))
                {
                    isHardwareEncoder = true;
                }
            }
            
            if (isHardwareEncoder)
            {
                argsBuilder.Append($"-c:v {finalVideoCodec} ");
                argsBuilder.Append($"-cq {settings.Crf} ");
                string hwPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "p4";
                argsBuilder.Append($"-preset {hwPreset} ");
                argsBuilder.Append("-vsync cfr -r 30 ");
            }
            else
            {
                argsBuilder.Append($"-c:v {finalVideoCodec ?? "libx264"} ");
                argsBuilder.Append($"-crf {settings.Crf} ");
                string cpuPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "medium";
                argsBuilder.Append($"-preset {cpuPreset} ");
            }
            
            argsBuilder.Append($"-c:a aac -b:a {settings.AudioBitrate} -ar 44100 ");
            if (settings.ForceStereo) argsBuilder.Append("-ac 2 ");
            argsBuilder.Append("-movflags +faststart ");
            argsBuilder.Append($"\"{segmentOutputPath}\"");
            
            await ExecuteFfmpegWithProgress(
                ffmpegPath,
                argsBuilder.ToString(),
                progressWindow,
                segmentOutputPath,
                cancellationToken,
                segMeta.Duration.TotalSeconds
            );
            
            return segmentOutputPath;
        }

        /// <summary>
        /// Process a single segment for normal video export with multiple video clips support.
        /// This method handles segments that may contain multiple video clips on the timeline,
        /// properly calculating trim start/end for each clip and applying per-clip pan/zoom.
        /// </summary>
        private async Task<string> ProcessSingleNormalVideoSegmentWithMultiClipsAsync(
            string ffmpegPath,
            NormalVideoSegmentMetadata segMeta,
            VideoExportSettings settings,
            GenerateVideoWindow progressWindow,
            CancellationToken cancellationToken)
        {
            // Generate ASS file for subtitles in this segment (with adjusted timing)
            string assContent = GenerateAssFileContentForSegment(
                settings.ResolutionWidth,
                settings.ResolutionHeight,
                segMeta.SubtitleClips,
                segMeta.SourceStart
            );
            string tempAssPath = TempFileManager.CreateTempFile(".ass");
            await File.WriteAllTextAsync(tempAssPath, assContent, Encoding.UTF8, cancellationToken);
            TempFileManager.RegisterForCleanup(tempAssPath);
            
            string segmentOutputPath = TempFileManager.CreateTempFile(".mp4");
            TempFileManager.RegisterForCleanup(segmentOutputPath);
            
            // Build ffmpeg arguments
            var argsBuilder = new StringBuilder();
            argsBuilder.Append("-y -hide_banner ");
            
            // GPU acceleration
            string finalGpuAccel = "none";
            string finalVideoCodec = settings.VideoCodec;
            if (settings.GpuAcceleration == "auto")
            {
                var allGpus = await FfmpegGpuDetector.GetAvailableGpusAsync();
                var bestGpu = FfmpegGpuDetector.GetBestAvailableGpu(allGpus);
                if (bestGpu != null && bestGpu.FfmpegValue != "none")
                {
                    finalGpuAccel = bestGpu.FfmpegValue;
                    finalVideoCodec = bestGpu.RecommendedCodec;
                }
            }
            else if (!string.IsNullOrEmpty(settings.GpuAcceleration) && settings.GpuAcceleration != "none")
            {
                finalGpuAccel = settings.GpuAcceleration;
            }
            
            if (finalGpuAccel != "none")
            {
                argsBuilder.Append($"-hwaccel {finalGpuAccel} ");
            }
            
            // Build input map for all video clips in this segment
            var inputMap = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            int inputIndex = 0;
            
            // Add video clip inputs
            foreach (var videoClip in segMeta.VideoClips)
            {
                if (videoClip.SourceData is MediaAsset videoAsset &&
                    !string.IsNullOrEmpty(videoAsset.FilePath) &&
                    File.Exists(videoAsset.FilePath) &&
                    !inputMap.ContainsKey(videoAsset.FilePath))
                {
                    inputMap[videoAsset.FilePath] = inputIndex++;
                    argsBuilder.Append($"-i \"{videoAsset.FilePath}\" ");
                }
            }
            
            // Classify audio clips - only include TTS clips in segment, background music handled at concatenation
            var (ttsClips, _) = ClassifyAudioClipsForExport();
            var segmentTtsClips = segMeta.AudioClips
                .Where(ac => ac.SourceData is TimelineAudioClip tac && 
                            ttsClips.Any(t => t.FilePath == tac.FilePath))
                .ToList();
            
            foreach (var audioClip in segmentTtsClips)
            {
                if (audioClip.SourceData is TimelineAudioClip tac && 
                    !string.IsNullOrEmpty(tac.FilePath) && 
                    File.Exists(tac.FilePath) &&
                    !inputMap.ContainsKey(tac.FilePath))
                {
                    argsBuilder.Append($"-i \"{tac.FilePath}\" ");
                    inputMap[tac.FilePath] = inputIndex++;
                }
            }
            
            // Add image overlay inputs
            foreach (var imgClip in segMeta.ImageOverlayClips)
            {
                if (imgClip.SourceData is MediaAsset imgAsset &&
                    !string.IsNullOrEmpty(imgAsset.FilePath) &&
                    File.Exists(imgAsset.FilePath) &&
                    !inputMap.ContainsKey(imgAsset.FilePath))
                {
                    argsBuilder.Append($"-stream_loop -1 -i \"{imgAsset.FilePath}\" ");
                    inputMap[imgAsset.FilePath] = inputIndex++;
                }
            }
            
            // Build filter complex for multi-clip segment
            var filterComplex = BuildFilterComplexForMultiClipSegment(
                segMeta,
                settings,
                tempAssPath,
                inputMap
            );
            
            // Write filter script to file
            var filterScriptPath = TempFileManager.CreateTempFile(".txt");
            await WriteTextNoBomAsync(filterScriptPath, filterComplex, cancellationToken);
            TempFileManager.RegisterForCleanup(filterScriptPath);
            
            argsBuilder.Append($"-filter_complex_script \"{filterScriptPath}\" -filter_threads 0 ");
            argsBuilder.Append("-map \"[video_out]\" -map \"[final_audio]\" ");
            
            // Codec settings
            bool isHardwareEncoder = false;
            if (!string.IsNullOrWhiteSpace(finalVideoCodec))
            {
                string lowerCodec = finalVideoCodec.ToLowerInvariant();
                if (lowerCodec.Contains("_nvenc") || lowerCodec.Contains("_qsv") || lowerCodec.Contains("_amf"))
                {
                    isHardwareEncoder = true;
                }
            }
            
            if (isHardwareEncoder)
            {
                argsBuilder.Append($"-c:v {finalVideoCodec} ");
                argsBuilder.Append($"-cq {settings.Crf} ");
                string hwPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "p4";
                argsBuilder.Append($"-preset {hwPreset} ");
                argsBuilder.Append("-vsync cfr -r 30 ");
            }
            else
            {
                argsBuilder.Append($"-c:v {finalVideoCodec ?? "libx264"} ");
                argsBuilder.Append($"-crf {settings.Crf} ");
                string cpuPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "medium";
                argsBuilder.Append($"-preset {cpuPreset} ");
            }
            
            argsBuilder.Append($"-c:a aac -b:a {settings.AudioBitrate} -ar 44100 ");
            if (settings.ForceStereo) argsBuilder.Append("-ac 2 ");
            argsBuilder.Append("-movflags +faststart ");
            argsBuilder.Append($"\"{segmentOutputPath}\"");
            
            await ExecuteFfmpegWithProgress(
                ffmpegPath,
                argsBuilder.ToString(),
                progressWindow,
                segmentOutputPath,
                cancellationToken,
                segMeta.Duration.TotalSeconds
            );
            
            return segmentOutputPath;
        }

        /// <summary>
        /// Build filter complex for a segment with multiple video clips.
        /// Each clip gets its own trim, pan/zoom, and is then concatenated.
        /// </summary>
        private string BuildFilterComplexForMultiClipSegment(
            NormalVideoSegmentMetadata segMeta,
            VideoExportSettings settings,
            string assPath,
            Dictionary<string, int> inputMap)
        {
            var filterComplex = new StringBuilder();
            int W = settings.ResolutionWidth;
            int H = settings.ResolutionHeight;
            
            var videoClipsInSegment = segMeta.VideoClips
                .OrderBy(c => c.StartTime)
                .ToList();
            
            var videoSegmentLabels = new List<string>();
            var audioSegmentLabels = new List<string>();
            
            for (int i = 0; i < videoClipsInSegment.Count; i++)
            {
                var clip = videoClipsInSegment[i];
                var mediaAsset = clip.SourceData as MediaAsset;
                
                if (mediaAsset == null || !inputMap.TryGetValue(mediaAsset.FilePath, out int mapIndex))
                    continue;
                
                // Calculate the portion of this clip that falls within the segment
                var clipStartInTimeline = clip.StartTime;
                var clipEndInTimeline = clip.EndTime;
                
                // Clamp clip range to segment range
                var effectiveStart = clipStartInTimeline < segMeta.SourceStart ? segMeta.SourceStart : clipStartInTimeline;
                var effectiveEnd = clipEndInTimeline > segMeta.SourceEnd ? segMeta.SourceEnd : clipEndInTimeline;
                
                if (effectiveEnd <= effectiveStart)
                    continue; // Clip doesn't contribute to this segment
                
                // Calculate trim start relative to the clip's source start (accounting for clip's own TrimStartOffset)
                double clipTrimStart = mediaAsset.TrimStartOffset.TotalSeconds;
                double offsetIntoClip = (effectiveStart - clipStartInTimeline).TotalSeconds;
                double srcTrimStart = clipTrimStart + offsetIntoClip;
                
                // Duration of this clip's contribution to the segment
                double clipDuration = (effectiveEnd - effectiveStart).TotalSeconds;
                
                // Apply speed if set
                double speed = mediaAsset.Speed > 0 ? mediaAsset.Speed : 1.0;
                double srcDuration = clipDuration * speed;
                
                // Build pan/zoom filter for this clip
                double zoom = Math.Max(mediaAsset.Scale, 0.0001);
                double posX = mediaAsset.PositionX;
                double posY = mediaAsset.PositionY;
                
                string panZoomFilter;
                if (Math.Abs(zoom - 1.0) > 0.001 || Math.Abs(posX - 0.5) > 0.001 || Math.Abs(posY - 0.5) > 0.001)
                {
                    string cover = $"max({W}/iw\\,{H}/ih)";
                    string zoomExpr = $"max({zoom.ToString(CultureInfo.InvariantCulture)}\\,1)";
                    string eff = $"({cover})*({zoomExpr})";
                    string scaleFilter = $"scale=w=ceil(iw*{eff}):h=ceil(ih*{eff})";
                    
                    string cx = $"(iw - {W})/2 - ({posX.ToString(CultureInfo.InvariantCulture)} - 0.5)*{W}";
                    string cy = $"(ih - {H})/2 - ({posY.ToString(CultureInfo.InvariantCulture)} - 0.5)*{H}";
                    string cropX = $"x='max(0\\,min(iw-{W}\\,({cx})))'";
                    string cropY = $"y='max(0\\,min(ih-{H}\\,({cy})))'";
                    
                    panZoomFilter = $"{scaleFilter},crop={W}:{H}:{cropX}:{cropY}";
                }
                else
                {
                    string cover = $"max({W}/iw\\,{H}/ih)";
                    panZoomFilter = $"scale=w=ceil(iw*({cover})):h=ceil(ih*({cover})),crop={W}:{H}";
                }
                
                // Build video chain for this clip
                string ptsFilter = (Math.Abs(speed - 1.0) > 0.01) ? $",setpts=PTS/{speed.ToString(CultureInfo.InvariantCulture)}" : "";
                string v_label = $"[v_clip_{i}]";
                string a_label = $"[a_clip_{i}]";
                
                filterComplex.Append($"[{mapIndex}:v]trim=start={srcTrimStart.ToString(CultureInfo.InvariantCulture)}:duration={srcDuration.ToString(CultureInfo.InvariantCulture)}{ptsFilter},setpts=PTS-STARTPTS,{panZoomFilter},setsar=1,scale='trunc(iw/2)*2:trunc(ih/2)*2'{v_label};");
                
                // Build audio chain for this clip
                string atempoFilter = (Math.Abs(speed - 1.0) > 0.01) ? $",atempo={speed.ToString(CultureInfo.InvariantCulture)}" : "";
                double clipVolumeDb = mediaAsset.VolumeDb;
                filterComplex.Append($"[{mapIndex}:a]atrim=start={srcTrimStart.ToString(CultureInfo.InvariantCulture)}:duration={srcDuration.ToString(CultureInfo.InvariantCulture)},asetpts=PTS-STARTPTS{atempoFilter},volume={DbToGain(clipVolumeDb).ToString(CultureInfo.InvariantCulture)},aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo{a_label};");
                
                videoSegmentLabels.Add(v_label);
                audioSegmentLabels.Add(a_label);
            }
            
            // Concatenate all video clips in this segment
            string currentVideoTag;
            string currentAudioTag;
            
            if (videoSegmentLabels.Count > 1)
            {
                filterComplex.Append($"{string.Join("", videoSegmentLabels)}concat=n={videoSegmentLabels.Count}:v=1:a=0[v_concat];");
                filterComplex.Append($"{string.Join("", audioSegmentLabels)}concat=n={audioSegmentLabels.Count}:v=0:a=1[a_concat];");
                currentVideoTag = "v_concat";
                currentAudioTag = "a_concat";
            }
            else if (videoSegmentLabels.Count == 1)
            {
                // Only one clip - use it directly
                currentVideoTag = videoSegmentLabels[0].Trim('[', ']');
                currentAudioTag = audioSegmentLabels[0].Trim('[', ']');
            }
            else
            {
                // No video clips - create black video
                filterComplex.Append($"nullsrc=size={W}x{H}:duration={segMeta.Duration.TotalSeconds.ToString(CultureInfo.InvariantCulture)},format=yuv420p[v_concat];");
                filterComplex.Append($"anullsrc=channel_layout=stereo:sample_rate=44100,atrim=duration={segMeta.Duration.TotalSeconds.ToString(CultureInfo.InvariantCulture)},asetpts=PTS-STARTPTS[a_concat];");
                currentVideoTag = "v_concat";
                currentAudioTag = "a_concat";
            }
            
            // Apply blur if enabled
            string blurChain = BuildBlurBoxFilter(
                currentVideoTag,
                "v_blur",
                CurrentProject,
                segMeta.SubtitleClips.Any(),
                segMeta.Duration
            );
            filterComplex.Append(blurChain + ";");
            currentVideoTag = "v_blur";
            
            // Flip if enabled
            if (_isVideoFlipEnabled)
            {
                filterComplex.Append($"[{currentVideoTag}]hflip[v_flipped];");
                currentVideoTag = "v_flipped";
            }
            
            // Apply subtitles
            string fontsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Fonts");
            if (!Directory.Exists(fontsDir)) fontsDir = @"C:\Windows\Fonts";
            string escapedAss = EscapePathForFilterScript(assPath);
            string escapedFonts = EscapePathForFilterScript(fontsDir);
            filterComplex.Append($"[{currentVideoTag}]subtitles=filename='{escapedAss}':fontsdir='{escapedFonts}':charenc=UTF-8[video_out];");
            
            // Final audio processing
            filterComplex.Append($"[{currentAudioTag}]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,alimiter=limit=0.97[final_audio]");
            
            return filterComplex.ToString();
        }

        /// <summary>
        /// Generate ASS content for a specific segment with adjusted timing
        /// </summary>
        private string GenerateAssFileContentForSegment(
            int playResX,
            int playResY,
            List<TimelineClipViewModel> subtitleClips,
            TimeSpan segmentOffset)
        {
            // Create subtitle timeline with adjusted times
            var subtitleTimeline = new List<(SrtSubtitleLine Line, TimeSpan FinalStart, TimeSpan FinalEnd)>();
            
            foreach (var clip in subtitleClips)
            {
                if (clip.SourceData is SrtSubtitleLine srtLine)
                {
                    // Adjust timing relative to segment start
                    var adjustedStart = clip.StartTime - segmentOffset;
                    var adjustedEnd = clip.EndTime - segmentOffset;
                    
                    // Clamp to segment boundaries
                    if (adjustedStart < TimeSpan.Zero) adjustedStart = TimeSpan.Zero;
                    if (adjustedEnd < TimeSpan.Zero) continue; // Skip if entirely before segment
                    
                    subtitleTimeline.Add((srtLine, adjustedStart, adjustedEnd));
                }
            }
            
            return GenerateAssFileContentForSmartCut(playResX, playResY, subtitleTimeline);
        }

        /// <summary>
        /// Build simple filter complex for normal segment
        /// </summary>
        private string BuildFilterComplexForNormalSegment(
            MediaAsset mainVideoAsset,
            NormalVideoSegmentMetadata segMeta,
            VideoExportSettings settings,
            string assPath)
        {
            var filterComplex = new StringBuilder();
            int W = settings.ResolutionWidth;
            int H = settings.ResolutionHeight;
            
            // Pan/zoom filter
            double zoom = Math.Max(mainVideoAsset.Scale, 0.0001);
            double posX = mainVideoAsset.PositionX;
            double posY = mainVideoAsset.PositionY;
            
            string cover = $"max({W}/iw\\,{H}/ih)";
            string zoomExpr = $"max({zoom.ToString(CultureInfo.InvariantCulture)}\\,1)";
            string eff = $"({cover})*({zoomExpr})";
            string scaleFilter = $"scale=w=ceil(iw*{eff}):h=ceil(ih*{eff})";
            string cx = $"(iw - {W})/2 - ({posX.ToString(CultureInfo.InvariantCulture)} - 0.5)*{W}";
            string cy = $"(ih - {H})/2 - ({posY.ToString(CultureInfo.InvariantCulture)} - 0.5)*{H}";
            string cropX = $"x='max(0\\,min(iw-{W}\\,({cx})))'";
            string cropY = $"y='max(0\\,min(ih-{H}\\,({cy})))'";
            string panZoomFilter = $"{scaleFilter},crop={W}:{H}:{cropX}:{cropY}";
            
            double duration = segMeta.Duration.TotalSeconds;
            
            // Video processing
            filterComplex.Append($"[0:v]trim=duration={duration.ToString(CultureInfo.InvariantCulture)},setpts=PTS-STARTPTS,{panZoomFilter},setsar=1[v_processed];");
            
            // Blur (if enabled)
            string currentVideoTag = "v_processed";
            string blurChain = BuildBlurBoxFilter(
                currentVideoTag,
                "v_blur",
                CurrentProject,
                segMeta.SubtitleClips.Any(),
                segMeta.Duration
            );
            filterComplex.Append(blurChain + ";");
            currentVideoTag = "v_blur";
            
            // Flip if enabled
            if (_isVideoFlipEnabled)
            {
                filterComplex.Append($"[{currentVideoTag}]hflip[v_flipped];");
                currentVideoTag = "v_flipped";
            }
            
            // Subtitles
            string fontsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Fonts");
            if (!Directory.Exists(fontsDir)) fontsDir = @"C:\Windows\Fonts";
            string escapedAss = EscapePathForFilterScript(assPath);
            string escapedFonts = EscapePathForFilterScript(fontsDir);
            filterComplex.Append($"[{currentVideoTag}]subtitles=filename='{escapedAss}':fontsdir='{escapedFonts}':charenc=UTF-8[video_out];");
            
            // Audio
            double mainVideoVolumeDb = ResolveDbOrDefault(mainVideoAsset.VolumeDb, 0.0);
            filterComplex.Append($"[0:a]atrim=duration={duration.ToString(CultureInfo.InvariantCulture)},asetpts=PTS-STARTPTS,volume={DbToGain(mainVideoVolumeDb).ToString(CultureInfo.InvariantCulture)},aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,alimiter=limit=0.97[final_audio]");
            
            return filterComplex.ToString();
        }

        /// <summary>
        /// Build filter complex for normal segment with all inputs (audio, overlays)
        /// </summary>
        private string BuildFilterComplexForNormalSegmentWithInputs(
            MediaAsset mainVideoAsset,
            NormalVideoSegmentMetadata segMeta,
            VideoExportSettings settings,
            string assPath,
            Dictionary<string, int> inputMap,
            List<TimelineClipViewModel> ttsClips)
        {
            var filterComplex = new StringBuilder();
            int W = settings.ResolutionWidth;
            int H = settings.ResolutionHeight;
            
            // Pan/zoom filter
            double zoom = Math.Max(mainVideoAsset.Scale, 0.0001);
            double posX = mainVideoAsset.PositionX;
            double posY = mainVideoAsset.PositionY;
            
            string cover = $"max({W}/iw\\,{H}/ih)";
            string zoomExpr = $"max({zoom.ToString(CultureInfo.InvariantCulture)}\\,1)";
            string eff = $"({cover})*({zoomExpr})";
            string scaleFilter = $"scale=w=ceil(iw*{eff}):h=ceil(ih*{eff})";
            string cx = $"(iw - {W})/2 - ({posX.ToString(CultureInfo.InvariantCulture)} - 0.5)*{W}";
            string cy = $"(ih - {H})/2 - ({posY.ToString(CultureInfo.InvariantCulture)} - 0.5)*{H}";
            string cropX = $"x='max(0\\,min(iw-{W}\\,({cx})))'";
            string cropY = $"y='max(0\\,min(ih-{H}\\,({cy})))'";
            string panZoomFilter = $"{scaleFilter},crop={W}:{H}:{cropX}:{cropY}";
            
            double duration = segMeta.Duration.TotalSeconds;
            string durationStr = duration.ToString(CultureInfo.InvariantCulture);
            
            // Video processing
            filterComplex.Append($"[0:v]trim=duration={durationStr},setpts=PTS-STARTPTS,{panZoomFilter},setsar=1[v_processed];");
            
            string currentVideoTag = "v_processed";
            
            // Process image overlays
            double refW = CurrentProject?.ProjectReferenceVideoWidth > 0 ? CurrentProject.ProjectReferenceVideoWidth : 1280.0;
            double refH = CurrentProject?.ProjectReferenceVideoHeight > 0 ? CurrentProject.ProjectReferenceVideoHeight : 720.0;
            double scaleXFactor = settings.ResolutionWidth / refW;
            double scaleYFactor = settings.ResolutionHeight / refH;
            
            int overlayIdx = 0;
            foreach (var imgClip in segMeta.ImageOverlayClips)
            {
                if (imgClip.SourceData is not MediaAsset imgAsset) continue;
                if (!inputMap.TryGetValue(imgAsset.FilePath, out int imgInputIndex)) continue;
                
                // Calculate timing relative to segment
                double imgStartRel = Math.Max(0, (imgClip.StartTime - segMeta.SourceStart).TotalSeconds);
                double imgEndRel = Math.Min(duration, (imgClip.EndTime - segMeta.SourceStart).TotalSeconds);
                
                if (imgEndRel <= imgStartRel + 0.01) continue;
                
                double imgAR = imgAsset.Height > 0 ? (double)imgAsset.Width / imgAsset.Height : 1.0;
                double initW_ref, initH_ref;
                if ((refW / refH) > imgAR) { initH_ref = refH; initW_ref = initH_ref * imgAR; }
                else { initW_ref = refW; initH_ref = initW_ref / imgAR; }
                
                double finalW_out = initW_ref * Math.Max(imgAsset.ScaleX, 0.0001) * scaleXFactor;
                double finalH_out = initH_ref * Math.Max(imgAsset.ScaleY, 0.0001) * scaleYFactor;
                int outW = Math.Max(1, (int)Math.Round(finalW_out));
                int outH = Math.Max(1, (int)Math.Round(finalH_out));
                double centerX_out = imgAsset.PositionX * refW * scaleXFactor;
                double centerY_out = imgAsset.PositionY * refH * scaleYFactor;
                double radians = (imgAsset.Rotation) * Math.PI / 180.0;
                
                string processedLabel = $"img_{overlayIdx}";
                string nextLabel = $"v_img_{overlayIdx}";
                
                filterComplex.Append(
                    $"[{imgInputIndex}:v]" +
                    $"scale={outW}:{outH}:flags=lanczos," +
                    $"format=rgba," +
                    $"rotate='{radians.ToString(CultureInfo.InvariantCulture)}:c=none:ow=hypot(iw\\,ih):oh=hypot(iw\\,ih)'" +
                    $"[{processedLabel}];");
                
                string ox = $"{centerX_out.ToString(CultureInfo.InvariantCulture)}-overlay_w/2";
                string oy = $"{centerY_out.ToString(CultureInfo.InvariantCulture)}-overlay_h/2";
                string enableExpr = $"between(t,{imgStartRel.ToString(CultureInfo.InvariantCulture)},{imgEndRel.ToString(CultureInfo.InvariantCulture)})";
                
                filterComplex.Append(
                    $"[{currentVideoTag}][{processedLabel}]" +
                    $"overlay=x='{ox}':y='{oy}':eval=init:shortest=1:format=auto:enable='{enableExpr}'" +
                    $"[{nextLabel}];");
                
                currentVideoTag = nextLabel;
                overlayIdx++;
            }
            
            // Blur (if enabled)
            string blurChain = BuildBlurBoxFilter(
                currentVideoTag,
                "v_blur",
                CurrentProject,
                segMeta.SubtitleClips.Any(),
                segMeta.Duration
            );
            filterComplex.Append(blurChain + ";");
            currentVideoTag = "v_blur";
            
            // Flip if enabled
            if (_isVideoFlipEnabled)
            {
                filterComplex.Append($"[{currentVideoTag}]hflip[v_flipped];");
                currentVideoTag = "v_flipped";
            }
            
            // Subtitles
            string fontsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Fonts");
            if (!Directory.Exists(fontsDir)) fontsDir = @"C:\Windows\Fonts";
            string escapedAss = EscapePathForFilterScript(assPath);
            string escapedFonts = EscapePathForFilterScript(fontsDir);
            filterComplex.Append($"[{currentVideoTag}]subtitles=filename='{escapedAss}':fontsdir='{escapedFonts}':charenc=UTF-8[video_out];");
            
            // Audio processing
            double mainVideoVolumeDb = ResolveDbOrDefault(mainVideoAsset.VolumeDb, 0.0);
            var audioMixInputs = new List<string>();
            
            // Main video audio
            filterComplex.Append($"[0:a]atrim=duration={durationStr},asetpts=PTS-STARTPTS,volume={DbToGain(mainVideoVolumeDb).ToString(CultureInfo.InvariantCulture)},aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a_main];");
            audioMixInputs.Add("[a_main]");
            
            // TTS audio clips
            int ttsIdx = 0;
            foreach (var audioClip in ttsClips)
            {
                if (audioClip.SourceData is not TimelineAudioClip tac) continue;
                if (!inputMap.TryGetValue(tac.FilePath, out int audioInputIdx)) continue;
                
                // Calculate timing relative to segment
                double startRel = Math.Max(0, (audioClip.StartTime - segMeta.SourceStart).TotalSeconds);
                double endRel = Math.Min(duration, (audioClip.EndTime - segMeta.SourceStart).TotalSeconds);
                double clipDur = endRel - startRel;
                
                if (clipDur <= 0.01) continue;
                
                double ttsDb = ResolveDbOrDefault(tac.VolumeDb, +3.0);
                long delayMs = (long)(startRel * 1000);
                
                string ttsLabel = $"a_tts_{ttsIdx}";
                filterComplex.Append($"[{audioInputIdx}:a]volume={DbToGain(ttsDb).ToString(CultureInfo.InvariantCulture)},adelay={delayMs}|{delayMs},aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[{ttsLabel}];");
                audioMixInputs.Add($"[{ttsLabel}]");
                ttsIdx++;
            }
            
            // Mix all audio
            if (audioMixInputs.Count > 1)
            {
                filterComplex.Append($"{string.Join("", audioMixInputs)}amix=inputs={audioMixInputs.Count}:duration=first:normalize=0,alimiter=limit=0.97[final_audio]");
            }
            else
            {
                filterComplex.Append($"[a_main]alimiter=limit=0.97[final_audio]");
            }
            
            return filterComplex.ToString();
        }

        /// <summary>
        /// Concatenate all normal video segments and add background music
        /// </summary>
        private async Task ConcatenateNormalVideoSegmentsAsync(
            string ffmpegPath,
            List<NormalVideoSegmentMetadata> segments,
            List<TimelineClipViewModel> allAudioClips,
            VideoExportSettings settings,
            GenerateVideoWindow progressWindow,
            CancellationToken cancellationToken)
        {
            progressWindow.UpdateProgress(80, "Đang ghép các đoạn video...");
            
            // Create concat list file
            string concatListPath = TempFileManager.CreateTempFile(".txt");
            var concatLines = new StringBuilder();
            
            foreach (var seg in segments.OrderBy(s => s.SegmentIndex))
            {
                if (!string.IsNullOrEmpty(seg.OutputPath) && File.Exists(seg.OutputPath))
                {
                    var p = seg.OutputPath.Replace("\\", "/").Replace("'", "'\\''");
                    concatLines.AppendLine($"file '{p}'");
                }
            }
            
            var utf8NoBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
            await File.WriteAllTextAsync(concatListPath, concatLines.ToString(), utf8NoBom, cancellationToken);
            TempFileManager.RegisterForCleanup(concatListPath);
            
            // First concatenate without background music
            string tempConcatenatedPath = TempFileManager.CreateTempFile(".mp4");
            TempFileManager.RegisterForCleanup(tempConcatenatedPath);
            
            var concatArgs = new StringBuilder();
            concatArgs.Append($"-y -hide_banner -f concat -safe 0 -i \"{concatListPath}\" ");
            concatArgs.Append("-c copy ");
            concatArgs.Append($"\"{tempConcatenatedPath}\"");
            
            await ExecuteFfmpegWithProgress(
                ffmpegPath,
                concatArgs.ToString(),
                progressWindow,
                tempConcatenatedPath,
                cancellationToken,
                0
            );
            
            // Get background music clips (non-TTS audio)
            var (_, bgFxClips) = ClassifyAudioClipsForExport();
            var bgAudioClips = bgFxClips.Where(b => !string.IsNullOrEmpty(b.FilePath) && File.Exists(b.FilePath)).ToList();
            
            progressWindow.UpdateProgress(90, "Đang thêm nhạc nền...");
            
            if (bgAudioClips.Any())
            {
                // Build segment maps for time mapping
                var segmentMaps = segments.Select(s => new SmartCutSegmentMap
                {
                    SourceStart = s.SourceStart,
                    SourceEnd = s.SourceEnd,
                    FinalStart = s.OutputTimelineOffset,
                    FinalEnd = s.OutputTimelineOffset + s.ActualOutputDuration,
                    Scale = s.Duration.TotalSeconds > 0
                        ? s.ActualOutputDuration.TotalSeconds / s.Duration.TotalSeconds
                        : 1.0
                }).ToList();
                
                var mixArgs = new StringBuilder();
                mixArgs.Append($"-y -hide_banner -i \"{tempConcatenatedPath}\" ");
                
                var bgInputMap = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase)
                {
                    [tempConcatenatedPath] = 0
                };
                int inputIndex = 1;
                
                foreach (var bg in bgAudioClips)
                {
                    if (bgInputMap.ContainsKey(bg.FilePath)) continue;
                    mixArgs.Append($"-i \"{bg.FilePath}\" ");
                    bgInputMap[bg.FilePath] = inputIndex++;
                }
                
                var filterComplex = new StringBuilder();
                var audioInputs = new List<string> { "[0:a]" };
                
                int bgIndex = 0;
                foreach (var bg in bgAudioClips)
                {
                    if (!bgInputMap.TryGetValue(bg.FilePath, out int bgInputIndex) || bgInputIndex == 0)
                        continue;
                    
                    string processedLabel = $"bg_{bgIndex}";
                    double bgVolume = DbToGain(bg.VolumeDb);
                    
                    // Map source time to output time for proper positioning
                    double mappedStartSec = MapSourceTimeToOutputTimelineSeconds_Fixed(
                        bg.StartTime.TotalSeconds,
                        segmentMaps);
                    
                    long delay = (long)(mappedStartSec * 1000);
                    
                    filterComplex.Append($"[{bgInputIndex}:a]volume={bgVolume.ToString(CultureInfo.InvariantCulture)},adelay={delay}|{delay},aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[{processedLabel}];");
                    audioInputs.Add($"[{processedLabel}]");
                    bgIndex++;
                }
                
                filterComplex.Append($"{string.Join("", audioInputs)}amix=inputs={audioInputs.Count}:duration=first:normalize=0,alimiter=limit=0.95[final_audio]");
                
                mixArgs.Append($"-filter_complex \"{filterComplex}\" ");
                mixArgs.Append("-map \"[0:v]\" -map \"[final_audio]\" ");
                mixArgs.Append("-c:v copy ");
                mixArgs.Append($"-c:a aac -b:a {settings.AudioBitrate} -ar 44100 ");
                if (settings.ForceStereo) mixArgs.Append("-ac 2 ");
                mixArgs.Append("-movflags +faststart ");
                mixArgs.Append($"\"{settings.OutputPath}\"");
                
                await ExecuteFfmpegWithProgress(
                    ffmpegPath,
                    mixArgs.ToString(),
                    progressWindow,
                    settings.OutputPath,
                    cancellationToken,
                    0
                );
            }
            else
            {
                // No background music, just copy the concatenated file
                File.Copy(tempConcatenatedPath, settings.OutputPath, true);
            }
            
            progressWindow.UpdateProgress(100, "Hoàn tất!");
            progressWindow.MarkAsComplete(true);
        }

        #endregion

        private async Task ExecuteParallelSmartCutExportAsync(
    string ffmpegPath,
    VideoExportSettings settings,
    GenerateVideoWindow progressWindow,
    CancellationToken cancellationToken)
        {
            progressWindow.UpdateProgress(1, "Đang thu thập dữ liệu");
            var mainVideoClip = TimelineClips.FirstOrDefault(c => c.ClipType == TimelineClipType.Video);
            if (mainVideoClip == null || mainVideoClip.SourceData is not MediaAsset mainVideoAsset)
                throw new Exception("Không tìm thấy video chính.");
            var imageClips = TimelineClips.Where(c => c.ClipType == TimelineClipType.Image && c.SourceData is MediaAsset).ToList();
            progressWindow.UpdateProgress(3, "Đang phân tích timeline...");
            var mapItems = await BuildSmartCutMapItemsAsync();
            if (mapItems == null || mapItems.Count == 0) throw new Exception("Không có dữ liệu Smart Cut.");
            progressWindow.UpdateProgress(5, "Đang tạo danh sách segments...");
            var segments = await BuildSegmentListForParallelProcessing(mainVideoAsset, mapItems, cancellationToken);
            if (segments.Count == 0) throw new Exception("Không có segment nào để xử lý.");
            progressWindow.UpdateProgress(6, "Chuẩn bị dữ liệu Subtitle và Overlay...");
            string tempAssDir = TempFileManager.CreateTempDirectory();
            foreach (var segment in segments)
            {
                segment.BlurMode = _currentProject.BlurMode;
                segment.BlurRect = _currentProject.BlurRectNormalized;
                segment.BlurRadius = _currentProject.BlurPreviewRadius;
                if (segment.BlurMode != ProjectState.BlurApplyMode.None && segment.BlurRect == null)
                {
                    segment.BlurRect = new System.Windows.Rect(0, 0, 1, 1);
                }
                if (segment.SubtitleLine != null)
                {
                    string assContent = GenerateAssForSingleSegment(
                        settings.ResolutionWidth,
                        settings.ResolutionHeight,
                        segment.SubtitleLine,
                        segment.TargetDurationExact
                    );

                    string segmentAssPath = Path.Combine(tempAssDir, $"seg_{segment.SegmentIndex}.ass");
                    await File.WriteAllTextAsync(segmentAssPath, assContent, Encoding.UTF8, cancellationToken);
                    segment.TempAssPath = segmentAssPath;
                }
                foreach (var imgClip in imageClips)
                {
                    if (imgClip.SourceData is not MediaAsset imgAsset) continue;
                    double imgStartSource = imgClip.RenderStartTime.TotalSeconds;
                    double imgEndSource = imgStartSource + imgClip.RenderDuration.TotalSeconds;
                    double imgStartOutput = MapSourceTimeToOutputTimelineSeconds(imgStartSource, segments);
                    double imgEndOutput = MapSourceTimeToOutputTimelineSeconds(imgEndSource, segments);
                    double segStart = segment.OutputStart.TotalSeconds;
                    double segEnd = segment.OutputEnd.TotalSeconds;
                    double overlapStart = Math.Max(segStart, imgStartOutput);
                    double overlapEnd = Math.Min(segEnd, imgEndOutput);

                    if (overlapEnd > overlapStart + 0.01) 
                    {
                        double relStart = overlapStart - segStart;
                        double relEnd = overlapEnd - segStart;

                        segment.Overlays.Add(new SegmentOverlayInfo
                        {
                            FilePath = imgAsset.FilePath,
                            RelativeStartSeconds = relStart,
                            RelativeEndSeconds = relEnd,
                            X = imgAsset.PositionX,
                            Y = imgAsset.PositionY,
                            ScaleX = imgAsset.ScaleX,
                            ScaleY = imgAsset.ScaleY,
                            Rotation = imgAsset.Rotation,
                            Width = imgAsset.Width,
                            Height = imgAsset.Height
                        });
                    }
                }
            }
            progressWindow.UpdateProgress(8, $"Đã chuẩn bị {segments.Count} segments. Bắt đầu xử lý song song...");
            int maxParallelProcesses = settings.MaxParallelProcesses;
            if (maxParallelProcesses <= 0)
            {
                if (settings.GpuAcceleration != "none")
                {
                    maxParallelProcesses = Math.Min(4, Math.Max(2, Environment.ProcessorCount / 4));
                }
                else
                {
                    maxParallelProcesses = Math.Min(2, Math.Max(1, Environment.ProcessorCount / 8));
                }
            }

            await ProcessSegmentsInParallelAsync(
                segments,
                mainVideoAsset,
                ffmpegPath,
                settings,
                progressWindow,
                maxParallelProcesses,
                cancellationToken);
            progressWindow.UpdateProgress(90, "Đang ghép nối video...");
            await ConcatSegmentsToFinalOutputAsync(
                segments,
                ffmpegPath,
                settings,
                null, 
                settings.OutputPath,
                progressWindow,
                cancellationToken);
            try { Directory.Delete(tempAssDir, true); } catch { }

            progressWindow.UpdateProgress(100, "Hoàn tất!");
            progressWindow.MarkAsComplete(true);
        }
        private void FontFamilyComboBox_DropDownClosed(object sender, EventArgs e)
        {
            ExitAuxUi();
            if (_originalFontFamilyBeforePreview != null && _selectedSubtitle != null)
            {
                if (_activeVisuals.TryGetValue(_selectedSubtitle, out var currentVisual))
                {
                    ApplyStyleToVisual(currentVisual, _selectedSubtitle.Style);
                }
                else
                {
                }
            }

            _originalFontFamilyBeforePreview = null;
        }
        private void TtsProgressSlider_DragStarted(object sender, System.Windows.Controls.Primitives.DragStartedEventArgs e)
        {
            _isTtsSliderDragging = true;
        }

        private void TtsProgressSlider_DragCompleted(object sender, System.Windows.Controls.Primitives.DragCompletedEventArgs e)
        {
            _isTtsSliderDragging = false;
            _ttsAudioPlayer.Position = TimeSpan.FromSeconds(TtsProgressSlider.Value);
        }
        private void InitializeEditorEvents()
        {
            FontFamilyComboBox.SelectionChanged += EditorControl_ValueChanged;
            FontSizeSlider.ValueChanged += EditorControl_ValueChanged;
            FontSizeTextBox.TextChanged += EditorControl_ValueChanged_TextBox;
            FontColorPicker.SelectedColorChanged += EditorControl_ValueChanged;
            OpacitySlider.ValueChanged += EditorControl_ValueChanged;
            OpacityTextBox.TextChanged += EditorControl_ValueChanged_TextBox;
            BoldButton.Click += EditorControl_ValueChanged;
            ItalicButton.Click += EditorControl_ValueChanged;
            UnderlineButton.Click += EditorControl_ValueChanged;
            CharacterSpacingSlider.ValueChanged += EditorControl_ValueChanged;

            BackgroundEnabledCheckBox.Checked += EditorControl_ValueChanged;
            BackgroundEnabledCheckBox.Unchecked += EditorControl_ValueChanged;
            BackgroundColorPicker.SelectedColorChanged += EditorControl_ValueChanged;
            BackgroundOpacitySlider.ValueChanged += EditorControl_ValueChanged;
            BackgroundCornerRadiusSlider.ValueChanged += EditorControl_ValueChanged;
            BackgroundPaddingXSlider.ValueChanged += EditorControl_ValueChanged;
            BackgroundPaddingYSlider.ValueChanged += EditorControl_ValueChanged;

            OutlineEnabledCheckBox.Checked += EditorControl_ValueChanged;
            OutlineEnabledCheckBox.Unchecked += EditorControl_ValueChanged;
            OutlineColorPicker.SelectedColorChanged += EditorControl_ValueChanged;
            OutlineThicknessSlider.ValueChanged += EditorControl_ValueChanged;

            ShadowEnabledCheckBox.Checked += EditorControl_ValueChanged;
            ShadowEnabledCheckBox.Unchecked += EditorControl_ValueChanged;
            ShadowColorPicker.SelectedColorChanged += EditorControl_ValueChanged;
            ShadowOpacitySlider.ValueChanged += EditorControl_ValueChanged;
            ShadowBlurSlider.ValueChanged += EditorControl_ValueChanged;
            ShadowDepthSlider.ValueChanged += EditorControl_ValueChanged;
            ShadowDirectionSlider.ValueChanged += EditorControl_ValueChanged;
        }

        private void EditorControl_ValueChanged_TextBox(object sender, TextChangedEventArgs e)
        {
            EditorControl_ValueChanged(sender, e);
        }
        private void EditorControl_ValueChanged(object sender, RoutedEventArgs e)
        {
            if (_isUpdatingUiFromCode) return;

            var selectedClips = TimelineClips.Where(c => c.IsSelected).ToList();
            var selectedSrtLines = selectedClips
                .Select(c => c.SourceData as SrtSubtitleLine)
                .Where(s => s != null)
                .ToList();

            if (!selectedSrtLines.Any())
            {
                UpdateProjectTemplateFromUi();
                var finalTemplate = _currentProject.GetTemplateAsStyleState();
                ApplyTemplateToAllSubtitlesAndUpdate(finalTemplate, null);
            }
            else
            {
                var textClips = selectedSrtLines.Where(s => s.IsTextClip).ToList();
                var subtitleClips = selectedSrtLines.Where(s => !s.IsTextClip).ToList();
                foreach (var line in textClips)
                {
                    var style = (line.Style ?? _currentProject.GetTemplateAsStyleState()).Clone();
                    UpdateStyleFromUi(style);
                    line.Style = style;
                    if (_activeVisuals.TryGetValue(line, out var v))
                    {
                        ApplyStyleToVisual(v, style);
                        if (_selectedSubtitle == line)
                        {
                            RemoveSubtitleAdorner();
                            AddSubtitleAdorner(v, style);
                        }
                    }
                }
                if (subtitleClips.Any())
                {
                    UpdateProjectTemplateFromUi();
                    var finalTemplate = _currentProject.GetTemplateAsStyleState();
                    var mainSubtitleToUpdate = subtitleClips.FirstOrDefault(s => s == _selectedSubtitle) ?? subtitleClips.First();
                    ApplyTemplateToAllSubtitlesAndUpdate(finalTemplate, mainSubtitleToUpdate);
                }
            }
            _undoRedoService.AddState(CaptureEditorSnapshot());
            SaveProjectCurrent();
            UpdateChildPanelVisibility();
        }
        private void UpdateProjectTemplateFromUi()
        {
            _isUpdatingUiFromCode = true;
            try
            {
                var fonts = FontFamilyComboBox.ItemsSource as IEnumerable<FontFamily>;
                _currentProject.TemplateFontFamily = (fonts?.FirstOrDefault(f => f == (FontFamily)FontFamilyComboBox.SelectedItem)?.Source) ?? _currentProject.TemplateFontFamily;
                double integerFontSize = Math.Round(FontSizeSlider.Value);
                _currentProject.TemplateFontSize = integerFontSize;
                FontSizeSlider.Value = integerFontSize;
                _currentProject.TemplateFontColor = (FontColorPicker.SelectedColor?.ToString()) ?? _currentProject.TemplateFontColor;
                _currentProject.TemplateOpacity = OpacitySlider.Value / 100.0;
                _currentProject.TemplateFontWeight = (BoldButton.IsChecked == true) ? 700 : 400;
                _currentProject.TemplateIsItalic = (ItalicButton.IsChecked == true);
                _currentProject.TemplateIsUnderlined = (UnderlineButton.IsChecked == true);
                _currentProject.TemplateCharacterSpacing = CharacterSpacingSlider.Value;
                if (AlignLeftButton.IsChecked == true) _currentProject.TemplateAlignment = 1;
                else if (AlignCenterButton.IsChecked == true) _currentProject.TemplateAlignment = 2;
                else if (AlignRightButton.IsChecked == true) _currentProject.TemplateAlignment = 3;
                else if (AlignJustifyButton.IsChecked == true) _currentProject.TemplateAlignment = 4;
                _currentProject.IsBackgroundEnabled = BackgroundEnabledCheckBox.IsChecked == true;
                var bgColor = BackgroundColorPicker.SelectedColor ?? Colors.Black;
                var bgOpacity = BackgroundOpacitySlider.Value / 100.0;
                _currentProject.TemplateBackgroundColor = Color.FromArgb((byte)(bgOpacity * 255), bgColor.R, bgColor.G, bgColor.B).ToString();
                _currentProject.TemplateBackgroundOpacity = bgOpacity;
                _currentProject.TemplateBackgroundCornerRadius = BackgroundCornerRadiusSlider.Value;
                _currentProject.TemplateBackgroundPaddingX = BackgroundPaddingXSlider.Value;
                _currentProject.TemplateBackgroundPaddingY = BackgroundPaddingYSlider.Value;
                _currentProject.IsOutlineEnabled = OutlineEnabledCheckBox.IsChecked == true;
                _currentProject.TemplateOutlineColor = OutlineColorPicker.SelectedColor?.ToString() ?? _currentProject.TemplateOutlineColor;
                _currentProject.TemplateOutlineThickness = OutlineThicknessSlider.Value;
                _currentProject.IsShadowEnabled = ShadowEnabledCheckBox.IsChecked == true;
                var shadowColor = ShadowColorPicker.SelectedColor ?? Colors.Black;
                var shadowOpacity = ShadowOpacitySlider.Value / 100.0;
                _currentProject.TemplateShadowColor = Color.FromArgb((byte)(shadowOpacity * 255), shadowColor.R, shadowColor.G, shadowColor.B).ToString();
                _currentProject.TemplateShadowBlur = ShadowBlurSlider.Value;
                _currentProject.TemplateShadowDepth = ShadowDepthSlider.Value;
                _currentProject.TemplateShadowDirection = ShadowDirectionSlider.Value;
            }
            finally
            {
                _isUpdatingUiFromCode = false;
            }
        }

        private void UpdateStyleFromUi(StyleState styleToUpdate)
        {
            var fonts = FontFamilyComboBox.ItemsSource as IEnumerable<FontFamily>;
            styleToUpdate.FontFamilyName = (fonts?.FirstOrDefault(f => f == (FontFamily)FontFamilyComboBox.SelectedItem)?.Source) ?? styleToUpdate.FontFamilyName;
            double integerFontSize = Math.Round(FontSizeSlider.Value);
            styleToUpdate.FontSize = integerFontSize;
            FontSizeSlider.Value = integerFontSize;
            styleToUpdate.FontColorHex = (FontColorPicker.SelectedColor?.ToString()) ?? styleToUpdate.FontColorHex;
            styleToUpdate.Opacity = OpacitySlider.Value / 100.0;
            styleToUpdate.FontWeightValue = (BoldButton.IsChecked == true) ? 700 : 400;
            styleToUpdate.IsItalic = (ItalicButton.IsChecked == true);
            styleToUpdate.IsUnderlined = (UnderlineButton.IsChecked == true);
            styleToUpdate.CharacterSpacing = CharacterSpacingSlider.Value;
            if (AlignLeftButton.IsChecked == true) styleToUpdate.Alignment = 1;
            else if (AlignCenterButton.IsChecked == true) styleToUpdate.Alignment = 2;
            else if (AlignRightButton.IsChecked == true) styleToUpdate.Alignment = 3;
            else if (AlignJustifyButton.IsChecked == true) styleToUpdate.Alignment = 4;
            else styleToUpdate.Alignment = 0;
            styleToUpdate.IsBackgroundEnabled = BackgroundEnabledCheckBox.IsChecked == true;
            var bgColor = BackgroundColorPicker.SelectedColor ?? Colors.Black;
            var bgOpacity = BackgroundOpacitySlider.Value / 100.0;
            styleToUpdate.BackgroundColorHex = Color.FromArgb((byte)(bgOpacity * 255), bgColor.R, bgColor.G, bgColor.B).ToString();
            styleToUpdate.BackgroundCornerRadius = BackgroundCornerRadiusSlider.Value;
            styleToUpdate.BackgroundPaddingX = BackgroundPaddingXSlider.Value;
            styleToUpdate.BackgroundPaddingY = BackgroundPaddingYSlider.Value;
            if (styleToUpdate.IsBackgroundEnabled)
                styleToUpdate.EdgeStyle = TextEdgeStyle.None;
            else if (OutlineEnabledCheckBox.IsChecked == true)
                styleToUpdate.EdgeStyle = TextEdgeStyle.Outline;
            else if (ShadowEnabledCheckBox.IsChecked == true)
                styleToUpdate.EdgeStyle = TextEdgeStyle.Shadow;
            else
                styleToUpdate.EdgeStyle = TextEdgeStyle.None;
            styleToUpdate.OutlineColorHex = OutlineColorPicker.SelectedColor?.ToString() ?? styleToUpdate.OutlineColorHex;
            styleToUpdate.OutlineThickness = OutlineThicknessSlider.Value;
            var sColor = ShadowColorPicker.SelectedColor ?? Colors.Black;
            var sOp = ShadowOpacitySlider.Value / 100.0;
            styleToUpdate.ShadowColorHex = Color.FromArgb((byte)(sOp * 255), sColor.R, sColor.G, sColor.B).ToString();
            styleToUpdate.ShadowBlur = ShadowBlurSlider.Value;
            styleToUpdate.ShadowDepth = ShadowDepthSlider.Value;
            styleToUpdate.ShadowDirection = ShadowDirectionSlider.Value;
        }
        private void UpdateEditorPanelVisibility()
        {
            var selectedClips = TimelineClips.Where(c => c.IsSelected).ToList();
            bool showSubtitleEditor = false;
            bool showAudioEditor = false;
            bool showVideoEditor = false;
            AudioEditorPanel.DataContext = null;
            VideoEditorPanel.DataContext = null;
            if (selectedClips.Any())
            {
                var firstClipType = selectedClips.First().ClipType;
                bool allSameType = selectedClips.All(c =>
                {
                    if (firstClipType == TimelineClipType.Text || firstClipType == TimelineClipType.Subtitle)
                    {
                        return c.ClipType == TimelineClipType.Text || c.ClipType == TimelineClipType.Subtitle;
                    }
                    if (firstClipType == TimelineClipType.Video || firstClipType == TimelineClipType.Image)
                    {
                        return c.ClipType == TimelineClipType.Video || c.ClipType == TimelineClipType.Image;
                    }
                    return c.ClipType == firstClipType;
                });

                if (allSameType)
                {
                    switch (firstClipType)
                    {
                        case TimelineClipType.Subtitle:
                        case TimelineClipType.Text:
                            showSubtitleEditor = true;
                            break;

                        case TimelineClipType.Audio:
                            showAudioEditor = true;
                            if (selectedClips.First().SourceData is TimelineAudioClip audioClip)
                            {
                                AudioEditorPanel.DataContext = audioClip;
                            }
                            else
                            {
                                showAudioEditor = false;
                            }
                            break;

                        case TimelineClipType.Video:
                        case TimelineClipType.Image:
                            showVideoEditor = true;
                            VideoEditorPanel.DataContext = selectedClips.First();
                            break;
                    }
                }
            }
            EditorPanel.Visibility = showSubtitleEditor ? Visibility.Visible : Visibility.Collapsed;
            AudioEditorPanel.Visibility = showAudioEditor ? Visibility.Visible : Visibility.Collapsed;
            VideoEditorPanel.Visibility = showVideoEditor ? Visibility.Visible : Visibility.Collapsed;
            if (showSubtitleEditor)
            {
                UpdateEditorPanelFromState();
                _isUpdatingUiFromCode = true;
                var converter = (IValueConverter)FindResource("NewlineConverter");
                if (selectedClips.Count == 1 && selectedClips.First().SourceData is SrtSubtitleLine srtLine)
                {
                    bool useTranslated = CurrentProject.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated;
                    string textForEditor = useTranslated ? srtLine.TranslatedText : srtLine.OriginalText;
                    SelectedTextEditorTextBox.Text = converter.Convert(textForEditor, typeof(string), null, CultureInfo.CurrentCulture) as string;
                }
                else
                {
                    SelectedTextEditorTextBox.Text = string.Empty;
                    SelectedTextEditorTextBox.IsEnabled = false;
                }
                _isUpdatingUiFromCode = false;
            }
            else
            {
                SelectedTextEditorTextBox.IsEnabled = true;
            }
        }
        private StyleState GetTemplateAsStyleState()
        {


            var style = new StyleState
            {
                X = _currentProject.TemplateX,
                Y = _currentProject.TemplateY,
                ScaleX = _currentProject.TemplateScaleX,
                ScaleY = _currentProject.TemplateScaleY,
                Rotation = _currentProject.TemplateRotation,
                Width = _currentProject.TemplateWidth,

                FontFamilyName = _currentProject.TemplateFontFamily,
                FontSize = _currentProject.TemplateFontSize,
                FontColorHex = _currentProject.TemplateFontColor,
                FontWeightValue = _currentProject.TemplateFontWeight,
                IsItalic = _currentProject.TemplateIsItalic,
                IsUnderlined = _currentProject.TemplateIsUnderlined,
                CharacterSpacing = _currentProject.TemplateCharacterSpacing,
                IsBackgroundEnabled = _currentProject.IsBackgroundEnabled,
                BackgroundColorHex = _currentProject.TemplateBackgroundColor,
                BackgroundPaddingX = _currentProject.TemplateBackgroundPaddingX,
                BackgroundPaddingY = _currentProject.TemplateBackgroundPaddingY,
                BackgroundCornerRadius = _currentProject.TemplateBackgroundCornerRadius,
                OutlineColorHex = _currentProject.TemplateOutlineColor,
                OutlineThickness = _currentProject.TemplateOutlineThickness,
                ShadowColorHex = _currentProject.TemplateShadowColor,
                ShadowBlur = _currentProject.TemplateShadowBlur,
                ShadowDepth = _currentProject.TemplateShadowDepth,
                ShadowDirection = _currentProject.TemplateShadowDirection,
            };
            if (_currentProject.IsBackgroundEnabled)
            {
                style.EdgeStyle = TextEdgeStyle.None;
            }
            else if (_currentProject.IsOutlineEnabled)
            {
                style.EdgeStyle = TextEdgeStyle.Outline;
            }
            else if (_currentProject.IsShadowEnabled)
            {
                style.EdgeStyle = TextEdgeStyle.Shadow;
            }
            else
            {
                style.EdgeStyle = TextEdgeStyle.None;
            }
            return style;
        }
        private void UpdateEditorPanelFromState()
        {
            if (_currentProject == null) return;
            _isUpdatingUiFromCode = true;
            try
            {
                StyleState styleSource = null;
                if (_selectedSubtitle?.IsTextClip == true)
                {
                    styleSource = _selectedSubtitle.Style ?? _currentProject.GetTemplateAsStyleState();
                }
                else
                {
                    styleSource = _currentProject.GetTemplateAsStyleState();
                }
                var fonts = FontFamilyComboBox.ItemsSource as IEnumerable<FontFamily>;
                FontFamilyComboBox.SelectedItem = fonts?.FirstOrDefault(f => f.Source == styleSource.FontFamilyName) ?? fonts?.FirstOrDefault();
                FontSizeSlider.Value = styleSource.FontSize;
                FontSizeTextBox.Text = styleSource.FontSize.ToString("F0");
                BoldButton.IsChecked = styleSource.FontWeightValue > 500;
                ItalicButton.IsChecked = styleSource.IsItalic;
                UnderlineButton.IsChecked = styleSource.IsUnderlined;
                FontColorPicker.SelectedColor = (Color?)ColorConverter.ConvertFromString(styleSource.FontColorHex);
                OpacitySlider.Value = styleSource.Opacity * 100.0;
                OpacityTextBox.Text = (styleSource.Opacity * 100.0).ToString("F0");
                CharacterSpacingSlider.Value = styleSource.CharacterSpacing;
                AlignLeftButton.IsChecked = styleSource.Alignment == 1;
                AlignCenterButton.IsChecked = styleSource.Alignment == 2;
                AlignRightButton.IsChecked = styleSource.Alignment == 3;
                AlignJustifyButton.IsChecked = styleSource.Alignment == 4;

                BackgroundEnabledCheckBox.IsChecked = styleSource.IsBackgroundEnabled;
                var bgColor = (Color)(ColorConverter.ConvertFromString(styleSource.BackgroundColorHex) ?? ColorConverter.ConvertFromString("#80000000"));
                BackgroundColorPicker.SelectedColor = Color.FromArgb(255, bgColor.R, bgColor.G, bgColor.B);
                BackgroundOpacitySlider.Value = bgColor.A * 100.0 / 255.0;
                BackgroundCornerRadiusSlider.Value = styleSource.BackgroundCornerRadius;
                BackgroundPaddingXSlider.Value = styleSource.BackgroundPaddingX;
                BackgroundPaddingYSlider.Value = styleSource.BackgroundPaddingY;

                OutlineEnabledCheckBox.IsChecked = (!styleSource.IsBackgroundEnabled && styleSource.EdgeStyle == TextEdgeStyle.Outline);
                ShadowEnabledCheckBox.IsChecked = (!styleSource.IsBackgroundEnabled && styleSource.EdgeStyle == TextEdgeStyle.Shadow);

                OutlineColorPicker.SelectedColor = (Color?)ColorConverter.ConvertFromString(styleSource.OutlineColorHex);
                OutlineThicknessSlider.Value = styleSource.OutlineThickness;

                var shadowColor = (Color)(ColorConverter.ConvertFromString(styleSource.ShadowColorHex) ?? Colors.Black);
                ShadowColorPicker.SelectedColor = Color.FromRgb(shadowColor.R, shadowColor.G, shadowColor.B);
                ShadowOpacitySlider.Value = shadowColor.A * 100.0 / 255.0;
                ShadowBlurSlider.Value = styleSource.ShadowBlur;
                ShadowDepthSlider.Value = styleSource.ShadowDepth;
                ShadowDirectionSlider.Value = styleSource.ShadowDirection;
                UpdateChildPanelVisibility();
                switch (styleSource.Alignment)
                {
                    case 1: SelectedTextEditorTextBox.TextAlignment = TextAlignment.Left; break;
                    case 2: SelectedTextEditorTextBox.TextAlignment = TextAlignment.Center; break;
                    case 3: SelectedTextEditorTextBox.TextAlignment = TextAlignment.Right; break;
                    case 4: SelectedTextEditorTextBox.TextAlignment = TextAlignment.Justify; break;
                    default: SelectedTextEditorTextBox.TextAlignment = TextAlignment.Left; break;
                }
            }
            finally
            {
                _isUpdatingUiFromCode = false;
            }
        }
        private void VoiceoverModeComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (VoiceoverModeComboBox.SelectedItem is ComboBoxItem selectedItem &&
                Enum.TryParse<VoiceoverExportMode>(selectedItem.Tag.ToString(), out var selectedMode))
            {
                _selectedVoiceoverMode = selectedMode;
            }
        }
        private void UpdateChildPanelVisibility()
        {
            BackgroundSettingsPanel.Visibility = BackgroundEnabledCheckBox.IsChecked == true ? Visibility.Visible : Visibility.Collapsed;
            OutlineSettingsPanel.Visibility = OutlineEnabledCheckBox.IsChecked == true ? Visibility.Visible : Visibility.Collapsed;
            ShadowSettingsPanel.Visibility = ShadowEnabledCheckBox.IsChecked == true ? Visibility.Visible : Visibility.Collapsed;
        }

        private void ApplyTemplateToAllSubtitlesAndUpdate(StyleState template, SrtSubtitleLine lineToUpdate)
        {

            foreach (var sub in _currentProject.Subtitles.Where(s => !s.IsTextClip))
            {
                var oldWidth = sub.Style?.Width;
                sub.Style = template.Clone();
            }

            if (lineToUpdate != null && _activeVisuals.TryGetValue(lineToUpdate, out var currentVisual))
            {
                ApplyStyleToVisual(currentVisual, lineToUpdate.Style);
                if (_selectedSubtitle == lineToUpdate)
                {
                    RemoveSubtitleAdorner();
                    AddSubtitleAdorner(currentVisual, lineToUpdate.Style);
                }
                CollectAndSendPaddingSample(lineToUpdate, currentVisual);
            }
        }

        private void SelectedTextEditorTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (_isUpdatingUiFromCode)
            {
                return;
            }
            if (_selectedSubtitle == null)
            {
                return;
            }
            if (_imeCompositionActive)
            {
                return;
            }

            try
            {
                var converter = (IValueConverter)FindResource("NewlineConverter");
                string newMultilineText = SelectedTextEditorTextBox.Text;
                string editingText = converter.ConvertBack(newMultilineText, typeof(string), null, CultureInfo.CurrentCulture) as string ?? string.Empty;
                if (CurrentProject?.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated)
                {
                    if (_selectedSubtitle.TranslatedText != editingText)
                    {
                        _selectedSubtitle.TranslatedText = editingText;
                    }
                }
                else
                {
                    if (_selectedSubtitle.OriginalText != editingText)
                    {
                        _selectedSubtitle.OriginalText = editingText;
                    }
                }
                DisplaySubtitleOnPlayer(_selectedSubtitle);

                // Update timeline clip DisplayName based on current display mode
                var clip = TimelineClips.FirstOrDefault(c =>
                    c.SourceData is SrtSubtitleLine srtLine &&
                    srtLine.Index == _selectedSubtitle.Index);

                if (clip != null)
                {
                    // Update DisplayName according to the current subtitle display mode
                    if (_currentProject?.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated
                        && !string.IsNullOrWhiteSpace(_selectedSubtitle.TranslatedText))
                    {
                        clip.DisplayName = _selectedSubtitle.TranslatedText;
                    }
                    else
                    {
                        clip.DisplayName = _selectedSubtitle.OriginalText;
                    }
                    clip.RefreshPropertiesFromSource();
                }

                // Refresh subtitle rendering on timeline
                if (SubtitleRenderCanvas != null)
                {
                    SubtitleRenderCanvas.InvalidateVisual();
                }

                // Update timeline rendering
                UpdateTimelineScaleAndRender();
            }
            finally
            {
                if (_imeCompositionJustCommitted)
                {
                    _imeCompositionJustCommitted = false;
                }
            }
        }
        private void DisableBlurFeature()
        {
            if (_currentProject != null)
            {
                _currentProject.BlurMode = ProjectState.BlurApplyMode.None;
                _currentProject.BlurRectNormalized = null;
                _currentProject.BlurRectX = null;
                _currentProject.BlurRectY = null;
                _currentProject.BlurRectWidth = null;
                _currentProject.BlurRectHeight = null;
            }

            RemoveBlurAdorner();
            if (_blurPreview != null)
            {
                if (SubtitleRenderCanvas.Children.Contains(_blurPreview))
                {
                    SubtitleRenderCanvas.Children.Remove(_blurPreview);
                }
                _blurPreview = null;
            }
        }
        private void ShowAngleDisplay(double angle)
        {
            AngleDisplayText.Text = $"{angle:F2}°";
            AngleDisplay.Visibility = Visibility.Visible;
        }

        private void HideAngleDisplay()
        {
            AngleDisplay.Visibility = Visibility.Collapsed;
        }
        private void ImageAdorner_RotationStarted()
        {
            if (_activeTransformingImageAsset != null)
            {
                ShowAngleDisplay(_activeTransformingImageAsset.Rotation);
            }
        }

        private void ImageAdorner_RotationCompleted()
        {
            HideAngleDisplay();
        }
        private RotateTransform GetOrCreateRotateTransform(FrameworkElement element)
        {
            var transformGroup = element.RenderTransform as TransformGroup;
            if (transformGroup == null)
            {
                transformGroup = new TransformGroup();
                var oldTransform = element.RenderTransform;
                if (oldTransform != null && oldTransform != Transform.Identity)
                {
                    transformGroup.Children.Add(oldTransform);
                }
                element.RenderTransform = transformGroup;
            }

            var rotateTransform = transformGroup.Children.OfType<RotateTransform>().FirstOrDefault();
            if (rotateTransform == null)
            {
                rotateTransform = new RotateTransform();
                transformGroup.Children.Insert(1, rotateTransform);
            }
            return rotateTransform;
        }
        private void SubtitleAdorner_RotationStarted()
        {
            if (_selectedSubtitle?.Style == null || !_activeVisuals.TryGetValue(_selectedSubtitle, out var v))
            {
                return;
            }
            _isAdornerRotating = true;
            _rotatingVisual = v;
            _activeRotateTransform = GetOrCreateRotateTransform(v);
            ShowAngleDisplay(_selectedSubtitle.Style.Rotation);
        }

        private void SubtitleAdorner_RotationCompleted()
        {
            if (!_isAdornerRotating || _selectedSubtitle?.Style == null || _rotatingVisual == null)
            {
                return;
            }
            double finalAngle = _activeRotateTransform.Angle;
            _selectedSubtitle.Style.Rotation = finalAngle;
            _isAdornerRotating = false;
            _rotatingVisual = null;
            _activeRotateTransform = null;
            HideAngleDisplay();
            _undoRedoService.AddState(CaptureEditorSnapshot());
            SaveProjectCurrent();
        }
        private void SrtLinesDataGrid_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            var newlySelected = SrtLinesDataGrid.SelectedItem as SrtSubtitleLine;
            if (SelectedSubtitle != null && _activeVisuals.TryGetValue(SelectedSubtitle, out var oldVisual))
                RemoveSubtitleAdorner();
            SelectedSubtitle = newlySelected;
            _isTextInEditMode = false;
            SelectedAudioClip = null;
            var clipVM = TimelineClips.FirstOrDefault(c => c.SourceData == SelectedSubtitle);
            if (_selectedTimelineClip != clipVM)
            {
                foreach (var c in TimelineClips.Where(c => c.IsSelected)) c.IsSelected = false;
                _selectedTimelineClip = clipVM;
                if (_selectedTimelineClip != null) _selectedTimelineClip.IsSelected = true;
            }

            if (SelectedSubtitle != null)
            {
                if (_activeVisuals.TryGetValue(SelectedSubtitle, out var visual))
                {
                    RemoveVideoAdorner();
                    RemoveImageAdorner();
                    AddSubtitleAdorner(visual, SelectedSubtitle.Style);
                }
                if (_isTimelinePlaying) PauseTimelinePlayback();
            }
            else
            {
                RemoveVideoAdorner();
                RemoveImageAdorner();
                RemoveSubtitleAdorner();
            }
            UpdateEditorPanelVisibility();
        }
        private void RemoveSubtitleAdorner()
        {
            if (_subtitleAdorner != null && _adornerLayer != null)
            {
                _subtitleAdorner.DragDelta -= Adorner_DragDelta;
                _subtitleAdorner.UniformScaleDelta -= Adorner_UniformScaleDelta;
                _subtitleAdorner.Resized -= Adorner_Resized;
                _subtitleAdorner.DragCompleted -= Adorner_DragCompleted;
                _subtitleAdorner.SizeCommitted -= Adorner_SizeCommitted;
                _subtitleAdorner.ResizeStarted -= Adorner_ResizeStarted;
                _adornerLayer.Remove(_subtitleAdorner);
                _subtitleAdorner = null;
                _adornerLayer = null;
            }
        }
        private void Adorner_ResizeStarted(ResizeDirection dir)
        {
            if (_selectedSubtitle == null || !_activeVisuals.TryGetValue(_selectedSubtitle, out var currentVisual)) return;

            var canvas = currentVisual.Parent as Canvas;
            if (canvas == null || canvas.ActualWidth <= 0) return;

            _resizeCanvasWidth = canvas.ActualWidth;
            var style = _selectedSubtitle.Style;

            currentVisual.UpdateLayout();

            double unscaledTotalWidth = currentVisual.RenderSize.Width;
            double scaledTotalWidth = unscaledTotalWidth * Math.Max(0.001, style.ScaleX);

            double centerPx = style.X * _resizeCanvasWidth;
            _edgeLeftPx = centerPx - scaledTotalWidth / 2.0;
            _edgeRightPx = centerPx + scaledTotalWidth / 2.0;

            _isEdgeResizeActive = true;
            _isAdornerDragging = true;
        }
        private TranslateTransform GetOrCreateTranslateTransform(FrameworkElement element)
        {
            var transformGroup = element.RenderTransform as TransformGroup;
            if (transformGroup == null)
            {
                transformGroup = new TransformGroup();
                transformGroup.Children.Add(element.RenderTransform);
                element.RenderTransform = transformGroup;
            }

            var translateTransform = transformGroup.Children.OfType<TranslateTransform>().FirstOrDefault();
            if (translateTransform == null)
            {
                translateTransform = new TranslateTransform();
                transformGroup.Children.Add(translateTransform);
            }
            return translateTransform;
        }
        private void Adorner_DragDelta(double horizontalChange, double verticalChange)
        {
            if (_selectedSubtitle == null || !_activeVisuals.TryGetValue(_selectedSubtitle, out var currentVisual))
            {
                return;
            }

            if (!_isAdornerDragging)
            {
                _isAdornerDragging = true;
                _isPreparingToDragClip = false;
                _currentDragMode = DragMode.None;
            }
            var transform = GetOrCreateTranslateTransform(currentVisual);
            transform.X += horizontalChange;
            transform.Y += verticalChange;
            _subtitleAdorner?.InvalidateArrange();
        }
        private void Adorner_UniformScaleDelta(double scaleDelta)
        {
            if (_selectedSubtitle == null) return;

            _isAdornerDragging = true;
            _isPreparingToDragClip = false;
            _currentDragMode = DragMode.None;

            var style = _selectedSubtitle.Style;
            style.ScaleX = Math.Max(0.1, style.ScaleX + scaleDelta);
            style.ScaleY = Math.Max(0.1, style.ScaleY + scaleDelta);
            if (!_selectedSubtitle.IsTextClip)
            {
                _currentProject.TemplateScaleX = style.ScaleX;
                _currentProject.TemplateScaleY = style.ScaleY;
                foreach (var sub in _currentProject.Subtitles.Where(s => !s.IsTextClip && s != _selectedSubtitle))
                {
                    if (sub.Style == null)
                    {
                        sub.Style = _currentProject.GetTemplateAsStyleState();
                    }
                    sub.Style.ScaleX = style.ScaleX;
                    sub.Style.ScaleY = style.ScaleY;
                }
            }
            if (_activeVisuals.TryGetValue(_selectedSubtitle, out var currentVisual))
            {
                ApplyStyleToVisual(currentVisual, style);
            }
        }
        private void AlignmentButton_Click(object sender, RoutedEventArgs e)
        {
            if (_isUpdatingUiFromCode) return;

            var clickedButton = sender as ToggleButton;
            if (clickedButton == null) return;

            var buttons = new List<ToggleButton> { AlignLeftButton, AlignCenterButton, AlignRightButton, AlignJustifyButton };
            if (clickedButton.IsChecked == false)
            {
                foreach (var button in buttons)
                {
                    if (button != clickedButton)
                    {
                        button.IsChecked = false;
                    }
                }
            }
            else
            {
                foreach (var button in buttons)
                {
                    if (button != clickedButton)
                    {
                        button.IsChecked = false;
                    }
                }
            }
            EditorControl_ValueChanged(sender, e);
        }
        private void Adorner_Resized(object sender, ResizeEventArgs e)
        {
            if (_selectedSubtitle == null || !_activeVisuals.TryGetValue(_selectedSubtitle, out var currentVisual)) return;

            var canvas = currentVisual.Parent as Canvas;
            if (canvas == null || canvas.ActualWidth <= 0) return;

            if (!_isEdgeResizeActive)
            {
                Adorner_ResizeStarted(e.Direction);
            }
            _isAdornerDragging = true;
            _isPreparingToDragClip = false;
            _currentDragMode = DragMode.None;

            const double MIN_ADORNER_W_PX = 20.0;

            if (e.Direction == ResizeDirection.Left)
            {
                _edgeLeftPx += e.HorizontalChange;
            }
            else
            {
                _edgeRightPx += e.HorizontalChange;
            }

            _edgeLeftPx = Math.Max(0, _edgeLeftPx);
            _edgeRightPx = Math.Min(_resizeCanvasWidth, _edgeRightPx);

            if (_edgeRightPx - _edgeLeftPx < MIN_ADORNER_W_PX)
            {
                if (e.Direction == ResizeDirection.Left)
                    _edgeLeftPx = _edgeRightPx - MIN_ADORNER_W_PX;
                else
                    _edgeRightPx = _edgeLeftPx + MIN_ADORNER_W_PX;
            }
            double newScaledTotalWidth = _edgeRightPx - _edgeLeftPx;
            double newCenterPx = _edgeLeftPx + newScaledTotalWidth / 2.0;
            var style = _selectedSubtitle.Style;
            double newTotalLogicalWidth = newScaledTotalWidth / Math.Max(0.001, style.ScaleX);
            double logicalPaddingX = (style.IsBackgroundEnabled) ? style.BackgroundPaddingX : 0;
            const double SUBTITLE_REFERENCE_HEIGHT = 720.0;
            double playerCanvasActualHeight = SubtitleRenderCanvas.ActualHeight > 0 ? SubtitleRenderCanvas.ActualHeight : (videoGrid.ActualHeight > 0 ? videoGrid.ActualHeight : SUBTITLE_REFERENCE_HEIGHT);
            double scaleRatio = playerCanvasActualHeight / SUBTITLE_REFERENCE_HEIGHT;
            double newContentWidth = Math.Max(0, (newTotalLogicalWidth / scaleRatio) - (logicalPaddingX * 2));
            style.X = newCenterPx / _resizeCanvasWidth;
            style.Width = newContentWidth;
            ApplyStyleToVisual(currentVisual, style);
        }
        private void Adorner_SizeCommitted(double committedActualWidthPx)
        {
            try
            {
                if (_selectedSubtitle == null) return;
                var style = _selectedSubtitle.Style ?? _currentProject?.GetTemplateAsStyleState();
                if (style == null) return;
                EnsureInitialTemplateWidthFitsVideo();
                ComputeAndStoreManualAssOverrideForResize(_selectedSubtitle, style, committedActualWidthPx);
                if (!_selectedSubtitle.IsTextClip)
                {
                    var newTemplate = _currentProject.GetTemplateAsStyleState() ?? new StyleState();
                    newTemplate.X = style.X;
                    newTemplate.Y = style.Y;
                    newTemplate.ScaleX = style.ScaleX;
                    newTemplate.ScaleY = style.ScaleY;
                    newTemplate.Rotation = style.Rotation;


                    ApplyTemplateToAllSubtitlesAndUpdate(newTemplate, _selectedSubtitle);
                }

                if (_activeVisuals.TryGetValue(_selectedSubtitle, out var visual) && visual != null)
                {
                    ApplyStyleToVisual(visual, style, preserveTranslate: true, skipPositionUpdate: false);
                }

                _undoRedoService.AddState(CaptureEditorSnapshot());
                SaveProjectCurrent();

            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
            }
        }
        private void DisplaySubtitleOnPlayer(SrtSubtitleLine subtitle)
        {
            if (subtitle == null)
            {
                return;
            }
            if (!ShouldRenderSubtitleOnPlayer(subtitle))
                return;
            if (_activeVisuals.TryGetValue(subtitle, out var existingVisual))
            {
                existingVisual.SizeChanged -= SubtitleVisual_SizeChanged;
                SubtitleRenderCanvas.Children.Remove(existingVisual);
                _activeVisuals.Remove(subtitle);
            }
            var newVisual = new Border { Background = Brushes.Transparent, Padding = new Thickness(0) };
            newVisual.MouseLeftButtonDown += SubtitleVisual_MouseLeftButtonDown;
            newVisual.DataContext = subtitle;

            var backgroundBorder = new Border();
            newVisual.Child = backgroundBorder;

            bool isCurrentlySelected = _selectedSubtitle != null && _selectedSubtitle == subtitle;
            bool isEditing = _isTextInEditMode && isCurrentlySelected;
            double minDimension = (subtitle.Style?.FontSize ?? _currentProject.TemplateFontSize) * 1.2;

            bool useTranslated = CurrentProject.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated && !string.IsNullOrWhiteSpace(subtitle.TranslatedText);
            string textToDisplay = useTranslated ? subtitle.TranslatedText : subtitle.OriginalText;

            if (isEditing)
            {
                var textBox = new TextBox
                {
                    TextWrapping = TextWrapping.Wrap,
                    AcceptsReturn = true,
                    Background = Brushes.Transparent,
                    BorderThickness = new Thickness(0),
                    Foreground = Brushes.White,
                    CaretBrush = Brushes.LawnGreen
                };
                string propertyToBind = "OriginalText";
                if (CurrentProject.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated)
                {
                    propertyToBind = "TranslatedText";
                }

                var binding = new Binding(propertyToBind)
                {
                    Source = subtitle,
                    Mode = BindingMode.TwoWay,
                    UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged,
                    Converter = (IValueConverter)FindResource("NewlineConverter")
                };

                textBox.SetBinding(TextBox.TextProperty, binding);
                backgroundBorder.Child = textBox;
                Dispatcher.BeginInvoke(new Action(() => { textBox.Focus(); textBox.Select(textBox.Text.Length, 0); }), DispatcherPriority.Input);
            }
            else
            {
                // Use OutlinedTextBlock for accurate outline rendering when outline style is enabled
                var effectiveStyle = subtitle.Style ?? _currentProject?.GetTemplateAsStyleState() ?? new StyleState();
                if (effectiveStyle.EdgeStyle == TextEdgeStyle.Outline && !effectiveStyle.IsBackgroundEnabled)
                {
                    var otb = new Subphim.OutlinedTextBlock
                    {
                        HorizontalAlignment = HorizontalAlignment.Center,
                        VerticalAlignment = VerticalAlignment.Center
                    };
                    otb.Text = (textToDisplay ?? string.Empty).Replace(@"\N", Environment.NewLine).Replace("\n", " ");
                    backgroundBorder.Child = otb;
                }
                else
                {
                    var tb = new TextBlock
                    {
                        TextWrapping = TextWrapping.Wrap,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        VerticalAlignment = VerticalAlignment.Center
                    };
                    tb.Text = (textToDisplay ?? string.Empty).Replace(@"\N", Environment.NewLine);
                    backgroundBorder.Child = tb;
                }
            }
            SubtitleRenderCanvas.Children.Add(newVisual);
            Panel.SetZIndex(newVisual, Z_ORDER_SUBTITLE);
            ApplyZOrderForLayers();
            _activeVisuals[subtitle] = newVisual;
            newVisual.SizeChanged += SubtitleVisual_SizeChanged;
            ApplyStyleToVisual(newVisual, subtitle.Style);
            if (isCurrentlySelected)
            {
                AddSubtitleAdorner(newVisual, subtitle.Style);
            }
        }
        private void SubtitleVisual_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            var visual = sender as FrameworkElement;
            if (visual == null) return;

            var subtitle = visual.DataContext as SrtSubtitleLine;

            if (e.NewSize.Width > 0 && e.NewSize.Height > 0 && VisualTreeHelper.GetParent(visual) != null)
            {
                visual.SizeChanged -= SubtitleVisual_SizeChanged;

                if (subtitle != null)
                {
                    UpdateVisualPosition(visual, subtitle.Style);
                }
            }
        }
        private void SubtitleTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            var textBox = sender as TextBox;
            if (textBox != null)
            {
                Dispatcher.BeginInvoke(new Action(() =>
                {
                    if (!textBox.IsKeyboardFocused)
                    {
                        textBox.Focus();
                    }
                }), DispatcherPriority.Input);
            }
        }

        private void UpdateSubtitleForCurrentTime(TimeSpan timelineTime)
        {
            if (!TimelineClips.Any(c => c.IsVideo))
            {
                return;
            }
            List<SrtSubtitleLine> linesToShow;
            if (_currentSmartCutMode == SmartCutMode.StaticReview
                && _smartCutSubtitleTimeline != null
                && _smartCutSubtitleTimeline.Count > 0)
            {
                linesToShow = _smartCutSubtitleTimeline
                    .Where(m => timelineTime >= m.FinalStart && timelineTime < m.FinalEnd)
                    .Select(m => m.Line)
                    .Distinct()
                    .ToList();
            }
            else
            {
                var timelineSubtitleLines = TimelineClips
                    .Where(c => c.ClipType == TimelineClipType.Subtitle || c.ClipType == TimelineClipType.Text)
                    .Select(c => c.SourceData as SrtSubtitleLine)
                    .Where(s => s != null)
                    .Distinct()
                    .ToList();

                linesToShow = timelineSubtitleLines
                    .Where(s => timelineTime >= s.StartTime && timelineTime < s.EndTime)
                    .ToList();
            }

            var visualsToRemove = _activeVisuals.Keys
                .Where(line => !linesToShow.Contains(line))
                .ToList();

            foreach (var line in visualsToRemove)
            {
                var visual = _activeVisuals[line];
                SubtitleRenderCanvas.Children.Remove(visual);
                _activeVisuals.Remove(line);
                if (_selectedSubtitle == line)
                {
                    RemoveSubtitleAdorner();
                }
            }

            foreach (var line in linesToShow)
            {
                if (!_activeVisuals.ContainsKey(line))
                {
                    DisplaySubtitleOnPlayer(line);
                }
            }
        }
        private bool ShouldRenderSubtitleOnPlayer(SrtSubtitleLine subtitle)
        {
            if (subtitle == null)
                return false;
            if (_currentSmartCutMode == SmartCutMode.StaticReview
                && _smartCutSubtitleTimeline != null
                && _smartCutSubtitleTimeline.Any(m => ReferenceEquals(m.Line, subtitle)))
            {
                return true;
            }
            return TimelineClips.Any(c =>
                (c.ClipType == TimelineClipType.Subtitle || c.ClipType == TimelineClipType.Text)
                && ReferenceEquals(c.SourceData, subtitle));
        }

        private void UpdateSubtitleForCurrentTime()
        {
            UpdateSubtitleForCurrentTime(_playhead);
        }
        private void SubtitleVisual_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (_isTimelinePlaying) PauseTimelinePlayback();

            if (sender is FrameworkElement visual && visual.DataContext is SrtSubtitleLine line)
            {
                var clipVM = TimelineClips.FirstOrDefault(c => c.SourceData == line);
                if (clipVM != null)
                {
                    SwitchToClip(clipVM);
                }
            }
            e.Handled = true;
        }
        private System.Windows.Rect GetActualVideoContentRect()
        {
            if (videoGrid == null || VideoContainerBorder == null || !videoGrid.IsMeasureValid || videoGrid.ActualWidth <= 0 || videoGrid.ActualHeight <= 0)
            {
                return new System.Windows.Rect(0, 0, overlayCanvas.ActualWidth, overlayCanvas.ActualHeight);
            }
            try
            {
                GeneralTransform transform = videoGrid.TransformToAncestor(VideoContainerBorder);
                if (transform == null)
                {
                    return new System.Windows.Rect(0, 0, overlayCanvas.ActualWidth, overlayCanvas.ActualHeight);
                }
                return transform.TransformBounds(new System.Windows.Rect(0, 0, videoGrid.ActualWidth, videoGrid.ActualHeight));
            }
            catch (Exception ex)
            {
                return new System.Windows.Rect(0, 0, overlayCanvas.ActualWidth, overlayCanvas.ActualHeight);
            }
        }
        private void UpdateCropThumbsLayout()
        {
            try
            {
                System.Windows.Rect videoRect = GetActualVideoContentRect();
                if (overlayCanvas.ActualWidth <= 0 || overlayCanvas.ActualHeight <= 0 || videoRect.IsEmpty)
                {
                    topThumb.Visibility = Visibility.Collapsed;
                    bottomThumb.Visibility = Visibility.Collapsed;
                    leftThumb.Visibility = Visibility.Collapsed;
                    rightThumb.Visibility = Visibility.Collapsed;
                    return;
                }
                if (double.IsNaN(_topPercent) || double.IsInfinity(_topPercent)) _topPercent = 0.7;
                if (double.IsNaN(_bottomPercent) || double.IsInfinity(_bottomPercent)) _bottomPercent = 0.9;
                if (double.IsNaN(_leftPercent) || double.IsInfinity(_leftPercent)) _leftPercent = 0.1;
                if (double.IsNaN(_rightPercent) || double.IsInfinity(_rightPercent)) _rightPercent = 0.9;
                topThumb.Visibility = Visibility.Visible;
                bottomThumb.Visibility = Visibility.Visible;
                leftThumb.Visibility = Visibility.Visible;
                rightThumb.Visibility = Visibility.Visible;
                topThumb.Width = videoRect.Width;
                bottomThumb.Width = videoRect.Width;
                leftThumb.Height = videoRect.Height;
                rightThumb.Height = videoRect.Height;
                double topThumbHeight = topThumb.ActualHeight > 0 ? topThumb.ActualHeight : topThumb.Height;
                double bottomThumbHeight = bottomThumb.ActualHeight > 0 ? bottomThumb.ActualHeight : bottomThumb.Height;
                double leftThumbWidth = leftThumb.ActualWidth > 0 ? leftThumb.ActualWidth : leftThumb.Width;
                double rightThumbWidth = rightThumb.ActualWidth > 0 ? rightThumb.ActualWidth : rightThumb.Width;
                if (topThumbHeight <= 0 || double.IsNaN(topThumbHeight)) topThumbHeight = 8;
                if (bottomThumbHeight <= 0 || double.IsNaN(bottomThumbHeight)) bottomThumbHeight = 8;
                if (leftThumbWidth <= 0 || double.IsNaN(leftThumbWidth)) leftThumbWidth = 8;
                if (rightThumbWidth <= 0 || double.IsNaN(rightThumbWidth)) rightThumbWidth = 8;

                Canvas.SetLeft(topThumb, videoRect.X);
                Canvas.SetTop(topThumb, videoRect.Y + (videoRect.Height * _topPercent) - (topThumbHeight / 2));
                Canvas.SetLeft(bottomThumb, videoRect.X);
                Canvas.SetTop(bottomThumb, videoRect.Y + (videoRect.Height * _bottomPercent) - (bottomThumbHeight / 2));
                Canvas.SetLeft(leftThumb, videoRect.X + (videoRect.Width * _leftPercent) - (leftThumbWidth / 2));
                Canvas.SetTop(leftThumb, videoRect.Y);
                Canvas.SetLeft(rightThumb, videoRect.X + (videoRect.Width * _rightPercent) - (rightThumbWidth / 2));
                Canvas.SetTop(rightThumb, videoRect.Y);
            }
            catch (Exception ex)
            {
                if (topThumb != null) topThumb.Visibility = Visibility.Collapsed;
                if (bottomThumb != null) bottomThumb.Visibility = Visibility.Collapsed;
                if (leftThumb != null) leftThumb.Visibility = Visibility.Collapsed;
                if (rightThumb != null) rightThumb.Visibility = Visibility.Collapsed;
            }
        }
        private void AddSubtitleAdorner(FrameworkElement visual, StyleState style)
        {
            if (IsSnapshotModeActive) return;
            RemoveVideoAdorner();
            RemoveImageAdorner();
            RemoveSubtitleAdorner();
            if (visual == null)
            {
                return;
            }

            _adornerLayer = AdornerLayer.GetAdornerLayer(visual);
            if (_adornerLayer != null)
            {
                _subtitleAdorner = new SubtitleAdorner(visual, this);
                _subtitleAdorner.DragDelta += Adorner_DragDelta;
                _subtitleAdorner.UniformScaleDelta += Adorner_UniformScaleDelta;
                _subtitleAdorner.RotationChanged += Adorner_RotationChanged;
                _subtitleAdorner.Resized += Adorner_Resized;
                _subtitleAdorner.DragCompleted += Adorner_DragCompleted;
                _subtitleAdorner.SizeCommitted += Adorner_SizeCommitted;
                _subtitleAdorner.ResizeStarted += Adorner_ResizeStarted;
                _subtitleAdorner.RotationStarted += SubtitleAdorner_RotationStarted;
                _subtitleAdorner.RotationCompleted += SubtitleAdorner_RotationCompleted;
                _adornerLayer.Add(_subtitleAdorner);
                visual.UpdateLayout();
                double widthPx = visual.ActualWidth;
                double padLR = 0;
                if (visual is Border outer && outer.Child is Border inner)
                {
                    inner.UpdateLayout();
                    padLR = inner.Padding.Left + inner.Padding.Right;
                }
                if (style != null && style.AllowAutoWrap && style.FixedTextBoxWidth <= 1 && widthPx > 1)
                {
                    style.FixedTextBoxWidth = Math.Max(1, widthPx - padLR);
                    SaveProjectCurrent();
                }
            }
            else { }
        }
        private void Adorner_RotationChanged(double newAngle)
        {
            if (_isAdornerRotating && _activeRotateTransform != null)
            {
                _activeRotateTransform.Angle = newAngle;
                ShowAngleDisplay(newAngle);
            }
        }
        private void UpdateVisualPosition(FrameworkElement visual, StyleState style)
        {
            if (visual == null || style == null) return;

            var canvas = visual.Parent as Canvas;
            if (canvas == null || canvas.ActualWidth == 0 || canvas.ActualHeight == 0)
            {
                return;
            }
            visual.UpdateLayout();
            double actualRenderedWidth = visual.RenderSize.Width;
            double actualRenderedHeight = visual.RenderSize.Height;

            if (actualRenderedWidth == 0 && visual.MinWidth > 0)
            {
                actualRenderedWidth = visual.MinWidth;
            }
            if (actualRenderedHeight == 0 && visual.MinHeight > 0)
            {
                actualRenderedHeight = visual.MinHeight;
            }

            if (actualRenderedWidth == 0 || actualRenderedHeight == 0)
            {
            }

            double left = (canvas.ActualWidth * style.X) - (actualRenderedWidth / 2.0);
            double top = (canvas.ActualHeight * style.Y) - (actualRenderedHeight / 2.0);
            Canvas.SetLeft(visual, left);
            Canvas.SetTop(visual, top);
        }
        private void Adorner_DragCompleted()
        {
            if (_isAdornerRotating)
            {
                return;
            }

            if (!_isAdornerDragging)
            {
                return;
            }

            if (_selectedSubtitle == null || !_activeVisuals.TryGetValue(_selectedSubtitle, out var currentVisual))
            {
                _isAdornerDragging = false;
                _isEdgeResizeActive = false;
                return;
            }

            var transform = GetOrCreateTranslateTransform(currentVisual);
            double totalDeltaX = transform.X;
            double totalDeltaY = transform.Y;
            var canvas = currentVisual.Parent as Canvas;

            if (canvas != null && canvas.ActualWidth > 0 && canvas.ActualHeight > 0 && (Math.Abs(totalDeltaX) > 0.01 || Math.Abs(totalDeltaY) > 0.01))
            {
                var style = _selectedSubtitle.Style;
                style.X += totalDeltaX / canvas.ActualWidth;
                style.Y += totalDeltaY / canvas.ActualHeight;

                transform.X = 0;
                transform.Y = 0;
                UpdateVisualPosition(currentVisual, style);
                if (!_selectedSubtitle.IsTextClip)
                {
                    _currentProject.TemplateX = style.X;
                    _currentProject.TemplateY = style.Y;
                    var updatedTemplate = _currentProject.GetTemplateAsStyleState();
                    ApplyTemplateToAllSubtitlesAndUpdate(updatedTemplate, null);
                }
            }

            _isAdornerDragging = false;
            _isEdgeResizeActive = false;
            _undoRedoService.AddState(CaptureEditorSnapshot());
            SaveProjectCurrent();
        }

        private void ApplyTextStylesToControl(FrameworkElement control, StyleState style, double wpfFontSizeCorrectionFactor, double scaledFontSize)
        {
            double correctedFontSize = scaledFontSize * wpfFontSizeCorrectionFactor;

            var fontFamily = new System.Windows.Media.FontFamily(style.FontFamilyName);
            var fontWeight = FontWeight.FromOpenTypeWeight(style.FontWeightValue);
            var fontStyle = style.IsItalic ? FontStyles.Italic : FontStyles.Normal;
            Color fontBaseColor;
            try { fontBaseColor = (Color)ColorConverter.ConvertFromString(style.FontColorHex); }
            catch { fontBaseColor = Colors.White; }
            byte finalFontAlpha = (byte)(fontBaseColor.A * style.Opacity);
            Color finalFontColor = Color.FromArgb(finalFontAlpha, fontBaseColor.R, fontBaseColor.G, fontBaseColor.B);
            Brush foregroundBrush = new SolidColorBrush(finalFontColor);
            foregroundBrush.Freeze();
            var textAlignment = TextAlignment.Left;
            switch (style.Alignment)
            {
                case 1: textAlignment = TextAlignment.Left; break;
                case 2: textAlignment = TextAlignment.Center; break;
                case 3: textAlignment = TextAlignment.Right; break;
                case 4: textAlignment = TextAlignment.Justify; break;
            }
            if (control is TextBlock tb)
            {
                tb.FontFamily = fontFamily;
                tb.FontSize = correctedFontSize;
                tb.FontWeight = fontWeight;
                tb.FontStyle = fontStyle;
                tb.Foreground = foregroundBrush;
                tb.TextDecorations = style.IsUnderlined ? TextDecorations.Underline : null;
                tb.TextAlignment = textAlignment;
            }
            else if (control is TextBox tbox)
            {
                tbox.FontFamily = fontFamily;
                tbox.FontSize = correctedFontSize;
                tbox.FontWeight = fontWeight;
                tbox.FontStyle = fontStyle;
                tbox.Foreground = foregroundBrush;
                tbox.TextAlignment = textAlignment;
            }
            else if (control is Subphim.OutlinedTextBlock otb)
            {
                // Use OutlinedTextBlock for accurate outline rendering
                otb.FontFamily = fontFamily;
                otb.FontSize = correctedFontSize;
                otb.FontWeight = fontWeight;
                otb.FontStyle = fontStyle;
                otb.Fill = foregroundBrush;
                otb.TextDecorations = style.IsUnderlined ? TextDecorations.Underline : null;
                otb.CharacterSpacing = style.CharacterSpacing;

                // Apply outline stroke if enabled
                if (style.EdgeStyle == TextEdgeStyle.Outline)
                {
                    try
                    {
                        Color outlineBaseColor = (Color)ColorConverter.ConvertFromString(style.OutlineColorHex);
                        byte finalOutlineAlpha = (byte)(outlineBaseColor.A * style.Opacity);
                        var outlineColor = Color.FromArgb(finalOutlineAlpha, outlineBaseColor.R, outlineBaseColor.G, outlineBaseColor.B);
                        otb.Stroke = new SolidColorBrush(outlineColor);
                        otb.StrokeThickness = style.OutlineThickness;
                    }
                    catch
                    {
                        otb.Stroke = Brushes.Black;
                        otb.StrokeThickness = style.OutlineThickness;
                    }
                }
                else
                {
                    otb.Stroke = null;
                    otb.StrokeThickness = 0;
                }
                // OutlinedTextBlock doesn't need DropShadowEffect for outline, return early
                control.Effect = null;
                // Handle shadow separately for OutlinedTextBlock
                if (style.EdgeStyle == TextEdgeStyle.Shadow)
                {
                    var shadowEffect = new DropShadowEffect
                    {
                        BlurRadius = style.ShadowBlur,
                        ShadowDepth = style.ShadowDepth,
                        Direction = style.ShadowDirection
                    };
                    try
                    {
                        Color shadowBaseColor = (Color)ColorConverter.ConvertFromString(style.ShadowColorHex);
                        shadowEffect.Opacity = (shadowBaseColor.A / 255.0) * style.Opacity;
                        shadowEffect.Color = Color.FromRgb(shadowBaseColor.R, shadowBaseColor.G, shadowBaseColor.B);
                    }
                    catch { shadowEffect.Color = Colors.Black; }
                    control.Effect = shadowEffect;
                }
                return;
            }

            control.Effect = null;
            switch (style.EdgeStyle)
            {
                case TextEdgeStyle.Outline:
                    var outlineEffect = new DropShadowEffect
                    {
                        ShadowDepth = 0,
                        BlurRadius = style.OutlineThickness,

                        Opacity = 1
                    };
                    try
                    {
                        Color outlineBaseColor = (Color)ColorConverter.ConvertFromString(style.OutlineColorHex);
                        byte finalOutlineAlpha = (byte)(outlineBaseColor.A * style.Opacity);
                        outlineEffect.Color = Color.FromArgb(finalOutlineAlpha, outlineBaseColor.R, outlineBaseColor.G, outlineBaseColor.B);
                    }
                    catch { outlineEffect.Color = Colors.Black; }
                    control.Effect = outlineEffect;
                    break;

                case TextEdgeStyle.Shadow:
                    var shadowEffect = new DropShadowEffect
                    {
                        BlurRadius = style.ShadowBlur,
                        ShadowDepth = style.ShadowDepth,
                        Direction = style.ShadowDirection
                    };
                    try
                    {
                        Color shadowBaseColor = (Color)ColorConverter.ConvertFromString(style.ShadowColorHex);
                        shadowEffect.Opacity = (shadowBaseColor.A / 255.0) * style.Opacity;
                        shadowEffect.Color = Color.FromRgb(shadowBaseColor.R, shadowBaseColor.G, shadowBaseColor.B);
                    }
                    catch { shadowEffect.Color = Colors.Black; }
                    control.Effect = shadowEffect;
                    break;
            }
        }
        private double ComputeEffectiveWrapWidthPx(StyleState style, double pxPerLogicalUnit)
        {
            return ComputeEffectiveWrapWidthPx(style, pxPerLogicalUnit, null);
        }

        private void ApplyStyleToVisual(FrameworkElement visual, StyleState style, bool preserveTranslate = true, bool skipPositionUpdate = false)
        {
            if (visual == null || style == null)
            {
                return;
            }
            if (visual is not Border outer || outer.Child is not Border inner || inner.Child is not FrameworkElement text) return;
            outer.Opacity = style.Opacity;
            const double REF_H = 720.0;
            double playerH = SubtitleRenderCanvas.ActualHeight > 0 ? SubtitleRenderCanvas.ActualHeight
                              : (videoGrid.ActualHeight > 0 ? videoGrid.ActualHeight : REF_H);
            double scaleRatio = playerH / REF_H;
            double finalFontSize = style.FontSize * scaleRatio;
            ApplyTextStylesToControl(text, style, WPF_FONT_SIZE_CORRECTION_FACTOR, finalFontSize);
            double minDim = Math.Max(0, finalFontSize * 1.2);
            if (text is TextBlock tb)
            {
                tb.MinWidth = minDim; tb.MinHeight = minDim;
                tb.VerticalAlignment = VerticalAlignment.Center;
                tb.HorizontalAlignment = HorizontalAlignment.Center;
            }
            else if (text is TextBox tbox)
            {
                tbox.MinWidth = minDim; tbox.MinHeight = minDim;
                tbox.VerticalContentAlignment = VerticalAlignment.Center;
            }
            else if (text is Subphim.OutlinedTextBlock otb)
            {
                otb.MinWidth = minDim; otb.MinHeight = minDim;
                otb.VerticalAlignment = VerticalAlignment.Center;
                otb.HorizontalAlignment = HorizontalAlignment.Center;
            }

            if (style.IsBackgroundEnabled)
            {
                try { inner.Background = (SolidColorBrush)new BrushConverter().ConvertFrom(style.BackgroundColorHex); }
                catch { inner.Background = Brushes.Transparent; }
                inner.CornerRadius = new CornerRadius(style.BackgroundCornerRadius * scaleRatio);
                inner.Padding = new Thickness(
                    style.BackgroundPaddingX * scaleRatio,
                    style.BackgroundPaddingY * scaleRatio,
                    style.BackgroundPaddingX * scaleRatio,
                    style.BackgroundPaddingY * scaleRatio
                );
            }
            else
            {
                inner.Background = Brushes.Transparent;
                inner.Padding = new Thickness(0);
                inner.CornerRadius = new CornerRadius(0);
            }

            inner.HorizontalAlignment = HorizontalAlignment.Center;
            inner.VerticalAlignment = VerticalAlignment.Stretch;

            if (style.Width is double w && w > 0)
            {
                double logicalPadX = style.IsBackgroundEnabled ? style.BackgroundPaddingX : 0;
                double totalLogicalWidth = w + (logicalPadX * 2);
                outer.Width = totalLogicalWidth * scaleRatio;
            }
            else
            {
                double autoWidth = ComputeEffectiveWrapWidthPx(style, scaleRatio);
                if (double.IsPositiveInfinity(autoWidth))
                {
                    outer.Width = double.NaN;
                }
                else
                {
                    double totalAutoWidth = autoWidth;
                    if (style.IsBackgroundEnabled)
                    {
                        totalAutoWidth += (2.0 * style.BackgroundPaddingX * scaleRatio);
                    }
                    outer.Width = totalAutoWidth;
                }
            }
            TransformGroup tg = visual.RenderTransform as TransformGroup ?? new TransformGroup();
            var scale = tg.Children.OfType<ScaleTransform>().FirstOrDefault();
            var rotate = tg.Children.OfType<RotateTransform>().FirstOrDefault();
            var translate = tg.Children.OfType<TranslateTransform>().FirstOrDefault();

            if (scale == null) { scale = new ScaleTransform(); tg.Children.Insert(0, scale); }
            if (rotate == null)
            {
                int idx = Math.Min(1, tg.Children.Count);
                rotate = new RotateTransform();
                tg.Children.Insert(idx, rotate);
            }
            if (preserveTranslate && translate == null)
            {
                tg.Children.Add(new TranslateTransform());
                translate = tg.Children.OfType<TranslateTransform>().FirstOrDefault();
            }
            scale.ScaleX = Math.Max(0.0001, style.ScaleX);
            scale.ScaleY = Math.Max(0.0001, style.ScaleY);
            rotate.Angle = style.Rotation;
            visual.RenderTransform = tg;
            visual.RenderTransformOrigin = new System.Windows.Point(0.5, 0.5);
            text.InvalidateMeasure();
            inner.InvalidateMeasure();
            outer.InvalidateMeasure();
            outer.UpdateLayout();
            _subtitleAdorner?.InvalidateArrange();
            _subtitleAdorner?.InvalidateVisual();

            if (!skipPositionUpdate && visual.IsLoaded && visual.ActualWidth > 0 && visual.ActualHeight > 0)
            {
                UpdateVisualPosition(visual, style);
            }
        }
        private void RecalculateTrackAssignments()
        {
        }
        private void RenderTimeline(double pixelsPerSecond)
        {
            if (pixelsPerSecond <= 0) return;
            _trackLayoutManager.RefreshLayout(TimelineClips);
            var neededWidth = Math.Max(_totalTimelineDuration.TotalSeconds * pixelsPerSecond, TimelineScrollViewer.ViewportWidth);
            if (double.IsNaN(TracksContainerGrid.Width) || Math.Abs(TracksContainerGrid.Width - neededWidth) > 0.5)
            {
                TracksContainerGrid.Width = neededWidth;
            }

            var allTrackBackgrounds = _trackLayoutManager.GetAllTrackBackgrounds();
            TrackBackgroundsControl.ItemsSource = allTrackBackgrounds;
            var newHeight = _trackLayoutManager.GetTotalHeight();
            if (Math.Abs(TracksContainerGrid.Height - newHeight) > 0.5)
            {
                TracksContainerGrid.Height = newHeight;
            }

            foreach (var vm in TimelineClips)
            {
                vm.Y = _trackLayoutManager.GetTrackYPosition(vm.TrackIndex);
                vm.Height = _trackLayoutManager.GetHeightForClipType(vm.ClipType);
            }

            UpdateVisibleClips();
            RenderVisibleClipsOnly();
            DrawRuler(pixelsPerSecond);
            UpdatePositionMarkerVisuals();
        }
        private void RenderVisibleClipsOnly()
        {
            double pps = this._pixelsPerSecond;
            if (pps <= 0) return;

            bool staticSmartCutOn = _currentSmartCutMode == SmartCutMode.StaticReview &&
                                    _smartCutSegmentMaps != null &&
                                    _smartCutSegmentMaps.Count > 0;

            foreach (var vm in VisibleTimelineClips)
            {
                if (vm == null) continue;

                TimeSpan drawStart = vm.StartTime;
                TimeSpan drawDuration = vm.Duration;

                if (staticSmartCutOn)
                {
                    if (vm.ClipType == TimelineClipType.Video) { /* Giữ nguyên */ }
                    else if (vm.SourceData is TimelineAudioClip tts && tts.IsTts)
                    {
                        drawStart = MapSourceTimeToSmartCut(tts.StartTime);
                        drawDuration = tts.EffectiveDuration;
                        vm.SetRenderTimes(drawStart, drawDuration);
                    }
                    else
                    {
                        TimeSpan srcStart = vm.StartTime;
                        TimeSpan srcEnd = vm.EndTime;
                        TimeSpan mappedStart = MapSourceTimeToSmartCut(srcStart);
                        TimeSpan mappedEnd = MapSourceTimeToSmartCut(srcEnd);
                        if (mappedEnd < mappedStart) mappedEnd = mappedStart;
                        drawStart = mappedStart;
                        drawDuration = mappedEnd - mappedStart;
                        vm.SetRenderTimes(drawStart, drawDuration);
                    }
                }
                else
                {
                    vm.SetRenderTimes(TimeSpan.Zero, TimeSpan.Zero);
                }
                vm.X = drawStart.TotalSeconds * pps;
                vm.Width = Math.Max(1.0, drawDuration.TotalSeconds * pps);
            }
        }
        private string _staticReviewCacheJson;

        private class StaticReviewCacheData
        {
            public double SlowedFactor { get; set; }
            public long FinalDurationTicks { get; set; }
            public List<StaticReviewSegmentDto> Segments { get; set; }
        }
        private class StaticReviewSegmentDto
        {
            public long SourceStartTicks { get; set; }
            public long SourceEndTicks { get; set; }
            public long FinalStartTicks { get; set; }
            public long FinalEndTicks { get; set; }
            public double Scale { get; set; }
            public bool IsGap { get; set; }
        }

        private void SaveStaticReviewCacheJson(double slowedFactor, TimeSpan finalDuration)
        {
            try
            {
                if (_smartCutSegmentMaps == null || _smartCutSegmentMaps.Count == 0)
                {
                    _staticReviewCacheJson = null;
                    return;
                }
                var dto = new StaticReviewCacheData
                {
                    SlowedFactor = slowedFactor,
                    FinalDurationTicks = finalDuration.Ticks,
                    Segments = _smartCutSegmentMaps.Select(m => new StaticReviewSegmentDto
                    {
                        SourceStartTicks = m.SourceStart.Ticks,
                        SourceEndTicks = m.SourceEnd.Ticks,
                        FinalStartTicks = m.FinalStart.Ticks,
                        FinalEndTicks = m.FinalEnd.Ticks,
                        Scale = m.Scale,
                        IsGap = m.IsGap
                    }).ToList()
                };
                _staticReviewCacheJson = JsonConvert.SerializeObject(dto);
            }
            catch
            {
                _staticReviewCacheJson = null;
            }
        }

        private bool TryRestoreStaticReviewFromCache(double slowedFactor)
        {
            try
            {
                if (string.IsNullOrEmpty(_staticReviewCacheJson)) return false;
                var dto = JsonConvert.DeserializeObject<StaticReviewCacheData>(_staticReviewCacheJson);
                if (dto == null) return false;
                if (Math.Abs(dto.SlowedFactor - slowedFactor) > 1e-6) return false;
                _smartCutSegmentMaps = dto.Segments.Select(s => new SmartCutSegmentMap
                {
                    SourceStart = new TimeSpan(s.SourceStartTicks),
                    SourceEnd = new TimeSpan(s.SourceEndTicks),
                    FinalStart = new TimeSpan(s.FinalStartTicks),
                    FinalEnd = new TimeSpan(s.FinalEndTicks),
                    Scale = s.Scale,
                    IsGap = s.IsGap
                }).ToList();

                var finalDuration = new TimeSpan(dto.FinalDurationTicks);
                _totalTimelineDuration = finalDuration;
                _actualContentDuration = finalDuration;
                return true;
            }
            catch
            {
                return false;
            }
        }
        private void VisibleTimelineClips_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            if (e.NewItems != null)
            {
                foreach (TimelineClipViewModel vm in e.NewItems)
                    PrepareClipOnEnterViewport(vm);
            }
            if (e.OldItems != null)
            {
                foreach (TimelineClipViewModel vm in e.OldItems)
                    CancelHeavyTasks(vm);
            }
        }

        private void PrepareClipOnEnterViewport(TimelineClipViewModel vm)
        {
            if (vm == null) return;
            if ((vm.ClipType == TimelineClipType.Video || vm.ClipType == TimelineClipType.Image)
                && !_preparedFilmstrip.Contains(vm))
            {
                _preparedFilmstrip.Add(vm);

                if (vm.ClipType == TimelineClipType.Video)
                {
                    _ = GenerateAndDisplayFilmstripAsync(vm, force: true);
                }
                else
                {
                    PopulateImageFilmstrip(vm);
                }
            }
            if ((vm.ClipType == TimelineClipType.Audio || vm.ClipType == TimelineClipType.Video)
                && !_preparedWaveform.Contains(vm))
            {
                _preparedWaveform.Add(vm);
                vm.InvalidateWaveform();
            }
        }
        private void CancelHeavyTasks(TimelineClipViewModel vm)
        {
            if (vm == null) return;

            if (_filmstripTasks.TryRemove(vm, out var cts))
            {
                try { cts.Cancel(); } catch { }
                cts.Dispose();
            }

            _preparedFilmstrip.Remove(vm);
            _filmstripLayout.Remove(vm);
        }
        private void AddImageAdorner(MediaAsset asset)
        {
            if (IsSnapshotModeActive || (SnapshotResultPanel != null && SnapshotResultPanel.Visibility == Visibility.Visible)) return;
            RemoveImageAdorner();
            RemoveVideoAdorner();
            RemoveSubtitleAdorner();
            if (asset == null)
            {
                return;
            }

            var adornerLayer = AdornerLayer.GetAdornerLayer(PlayerAdornerDecorator);
            if (adornerLayer != null)
            {
                _imageAdorner = new ImageAdorner(PlayerAdornerDecorator, videoGrid, this.CurrentProject, this)
                {
                    DataContext = asset
                };
                _activeTransformingImageAsset = asset;

                _imageAdorner.DragDelta += ImageAdorner_DragDelta;
                _imageAdorner.ScaleChanged += ImageAdorner_ScaleChanged;
                _imageAdorner.RotationChanged += ImageAdorner_RotationChanged;
                _imageAdorner.RotationStarted += ImageAdorner_RotationStarted;
                _imageAdorner.RotationCompleted += ImageAdorner_RotationCompleted;
                _imageAdorner.DragCompleted += ImageAdorner_DragCompleted;

                adornerLayer.Add(_imageAdorner);
            }
            else { }
        }
        private void ImageAdorner_RotationChanged(double newAngle)
        {
            if (_activeTransformingImageAsset == null) return;
            _activeTransformingImageAsset.Rotation = newAngle;
            if (_activeImageOverlays != null && _activeImageOverlays.TryGetValue(_activeTransformingImageAsset, out var visual))
            {
                ApplyTransformToImageVisual(visual, _activeTransformingImageAsset);
            }
            _imageAdorner?.InvalidateArrange();
            _imageAdorner?.InvalidateVisual();
            ShowAngleDisplay(newAngle);
        }

        private void ImageAdorner_DragDelta(double horizontalChange, double verticalChange)
        {
            if (_activeTransformingImageAsset == null) return;
            double refW = Math.Max(1, this.CurrentProject.ProjectReferenceVideoWidth);
            double refH = Math.Max(1, this.CurrentProject.ProjectReferenceVideoHeight);
            double canvasW = Math.Max(1, SubtitleRenderCanvas.ActualWidth);
            double canvasH = Math.Max(1, SubtitleRenderCanvas.ActualHeight);
            double scaleToCanvas = Math.Min(canvasW / refW, canvasH / refH);
            double frameW = refW * scaleToCanvas;
            double frameH = refH * scaleToCanvas;
            double sx = Math.Max(_activeTransformingImageAsset.ScaleX, 0.001);
            double sy = Math.Max(_activeTransformingImageAsset.ScaleY, 0.001);
            double dx = horizontalChange / (frameW * sx);
            double dy = verticalChange / (frameH * sy);
            _activeTransformingImageAsset.PositionX += dx;
            _activeTransformingImageAsset.PositionY += dy;

            if (_activeImageOverlays != null
                && _activeImageOverlays.TryGetValue(_activeTransformingImageAsset, out var visual))
            {
                ApplyTransformToImageVisual(visual, _activeTransformingImageAsset);
            }
            _imageAdorner?.InvalidateArrange();
        }

        private void ImageAdorner_ScaleChanged(double newScale)
        {
            if (_activeTransformingImageAsset == null) return;

            _activeTransformingImageAsset.Scale = newScale;
            if (_activeImageOverlays != null && _activeImageOverlays.TryGetValue(_activeTransformingImageAsset, out var visual))
                ApplyTransformToImageVisual(visual, _activeTransformingImageAsset);

            _imageAdorner?.InvalidateArrange();
        }
        private void ImageAdorner_DragCompleted()
        {
        }
        private void RemoveImageAdorner()
        {
            if (_imageAdorner != null)
            {
                try { _imageAdorner.ReleaseMouseCapture(); } catch { }
                _imageAdorner.DragDelta -= ImageAdorner_DragDelta;
                _imageAdorner.ScaleChanged -= ImageAdorner_ScaleChanged;
                _imageAdorner.DragCompleted -= ImageAdorner_DragCompleted;

                var layer = AdornerLayer.GetAdornerLayer(PlayerAdornerDecorator);
                layer?.Remove(_imageAdorner);

                _imageAdorner = null;
                _activeTransformingImageAsset = null;
            }
        }
        private void UpdateUiForProcessing(bool isProcessing)
        {
            bool anyProcessing = isProcessing || _isAutoProcessing || IsSrtTranslating;

            AutomaticButton.IsEnabled = !anyProcessing;
            RunVSFButton.IsEnabled = !anyProcessing;
            StartButton.IsEnabled = !anyProcessing;
            RunWhisperButton.IsEnabled = !anyProcessing;
            TranslateSrtButton.IsEnabled = !anyProcessing;
            if (anyProcessing)
            {
                _isOverlayVisible = true;
                LoadingOverlay.Visibility = Visibility.Visible;
            }
            else
            {
                _isOverlayVisible = false;
                LoadingOverlay.Visibility = Visibility.Collapsed;
            }
        }
        private string _currentLoadingSessionId;
        private async void CancelProcessButton_Click(object sender, RoutedEventArgs e)
        {
            _masterCts?.Cancel();

            var sessionIdToCancel = _currentLoadingSessionId;
            if (!string.IsNullOrEmpty(sessionIdToCancel))
            {
                try
                {
                    await ApiService.CancelTranslationJobAsync(sessionIdToCancel);
                    LogMessage($"[Cancel] Đã hủy job {sessionIdToCancel}");
                }
                catch (Exception ex)
                {
                    LogMessage($"[Cancel] Lỗi: {ex.Message}");
                }
            }

            // ✅ QUAN TRỌNG: Reset TẤT CẢ session IDs
            _currentLoadingSessionId = null;
            _currentAioSessionId = null;

            IsSrtTranslating = false;
            UpdateUiForProcessing(false);
        }
        private void VsfMode_CheckedChanged(object sender, RoutedEventArgs e)
        {
            if (!this.IsLoaded) return;

            if (VsfModeCleanRadio.IsChecked == true)
            {
                _selectedVsfProcessingMode = VsfProcessingMode.CleanAndCreateTxtImages;
            }
            else if (VsfModeSearchOnlyRadio.IsChecked == true)
            {
                _selectedVsfProcessingMode = VsfProcessingMode.SearchSubtitlesOnly;
            }
        }
        private async void Tab_Checked(object sender, RoutedEventArgs e)
        {
            if (!this.IsLoaded) return;

            var newlyCheckedTab = sender as ToggleButton;
            if (newlyCheckedTab == null || newlyCheckedTab.IsChecked == false)
            {
                return;
            }

            var mainTabs = new List<ToggleButton> { MediaTab, SubtitleTab, TranslateTab, TtsTab };
            foreach (var tab in mainTabs)
            {
                if (tab != null && tab != newlyCheckedTab)
                {
                    if (tab.IsChecked == true)
                    {
                        tab.IsChecked = false;
                    }
                }
            }

            if (newlyCheckedTab == SubtitleTab)
            {
                await UpdateFeaturePermissionsAsync();
            }

            if (newlyCheckedTab == TtsTab)
            {
                if (TtsModeLongTextRadio.IsChecked == false && TtsModeVoiceSubRadio.IsChecked == false)
                {
                    TtsModeLongTextRadio.IsChecked = true;
                }

                // Load danh sách voices từ API khi mở tab TTS
                await LoadTtsVoicesFromApiAsync();
            }

            if (newlyCheckedTab != SubtitleTab && IsBatchSubtitleMode)
            {
                IsBatchSubtitleMode = false;
                _clipsForBatchSubtitle = null;
            }
            UpdateAdornerSuppression();
        }


        public async Task UpdateFeaturePermissionsAsync()
        {
            if (!App.User.IsLoggedIn)
            {
                RunVSFButton.IsEnabled = false;
                StartButton.IsEnabled = false;
                AutomaticButton.IsEnabled = false;
                RunWhisperButton.IsEnabled = false;
                return;
            }
            OcrSettingsPanel.IsEnabled = false;
            SpeechToTextSettingsPanel.IsEnabled = false;

            var (hasSubPhimAccess, subPhimMessage) = await ApiService.CheckFeatureAccessAsync("SubPhim");
            ModeOcrRadio.IsEnabled = hasSubPhimAccess;
            if (!hasSubPhimAccess)
            {
            }
            var (hasDichThuatAccess, dichThuatMessage) = await ApiService.CheckFeatureAccessAsync("DichThuat");
            ModeSpeechToTextRadio.IsEnabled = hasDichThuatAccess;
            if (!hasDichThuatAccess)
            {
            }

            OcrSettingsPanel.IsEnabled = true;
            SpeechToTextSettingsPanel.IsEnabled = true;

            ProcessingMode_Changed(null, null);

        }
        #region Video Loading, Player & Crop Thumbs Logic (Ported)

        private async void LoadVideoForCrop_Click(object sender, RoutedEventArgs e)
        {

            CustomMessageBox.Show(
                "Để bắt đầu, vui lòng sử dụng nút 'Nhập' trong tab 'Tệp' để thêm video của bạn vào Media Bin.\n\nSau đó, bạn có thể kéo video vào timeline hoặc chuột phải vào nó và chọn 'Tạo phụ đề'.",
                "Hướng dẫn",
                MessageBoxButton.OK,
                MessageBoxImage.Information
            );

        }
        private void VideoContainerBorder_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            UpdatePlayerLayout();
            UpdateCropThumbsLayout();
            if (SubtitleRenderCanvas != null)
            {
                foreach (var visual in _activeVisuals.Values)
                {
                    if (visual.DataContext is SrtSubtitleLine line)
                    {
                        UpdateVisualPosition(visual, line.Style);
                    }
                }
            }
        }
        private (double w, double h) GetReferenceSurfaceSize()
        {
            var cp = CurrentProject;

            double rw = (cp != null && cp.ProjectReferenceVideoWidth > 0)
                ? cp.ProjectReferenceVideoWidth
                : 1920.0;

            double rh = (cp != null && cp.ProjectReferenceVideoHeight > 0)
                ? cp.ProjectReferenceVideoHeight
                : 1080.0;

            return (rw, rh);
        }
        private void ApplyReferenceSurfaceSize()
        {
            var (w, h) = GetReferenceSurfaceSize();
            videoGrid.Width = w; videoGrid.Height = h;
            overlayCanvas.Width = w; overlayCanvas.Height = h;
        }
        private async Task SetupProjectWithFirstVideoAsync(string videoPath)
        {
            ResetApplicationState(false);
            _playhead = TimeSpan.Zero;
            _currentVideoPath = videoPath;
            VideoEntry.Text = _currentVideoPath;

            try
            {
                IMediaAnalysis mediaInfo = await FFProbe.AnalyseAsync(_currentVideoPath);
                var videoStream = mediaInfo.PrimaryVideoStream;
                if (videoStream == null) throw new InvalidDataException("File không chứa luồng video hợp lệ.");

                _videoNativeWidth = videoStream.Width;
                _videoNativeHeight = videoStream.Height;
                ApplyReferenceSurfaceSize();
                UpdateCropThumbsLayout();
                var asset = new MediaAsset
                {
                    FilePath = videoPath,
                    Type = AssetType.Video,
                    Duration = mediaInfo.Duration,
                    Width = videoStream.Width,
                    Height = videoStream.Height
                };
                VideoImageAssets.Add(asset);
                var clipVM = new TimelineClipViewModel(asset);
                TimelineClips.Add(clipVM);
                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();
                UpdatePlaybackUI(TimeSpan.Zero);
            }
            catch (Exception ex)
            {
                ResetApplicationState(true);
            }
        }
        private void OnMediaFailed(object sender, ExceptionRoutedEventArgs e)
        {
            string errorMessage = e?.ErrorException?.Message ?? "Không rõ nguyên nhân.";
            CustomMessageBox.Show($"Không thể phát video này. Lỗi: {errorMessage}", "Lỗi Media", MessageBoxButton.OK, MessageBoxImage.Error);
            ResetVideoPlayerState();
        }
        private async Task ResetVideoPlayerState()
        {
            await PauseTimelinePlayback();
            _currentVideoPath = null;
            _videoNativeWidth = 0;
            _videoNativeHeight = 0;
            playPauseButton.Content = "\uE768";
            totalDurationTextBlock.Text = "00:00:00.000";
            currentTimeTextBlock.Text = "00:00:00.000";
            UpdatePlayerLayout();
        }
        private async void PlayPauseButton_Click(object sender, RoutedEventArgs e)
        {
            await ExitFramePreviewMode(restorePlayback: false);
            if (_isTimelinePlaying)
            {
                await PauseTimelinePlayback();
            }
            else
            {
                await StartTimelinePlayback();
            }
        }
        private void Thumb_DragDelta(object sender, DragDeltaEventArgs e)
        {
            try
            {
                if (!(sender is Thumb thumb)) return;
                System.Windows.Rect videoRect = GetActualVideoContentRect();
                if (videoRect.IsEmpty || videoRect.Width == 0 || videoRect.Height == 0) return;

                if (thumb.Cursor == Cursors.SizeNS)
                {
                    double currentTop = Canvas.GetTop(thumb);
                    if (double.IsNaN(currentTop))
                    {
                        currentTop = videoRect.Y + (videoRect.Height * (thumb.Name == "topThumb" ? _topPercent : _bottomPercent)) - (thumb.ActualHeight / 2);
                        if (double.IsNaN(currentTop)) return;
                    }
                    if (thumb.ActualHeight <= 0 || double.IsNaN(thumb.ActualHeight)) return;

                    double newTop = Math.Clamp(currentTop + e.VerticalChange, videoRect.Y, videoRect.Bottom - thumb.ActualHeight);
                    if (double.IsNaN(newTop) || double.IsInfinity(newTop)) return;

                    Canvas.SetTop(thumb, newTop);
                    double relativeY = (newTop + thumb.ActualHeight / 2) - videoRect.Y;
                    double percent = Math.Clamp(relativeY / videoRect.Height, 0.0, 1.0);

                    if (!double.IsNaN(percent) && !double.IsInfinity(percent))
                    {
                        if (thumb.Name == "topThumb") _topPercent = percent; else _bottomPercent = percent;
                    }
                }
                else if (thumb.Cursor == Cursors.SizeWE)
                {
                    double currentLeft = Canvas.GetLeft(thumb);
                    if (double.IsNaN(currentLeft))
                    {
                        currentLeft = videoRect.X + (videoRect.Width * (thumb.Name == "leftThumb" ? _leftPercent : _rightPercent)) - (thumb.ActualWidth / 2);
                        if (double.IsNaN(currentLeft)) return;
                    }
                    if (thumb.ActualWidth <= 0 || double.IsNaN(thumb.ActualWidth)) return;

                    double newLeft = Math.Clamp(currentLeft + e.HorizontalChange, videoRect.X, videoRect.Right - thumb.ActualWidth);
                    if (double.IsNaN(newLeft) || double.IsInfinity(newLeft)) return;

                    Canvas.SetLeft(thumb, newLeft);
                    double relativeX = (newLeft + thumb.ActualWidth / 2) - videoRect.X;
                    double percent = Math.Clamp(relativeX / videoRect.Width, 0.0, 1.0);

                    if (!double.IsNaN(percent) && !double.IsInfinity(percent))
                    {
                        if (thumb.Name == "leftThumb") _leftPercent = percent; else _rightPercent = percent;
                    }
                }
                UpdateCropValues();
            }
            catch (Exception ex)
            {
            }
        }

        private void UpdateCropValues()
        {
            try
            {
                if (double.IsNaN(_topPercent) || double.IsInfinity(_topPercent)) _topPercent = 0.7;
                if (double.IsNaN(_bottomPercent) || double.IsInfinity(_bottomPercent)) _bottomPercent = 0.9;
                if (double.IsNaN(_leftPercent) || double.IsInfinity(_leftPercent)) _leftPercent = 0.1;
                if (double.IsNaN(_rightPercent) || double.IsInfinity(_rightPercent)) _rightPercent = 0.9;

                double validTopPercent = Math.Min(_topPercent, _bottomPercent);
                double validBottomPercent = Math.Max(_topPercent, _bottomPercent);
                double validLeftPercent = Math.Min(_leftPercent, _rightPercent);
                double validRightPercent = Math.Max(_leftPercent, _rightPercent);

                double top_video_image_percent_end = 1.0 - validBottomPercent;
                double bottom_video_image_percent_end = 1.0 - validTopPercent;

                _finalCropTop = Math.Min(top_video_image_percent_end, bottom_video_image_percent_end);
                _finalCropBottom = Math.Max(top_video_image_percent_end, bottom_video_image_percent_end);
                _finalCropLeft = validLeftPercent;
                _finalCropRight = validRightPercent;
                if (double.IsNaN(_finalCropTop) || double.IsInfinity(_finalCropTop)) _finalCropTop = 0.1;
                if (double.IsNaN(_finalCropBottom) || double.IsInfinity(_finalCropBottom)) _finalCropBottom = 0.3;
                if (double.IsNaN(_finalCropLeft) || double.IsInfinity(_finalCropLeft)) _finalCropLeft = 0.1;
                if (double.IsNaN(_finalCropRight) || double.IsInfinity(_finalCropRight)) _finalCropRight = 0.9;

                UpdateResultsText();
            }
            catch (Exception ex)
            {
            }
        }
        private void UpdateResultsText()
        {
            if (resultsTextBlock != null)
            {
                string output = $"Thông số OCR\nTop: {_finalCropTop:F6} | Bottom: {_finalCropBottom:F6} | Left: {_finalCropLeft:F6} | Right: {_finalCropRight:F6}";
                resultsTextBlock.Text = output;
            }
        }
        #endregion

        #region AIOSubPhim & Whisper Process Execution (Ported)

        private async void RunVSFButton_Click(object sender, RoutedEventArgs e)
        {
            if (!await CheckGoogleAccountsAndShowGuideAsync()) return;
            var (canProcess, message) = await ApiService.TryStartProcessingAsync();
            if (!canProcess)
            {
                CustomMessageBox.Show(message, "Đã đạt giới hạn", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            if (!await EnsureVsfIsAvailableAsync()) return;

            _masterCts = new CancellationTokenSource();
            UpdateUiForProcessing(true);

            try
            {
                VsfService.VsfParameters vsfParams;
                var selectedVideoClips = TimelineClips.Where(c => c.IsSelected && c.ClipType == TimelineClipType.Video).ToList();

                if (selectedVideoClips.Count == 1)
                {
                    var clipVM = selectedVideoClips.First();
                    var mediaAsset = clipVM.SourceData as MediaAsset;
                    if (mediaAsset != null)
                    {
                        vsfParams = GetVsfParametersFromUi();
                        vsfParams.VideoPath = mediaAsset.FilePath;
                        vsfParams.StartTime = mediaAsset.TrimStartOffset.ToString(@"hh\:mm\:ss\:fff");
                        var effectiveDurationInSource = mediaAsset.Duration - mediaAsset.TrimStartOffset - mediaAsset.TrimEndOffset;
                        vsfParams.EndTime = (mediaAsset.TrimStartOffset + effectiveDurationInSource).ToString(@"hh\:mm\:ss\:fff");
                    }
                    else
                    {
                        vsfParams = GetVsfParametersFromUi();
                    }
                }
                else
                {
                    vsfParams = GetVsfParametersFromUi();
                }

                var (success, resultPath) = await _vsfService.RunVSFProcessAsync(vsfParams, _masterCts.Token);

                if (!success || _masterCts.IsCancellationRequested)
                {
                    if (!_masterCts.IsCancellationRequested) { }
                    return;
                }

                ImagesEntry.Text = resultPath;
                TranslateTab.IsChecked = true;

                Action<int, string> updateProgressAction = (percent, msg) =>
                {
                };

                bool ocrResult = await StartOcrProcessAsync(_masterCts.Token, updateProgressAction);

                if (ocrResult) { }
                else if (!_masterCts.IsCancellationRequested)
                {
                    CustomMessageBox.Show("Có lỗi xảy ra trong quá trình OCR. Vui lòng kiểm tra lại các dòng phụ đề.", "Lỗi OCR", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            catch (OperationCanceledException)
            {
            }
            catch (Exception ex)
            {
            }
            finally
            {
                UpdateUiForProcessing(false);
                _masterCts?.Dispose();
                _masterCts = null;
            }
        }
        private async void RunWhisperButton_Click(object sender, RoutedEventArgs e)
        {
            _masterCts = new CancellationTokenSource();
            try
            {
                await RunWhisperProcess(_masterCts.Token);
            }
            finally
            {
                _masterCts?.Dispose(); _masterCts = null;
            }
        }

        private async Task RunWhisperProcess(CancellationToken token)
        {
            string baseName = Path.GetFileNameWithoutExtension(VideoEntry.Text);
            string outputSrtPath = Path.Combine(GetResolvedSubtitleOutputDirectory(), $"{baseName}.srt");
            bool success = false;
            if (WhisperNetRadio.IsChecked == true)
            {
                var selectedModel = WhisperNetModelComboBox.SelectedItem as WhisperNetModelInfo;
                if (selectedModel == null)
                {
                    CustomMessageBox.Show(
                        "Vui lòng chọn model cho Whisper.NET.\n\nNếu chưa có model nào, hãy bấm nút 'Tải model...' để tải xuống.",
                        "Chưa chọn model",
                        MessageBoxButton.OK, MessageBoxImage.Information);
                    return;
                }
                if (!WhisperNetModelManager.IsModelDownloaded(selectedModel.Name))
                {
                    CustomMessageBox.Show(
                        $"Model '{selectedModel.DisplayName}' chưa được tải xuống.\n\n" +
                        "Vui lòng bấm nút 'Tải model...' để tải model này.",
                        "Model chưa được tải",
                        MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                var parameters = new WhisperNetService.WhisperNetParameters
                {
                    VideoPath = VideoEntry.Text,
                    ModelName = selectedModel.Name,
                    Language = WhisperNetLanguageComboBox.SelectedValue?.ToString() ?? "vi",
                    OutputSrtPath = outputSrtPath,
                    TranslateToEnglish = false
                };

                LogMessage("=== Whisper.NET Mode ===");
                LogMessage($"Model: {selectedModel.DisplayName}");
                LogMessage($"Language: {parameters.Language}");
                LogMessage("Runtime: Auto-detect (Whisper.net will use best available)");
                var progressPopup = new WhisperProgressPopup(_masterCts);
                progressPopup.UpdateModel(selectedModel.DisplayName);
                progressPopup.UpdateStatus("Đang khởi tạo...");
                _whisperNetService.OnProgressUpdate = (hardware, model, status, segmentCount, progressPercentage) =>
                {
                    progressPopup.UpdateHardware(hardware);
                    progressPopup.UpdateStatus(status);
                    progressPopup.UpdateProgress(segmentCount, progressPercentage);
                };

                var originalLogAction = _whisperNetService.LogMessage;
                _whisperNetService.LogMessage = (msg, isError) =>
                {
                    originalLogAction?.Invoke(msg, isError);
                    var cleanMsg = msg;
                    if (msg.Contains("]") && msg.Contains("["))
                    {
                        var lastBracket = msg.LastIndexOf("]");
                        if (lastBracket > 0 && lastBracket < msg.Length - 1)
                        {
                            cleanMsg = msg.Substring(lastBracket + 1).Trim();
                        }
                    }
                    progressPopup.AddLog(cleanMsg);
                };
                progressPopup.Show();

                try
                {
                    success = await _whisperNetService.RunAsync(parameters, token);

                    if (success)
                    {
                        progressPopup.MarkComplete();
                        await Task.Delay(2000); 
                    }
                    else if (!token.IsCancellationRequested)
                    {
                        progressPopup.MarkFailed("Quá trình thất bại");
                        await Task.Delay(3000);
                    }
                }
                finally
                {
                    _whisperNetService.LogMessage = originalLogAction;
                    progressPopup.Close();
                }
            }
            else
            {
                var selectedModelInfo = WhisperModelComboBox.SelectedItem as subphimv1.Services.Whisper.WhisperModelInfo;
                var modelName = selectedModelInfo?.Name?.Replace("* ", "")?.Trim();

                var parameters = new WhisperService.WhisperParameters
                {
                    Engine = WhisperEngineComboBox.SelectedItem.ToString(),
                    VideoPath = VideoEntry.Text,
                    ModelName = modelName,
                    Language = WhisperLanguageComboBox.SelectedValue.ToString(),
                    OutputSrtPath = outputSrtPath,
                    Device = WhisperDeviceComboBox.SelectedItem.ToString(),
                    ComputeType = WhisperComputeTypeComboBox.SelectedItem.ToString()
                };

                if (string.IsNullOrEmpty(parameters.ModelName))
                {
                    CustomMessageBox.Show("Vui lòng chọn model.", "Thông báo",
                        MessageBoxButton.OK, MessageBoxImage.Information);
                    return;
                }

                LogMessage("=== Classic Whisper Mode ===");
                LogMessage($"Engine: {parameters.Engine}");
                LogMessage($"Model: {modelName}");
                LogMessage($"Device: {parameters.Device}");

                success = await _whisperService.RunAsync(parameters, token);
            }
            if (success && !token.IsCancellationRequested)
            {
                LogMessage("✓ Transcription hoàn thành thành công!");
                if (File.Exists(outputSrtPath))
                {
                    try
                    {
                        await LoadSrtFile(outputSrtPath);
                        LogMessage($"✓ Đã load phụ đề vào timeline: {Path.GetFileName(outputSrtPath)}");
                    }
                    catch (Exception ex)
                    {
                        LogMessage($"⚠ Không thể load phụ đề vào timeline: {ex.Message}", true);
                    }
                }
            }
            else if (!token.IsCancellationRequested)
            {
                CustomMessageBox.Show("Quá trình thất bại.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private VsfService.VsfParameters GetVsfParametersFromUi()
        {
            UpdateCropValues();
            string startTime = null, endTime = null;
            if (EnableStartTimeCheckBox.IsChecked == true)
            {
                startTime = GetFormattedTimeArgument(StartTimeH, StartTimeM, StartTimeS, StartTimeMS);
                if (EnableEndTimeCheckBox.IsChecked == true)
                {
                    endTime = GetFormattedTimeArgument(EndTimeH, EndTimeM, EndTimeS, EndTimeMS);
                }
            }
            return new VsfService.VsfParameters
            {
                VsfPath = _pathVSF,
                VideoPath = VideoEntry.Text,
                OutputBaseDirectory = GetResolvedVSFOutputDirectory(),
                OcrImagesFolderName = _ocrTextFolderName,
                CropTop = (float)_finalCropTop,
                CropBottom = (float)_finalCropBottom,
                CropLeft = (float)_finalCropLeft,
                CropRight = (float)_finalCropRight,
                ProcessingMode = _selectedVsfProcessingMode,
                OpenMethod = _selectedVsfOpenMethod,
                UseCuda = _useCuda,
                NumThreadsSearch = _vsfNumThreadsSearch,
                NumThreadsClean = _vsfNumThreadsClean,
                AdditionalArgs = _cmdVsfArgs,
                StartTime = startTime,
                EndTime = endTime
            };
        }

        private async Task<bool> EnsureVsfIsAvailableAsync()
        {
            if (File.Exists(_pathVSF)) return true;
            string downloadUrl = "https://github.com/visecal/qidian_vp_website/releases/download/VSF1.0/Subphim.zip";
            string appRootPath = AppDomain.CurrentDomain.BaseDirectory;
            string tempZipPath = Path.Combine(Path.GetTempPath(), "AIOSubPhim.zip");
            try
            {
                using (var client = new HttpClient())
                {
                    var response = await client.GetAsync(downloadUrl);
                    response.EnsureSuccessStatusCode();
                    using (var fs = new FileStream(tempZipPath, FileMode.Create, FileAccess.Write, FileShare.None))
                    {
                        await response.Content.CopyToAsync(fs);
                    }
                }
                System.IO.Compression.ZipFile.ExtractToDirectory(tempZipPath, appRootPath, true);
            }
            catch (Exception ex)
            {
            }
            finally { if (File.Exists(tempZipPath)) File.Delete(tempZipPath); }
            return File.Exists(_pathVSF);
        }

        #endregion

        #region UI Event Handlers & Helpers (Ported)

        private void ProcessingMode_Changed(object sender, RoutedEventArgs e)
        {
            if (OcrSettingsPanel == null || SpeechToTextSettingsPanel == null || !this.IsLoaded) return;

            bool isOcrMode = ModeOcrRadio.IsChecked == true;

            OcrSettingsPanel.Visibility = isOcrMode ? Visibility.Visible : Visibility.Collapsed;
            SpeechToTextSettingsPanel.Visibility = isOcrMode ? Visibility.Collapsed : Visibility.Visible;

            if (isOcrMode)
            {
                if (_selectedTimelineClip != null)
                {
                    _selectedTimelineClip.IsSelected = false;
                    _selectedTimelineClip = null;
                }
                RemoveVideoAdorner();
                UpdateVideoTransform(null);
                UpdateCropThumbsLayout();
            }

            bool canUseOcr = ModeOcrRadio.IsEnabled && isOcrMode;
            RunVSFButton.IsEnabled = canUseOcr;
            StartButton.IsEnabled = canUseOcr;
            AutomaticButton.IsEnabled = canUseOcr;
            bool canUseStt = ModeSpeechToTextRadio.IsEnabled && !isOcrMode;
            RunWhisperButton.IsEnabled = canUseStt;
            UpdateAdornerSuppression();
        }

        private void TimeCheckBox_Changed(object sender, RoutedEventArgs e) => UpdateTimeInputStates();

        private void UpdateTimeInputStates()
        {
            bool startChecked = EnableStartTimeCheckBox.IsChecked == true;
            bool endChecked = EnableEndTimeCheckBox.IsChecked == true;
            StartTimeH.IsEnabled = startChecked; StartTimeM.IsEnabled = startChecked; StartTimeS.IsEnabled = startChecked; StartTimeMS.IsEnabled = startChecked;
            EnableEndTimeCheckBox.IsEnabled = startChecked;
            EndTimeH.IsEnabled = startChecked && endChecked; EndTimeM.IsEnabled = startChecked && endChecked; EndTimeS.IsEnabled = startChecked && endChecked; EndTimeMS.IsEnabled = startChecked && endChecked;
        }

        private string GetFormattedTimeArgument(TextBox h, TextBox m, TextBox s, TextBox ms) => $"{h.Text}:{m.Text}:{s.Text}:{ms.Text}";

        private void InitializeWhisperControls()
        {
            WhisperEngineComboBox.ItemsSource = WhisperEngineManager.SupportedEngines.Keys;
            WhisperEngineComboBox.SelectedIndex = 0;
            WhisperLanguageComboBox.ItemsSource = new[] { new { Code = "auto", Name = "Auto Detect" }, new { Code = "en", Name = "English" }, new { Code = "vi", Name = "Vietnamese" } };
            WhisperLanguageComboBox.DisplayMemberPath = "Name";
            WhisperLanguageComboBox.SelectedValuePath = "Code";
            WhisperLanguageComboBox.SelectedValue = "vi";
            WhisperDeviceComboBox.ItemsSource = new List<string> { "cpu", "cuda" };
            WhisperDeviceComboBox.SelectedIndex = 0;
            WhisperComputeTypeComboBox.ItemsSource = new List<string> { "default", "auto", "int8", "float16" };
            WhisperComputeTypeComboBox.SelectedIndex = 1;
            var downloadedModels = WhisperNetModelManager.GetDownloadedModels();
            WhisperNetModelComboBox.ItemsSource = downloadedModels;
            WhisperNetModelComboBox.DisplayMemberPath = "DisplayName";
            WhisperNetModelComboBox.SelectedValuePath = "Name";
            if (downloadedModels.Count > 0)
            {
                var baseModel = downloadedModels.FirstOrDefault(m => m.Name == "base");
                if (baseModel != null)
                    WhisperNetModelComboBox.SelectedItem = baseModel;
                else
                    WhisperNetModelComboBox.SelectedIndex = 0;
            }

            WhisperNetLanguageComboBox.ItemsSource = new[] {
                new { Code = "auto", Name = "Auto Detect" },
                new { Code = "en", Name = "English" },
                new { Code = "vi", Name = "Vietnamese" },
                new { Code = "zh", Name = "Chinese" },
                new { Code = "ja", Name = "Japanese" },
                new { Code = "ko", Name = "Korean" },
                new { Code = "es", Name = "Spanish" },
                new { Code = "fr", Name = "French" },
                new { Code = "de", Name = "German" }
            };
            WhisperNetLanguageComboBox.DisplayMemberPath = "Name";
            WhisperNetLanguageComboBox.SelectedValuePath = "Code";
            WhisperNetLanguageComboBox.SelectedValue = "vi";
        }

        private void WhisperEngineComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (!this.IsLoaded || !(WhisperEngineComboBox.SelectedItem is string selectedEngine)) return;
            var provider = WhisperModelManager.GetProvider(selectedEngine);
            provider.CreateModelFolder();
            WhisperModelComboBox.ItemsSource = provider.GetModels();
            WhisperModelComboBox.DisplayMemberPath = "DisplayName";
            if (WhisperModelComboBox.Items.Count > 0) WhisperModelComboBox.SelectedIndex = 0;
        }

        private void DownloadWhisperModelButton_Click(object sender, RoutedEventArgs e)
        {
            if (!(WhisperEngineComboBox.SelectedItem is string selectedEngine)) return;
            var provider = WhisperModelManager.GetProvider(selectedEngine);
            var downloaderWindow = new WhisperModelDownloaderWindow(provider) { Owner = this };
            downloaderWindow.ShowDialog();
            WhisperEngineComboBox_SelectionChanged(null, null);
        }

        private void WhisperImpl_Changed(object sender, RoutedEventArgs e)
        {
            if (!this.IsLoaded) return;

            if (WhisperNetRadio.IsChecked == true)
            {
                WhisperClassicSettings.Visibility = Visibility.Collapsed;
                WhisperNetSettings.Visibility = Visibility.Visible;
            }
            else
            {
                WhisperClassicSettings.Visibility = Visibility.Visible;
                WhisperNetSettings.Visibility = Visibility.Collapsed;
            }
        }

        private void DownloadWhisperNetModelButton_Click(object sender, RoutedEventArgs e)
        {
            var downloaderWindow = new WhisperNetModelDownloader { Owner = this };
            downloaderWindow.ShowDialog();
            var downloadedModels = WhisperNetModelManager.GetDownloadedModels();
            WhisperNetModelComboBox.ItemsSource = downloadedModels;

            if (downloadedModels.Count > 0 && WhisperNetModelComboBox.SelectedIndex < 0)
            {
                var baseModel = downloadedModels.FirstOrDefault(m => m.Name == "base");
                if (baseModel != null)
                    WhisperNetModelComboBox.SelectedItem = baseModel;
                else
                    WhisperNetModelComboBox.SelectedIndex = 0;
            }
        }
        #endregion

        #region Configuration (Load/Save) (Ported)

        private void MainWindow_OnClosing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            try
            {

                var result = CustomMessageBox.Show(
                    "Bạn có muốn đặt tên và lưu lại project hiện tại không?",
                    "Lưu Project",
                    MessageBoxButton.YesNoCancel,
                    MessageBoxImage.Question
                );
                if (result == MessageBoxResult.Cancel)
                {
                    e.Cancel = true;
                    return;
                }
                if (result == MessageBoxResult.Yes)
                {
                    string defaultName = _currentProject.ProjectName.StartsWith("Untitled") ? "" : _currentProject.ProjectName;
                    string newProjectName = InputBox.Show("Nhập tên project:", "Lưu Project", defaultName);

                    if (!string.IsNullOrWhiteSpace(newProjectName))
                    {
                        string oldPath = _currentProjectFilePath;
                        bool isRenamingUntitled = Path.GetFileNameWithoutExtension(oldPath).StartsWith("Untitled Project") || Path.GetFileNameWithoutExtension(oldPath).StartsWith("Project_");

                        _currentProject.ProjectName = newProjectName;
                        UpdateProjectStateBeforeSave();
                        SaveProjectCurrent();
                        if (isRenamingUntitled && File.Exists(oldPath))
                        {
                            try { File.Delete(oldPath); }
                            catch (Exception ex) { }
                        }
                    }
                }

                // Cancel all translation jobs on server when closing
                if (IsSrtTranslating || !string.IsNullOrEmpty(_currentAioSessionId))
                {
                    _masterCts?.Cancel();
                    try
                    {
                        // Wait briefly for the cancel request to be sent before closing
                        Task.Run(async () => await ApiService.CancelAllTranslationJobsAsync()).Wait(TimeSpan.FromSeconds(2));
                    }
                    catch { }
                }

                CleanupPlaybackResources();
                SaveConfiguration();
                TempFileManager.CleanupCurrentSessionFiles();
                GC.Collect();
                GC.WaitForPendingFinalizers();
                GC.Collect();
            }
            catch (Exception ex)
            {
            }
        }
        private void CreateDefaultSettingsFile()
        {
            if (File.Exists(_settingsFilePath)) return;
            var defaultConfig = new Dictionary<string, Dictionary<string, string>>
            {
                ["settings"] = new Dictionary<string, string>
                {
                    { "path_VSF", Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "AIOSubphim.exe") },
                    { "OCR_Text", "TXTImages" }, { "cmd_vsf", "" }, { "VSF_Output_Base_Directory", "" },
                    { "Subtitle_Output_Directory", Environment.GetFolderPath(Environment.SpecialFolder.Desktop) },
                    { "ocr_mode", OcrMode.GeminiApi.ToString() },
                    { "vsf_video_open_method", VsfVideoOpenMethod.Default.ToString() },
                    { "vsf_processing_mode", VsfProcessingMode.CleanAndCreateTxtImages.ToString() },
                    { "vsf_num_threads_search", "-1" }, { "vsf_num_threads_clean", "-1" }, { "use_cuda", "True" },
                }
            };
            IniConfig.Save(_settingsFilePath, defaultConfig);
        }

        private void LoadConfiguration()
        {
            if (!File.Exists(_settingsFilePath)) CreateDefaultSettingsFile();

            var config = IniConfig.Load(_settingsFilePath);
            char[] keySeparators = { ',', ';', '\n', '\r' };
            _googleDriveFolderId = config.GetValue("settings", "folder_id", "");

            _pathVSF = config.GetValue("settings", "path_VSF", "");
            if (string.IsNullOrWhiteSpace(_pathVSF))
            {
                _pathVSF = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "AIOSubphim.exe");
            }
            _ocrTextFolderName = config.GetValue("settings", "OCR_Text", "TXTImages");
            _cmdVsfArgs = config.GetValue("settings", "cmd_vsf", "");
            _customVsfOutputBaseDir = config.GetValue("settings", "VSF_Output_Base_Directory", "");
            _customSubtitleOutputDir = config.GetValue("settings", "Subtitle_Output_Directory", "");
            _lastImagesFolderPath = config.GetValue("settings", "Last_Images_Folder_Path", "");
            _deleteRawTexts = config.GetBooleanValue("settings", "delete_raw_texts", true);
            _deleteTexts = config.GetBooleanValue("settings", "delete_texts", true);
            _compressRawTexts = config.GetBooleanValue("settings", "nen_raw_texts", true);
            _useCuda = config.GetBooleanValue("settings", "use_cuda", false);
            _vsfNumThreadsSearch = config.GetValue("settings", "vsf_num_threads_search", "-1");
            _vsfNumThreadsClean = config.GetValue("settings", "vsf_num_threads_clean", "-1");

            Enum.TryParse(config.GetValue("settings", "vsf_video_open_method"), out _selectedVsfOpenMethod);
            Enum.TryParse(config.GetValue("settings", "vsf_processing_mode"), out _selectedVsfProcessingMode);
            Enum.TryParse(config.GetValue("settings", "ocr_mode"), out _currentOcrMode);
            UpdateOcrModeMenuState();

            _geminiApiKeysOcr = config.GetValue("settings", "gemini_api_keys_ocr", "")
                                    .Split(keySeparators, StringSplitOptions.RemoveEmptyEntries)
                                    .Select(k => k.Trim()).Where(k => !string.IsNullOrWhiteSpace(k)).ToList();
            _selectedGeminiModelOcr = config.GetValue("settings", "gemini_model_ocr", ApiConfig.DefaultGeminiModelOcr);
            _geminiCustomModelsOcr = config.GetValue("settings", "gemini_custom_models_ocr", "").Split(',').Select(m => m.Trim()).Where(m => !string.IsNullOrEmpty(m)).ToList();
            int.TryParse(config.GetValue("settings", "gemini_images_per_request_ocr", "15"), out _geminiImagesPerRequestOcr);
            int.TryParse(config.GetValue("settings", "gemini_requests_per_minute_ocr", "8"), out _geminiRequestsPerMinuteOcr);
            _geminiEnableMultiKeyOcr = config.GetBooleanValue("settings", "gemini_enable_multi_key_ocr", false);

            _chutesApiKeySrt = config.GetValue("settings_srt_translation", "chutes_api_key_srt", "");
            _selectedChutesModelSrt = config.GetValue("settings_srt_translation", "chutes_model_srt", ApiConfig.DefaultChutesModelSrt);
            _chutesCustomModelsSrt = config.GetValue("settings_srt_translation", "chutes_custom_models_srt", "").Split(',').Select(m => m.Trim()).Where(m => !string.IsNullOrEmpty(m)).ToList();

            _geminiApiKeysSrt = config.GetValue("settings_srt_translation", "gemini_api_keys_srt", "")
                                    .Split(keySeparators, StringSplitOptions.RemoveEmptyEntries)
                                    .Select(k => k.Trim()).Where(k => !string.IsNullOrWhiteSpace(k)).ToList();
            _selectedGeminiModelSrt = config.GetValue("settings_srt_translation", "gemini_model_srt", ApiConfig.DefaultGeminiModelSrt);
            _geminiCustomModelsSrt = config.GetValue("settings_srt_translation", "gemini_custom_models_srt", "").Split(',').Select(m => m.Trim()).Where(m => !string.IsNullOrEmpty(m)).ToList();
            _geminiEnableMultiKeySrt = config.GetBooleanValue("settings_srt_translation", "gemini_enable_multi_key_srt", false);
            Enum.TryParse(config.GetValue("settings_srt_translation", "api_provider_srt"), out _currentSrtApiProvider);
            int.TryParse(config.GetValue("settings_srt_translation", "gemini_srt_rpm", "8"), out _geminiSrtTranslationRpm);
            int.TryParse(config.GetValue("settings_srt_translation", "gemini_srt_batch_size", "40"), out _geminiSrtTranslationBatchSize);
            int.TryParse(config.GetValue("settings_srt_translation", "gemini_srt_thinking_budget", "8192"), out _geminiSrtThinkingBudget);
            _selectedChatGPTModelSrt = config.GetValue("settings_srt_translation", "chatgpt_model_srt", "gpt-4o");
            _chatGptCustomModelsSrt = config.GetValue("settings_srt_translation", "chatgpt_custom_models_srt", "").Split(',').Select(m => m.Trim()).Where(m => !string.IsNullOrEmpty(m)).ToList();
            int.TryParse(config.GetValue("settings_srt_translation", "chatgpt_srt_batch_size", "40"), out _chatGptSrtBatchSize);
            _selectedSrtGenreValue = config.GetValue("settings_srt_translation", "last_selected_srt_genre", "H.Huyễn Tiên Hiệp");
            _selectedSrtTargetLanguage = config.GetValue("settings_srt_translation", "last_selected_srt_target_language", "Tiếng Việt");
            string promptsJson = config.GetValue("settings_srt_translation", "custom_prompts", "{}");
            try
            {
                _customPrompts = Newtonsoft.Json.JsonConvert.DeserializeObject<Dictionary<string, string>>(promptsJson) ?? new Dictionary<string, string>();
            }
            catch
            {
                _customPrompts = new Dictionary<string, string>();
            }
            CustomPromptNames.Clear();
            foreach (var name in _customPrompts.Keys.OrderBy(k => k))
            {
                CustomPromptNames.Add(name);
            }
            SrtApiProviderComboBox.SelectedItem = _currentSrtApiProvider;
            SrtGenreComboBox.SelectedItem = _selectedSrtGenreValue;
            SrtTargetLanguageComboBox.SelectedItem = _selectedSrtTargetLanguage;
            UpdateSrtApiProviderControls();
            _lastExportPath = config.GetValue("settings", "Last_Export_Path", "");
            string whisperNetModel = config.GetValue("settings", "whisper_net_last_model", "base");
            string whisperNetLanguage = config.GetValue("settings", "whisper_net_last_language", "auto");
            if (WhisperNetModelComboBox.ItemsSource != null)
            {
                var models = WhisperNetModelComboBox.ItemsSource as List<WhisperNetModelInfo>;
                var savedModel = models?.FirstOrDefault(m => m.Name == whisperNetModel);
                if (savedModel != null)
                {
                    WhisperNetModelComboBox.SelectedItem = savedModel;
                }
            }
            WhisperNetLanguageComboBox.SelectedValue = whisperNetLanguage;
        }
        private void SaveConfiguration()
        {
            var config = IniConfig.Load(_settingsFilePath);
            if (!config.ContainsKey("settings")) config["settings"] = new Dictionary<string, string>();
            if (!config.ContainsKey("settings_srt_translation")) config["settings_srt_translation"] = new Dictionary<string, string>();
            if (!config.ContainsKey("settings_tts")) config["settings_tts"] = new Dictionary<string, string>();
            var settings = config["settings"];
            settings["folder_id"] = _googleDriveFolderId;
            settings["path_VSF"] = _pathVSF;
            settings["OCR_Text"] = _ocrTextFolderName;
            settings["cmd_vsf"] = _cmdVsfArgs;
            settings["VSF_Output_Base_Directory"] = _customVsfOutputBaseDir;
            settings["Subtitle_Output_Directory"] = _customSubtitleOutputDir;
            settings["Last_Images_Folder_Path"] = ImagesEntry.Text;
            settings["delete_raw_texts"] = _deleteRawTexts.ToString();
            settings["delete_texts"] = _deleteTexts.ToString();
            settings["nen_raw_texts"] = _compressRawTexts.ToString();
            settings["use_cuda"] = _useCuda.ToString();
            settings["vsf_num_threads_search"] = _vsfNumThreadsSearch;
            settings["vsf_num_threads_clean"] = _vsfNumThreadsClean;
            settings["vsf_video_open_method"] = _selectedVsfOpenMethod.ToString();
            settings["vsf_processing_mode"] = _selectedVsfProcessingMode.ToString();
            settings["ocr_mode"] = _currentOcrMode.ToString();
            settings["gemini_api_keys_ocr"] = string.Join(Environment.NewLine, _geminiApiKeysOcr);
            settings["gemini_model_ocr"] = _selectedGeminiModelOcr;
            settings["gemini_custom_models_ocr"] = string.Join(",", _geminiCustomModelsOcr);
            settings["gemini_images_per_request_ocr"] = _geminiImagesPerRequestOcr.ToString();
            settings["gemini_requests_per_minute_ocr"] = _geminiRequestsPerMinuteOcr.ToString();
            settings["gemini_enable_multi_key_ocr"] = _geminiEnableMultiKeyOcr.ToString();

            var srtSettings = config["settings_srt_translation"];
            srtSettings["chatgpt_model_srt"] = _selectedChatGPTModelSrt;
            srtSettings["chatgpt_custom_models_srt"] = string.Join(",", _chatGptCustomModelsSrt);
            srtSettings["chatgpt_srt_batch_size"] = _chatGptSrtBatchSize.ToString();
            srtSettings["chutes_api_key_srt"] = _chutesApiKeySrt;
            srtSettings["chutes_model_srt"] = _selectedChutesModelSrt;
            srtSettings["chutes_custom_models_srt"] = string.Join(",", _chutesCustomModelsSrt);

            srtSettings["gemini_api_keys_srt"] = string.Join(Environment.NewLine, _geminiApiKeysSrt);
            srtSettings["gemini_model_srt"] = _selectedGeminiModelSrt;
            srtSettings["gemini_custom_models_srt"] = string.Join(",", _geminiCustomModelsSrt);
            srtSettings["gemini_enable_multi_key_srt"] = _geminiEnableMultiKeySrt.ToString();
            srtSettings["api_provider_srt"] = _currentSrtApiProvider.ToString();
            srtSettings["gemini_srt_rpm"] = _geminiSrtTranslationRpm.ToString();
            srtSettings["gemini_srt_batch_size"] = _geminiSrtTranslationBatchSize.ToString();
            srtSettings["gemini_srt_thinking_budget"] = _geminiSrtThinkingBudget.ToString();
            srtSettings["last_selected_srt_genre"] = _selectedSrtGenreValue;
            srtSettings["last_selected_srt_target_language"] = _selectedSrtTargetLanguage;
            srtSettings["custom_prompts"] = Newtonsoft.Json.JsonConvert.SerializeObject(_customPrompts);
            var ttsSettings = config["settings_tts"];
            settings["Last_Export_Path"] = _lastExportPath;
            var selectedModel = WhisperNetModelComboBox.SelectedItem as WhisperNetModelInfo;
            settings["whisper_net_last_model"] = selectedModel?.Name ?? "base";
            settings["whisper_net_last_language"] = WhisperNetLanguageComboBox.SelectedValue?.ToString() ?? "auto";

            IniConfig.Save(_settingsFilePath, config);
            LogMessage("[CONFIG] Cấu hình đã được lưu.");
        }
        private void SaveCustomPromptButton_Click(object sender, RoutedEventArgs e)
        {
            NewPromptName = "";
            IsSavePromptPopupOpen = true;
            NewPromptNameTextBox.Focus();
        }

        private void PopupSaveButton_Click(object sender, RoutedEventArgs e)
        {
            string name = NewPromptName?.Trim();
            if (string.IsNullOrWhiteSpace(name))
            {
                CustomMessageBox.Show("Tên prompt không được để trống.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            if (string.IsNullOrWhiteSpace(CurrentCustomPromptText))
            {
                CustomMessageBox.Show("Nội dung prompt không được để trống.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            _customPrompts[name] = CurrentCustomPromptText;

            if (!CustomPromptNames.Contains(name))
            {
                CustomPromptNames.Add(name);
                var sorted = CustomPromptNames.OrderBy(n => n).ToList();
                CustomPromptNames.Clear();
                foreach (var sortedName in sorted)
                {
                    CustomPromptNames.Add(sortedName);
                }
            }

            SelectedCustomPromptName = name;
            IsSavePromptPopupOpen = false;
            SaveConfiguration();
        }

        private void PopupCancelButton_Click(object sender, RoutedEventArgs e)
        {
            IsSavePromptPopupOpen = false;
        }
        private string GetResolvedVSFOutputDirectory()
        {
            if (!string.IsNullOrWhiteSpace(_customVsfOutputBaseDir) && Directory.Exists(_customVsfOutputBaseDir))
                return Path.GetFullPath(_customVsfOutputBaseDir);
            return AppDomain.CurrentDomain.BaseDirectory;
        }

        private string GetResolvedSubtitleOutputDirectory()
        {
            if (!string.IsNullOrWhiteSpace(_customSubtitleOutputDir) && Directory.Exists(_customSubtitleOutputDir))
                return Path.GetFullPath(_customSubtitleOutputDir);
            return Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
        }

        #endregion

        #region Menu Logic (Ported)

        private void SettingsApiMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var settingsWin = new Settings(
                _googleDriveFolderId, _pathVSF, _ocrTextFolderName, _cmdVsfArgs, _customVsfOutputBaseDir,
                _customSubtitleOutputDir, _selectedVsfOpenMethod, _selectedVsfProcessingMode, _vsfNumThreadsSearch,
                _vsfNumThreadsClean, _useCuda, _deleteRawTexts, _deleteTexts, _compressRawTexts,
                _geminiApiKeysOcr, _geminiImagesPerRequestOcr, _geminiRequestsPerMinuteOcr, _geminiEnableMultiKeyOcr,
                _selectedGeminiModelOcr, _geminiCustomModelsOcr,
                _chutesApiKeySrt, _geminiApiKeysSrt, _geminiEnableMultiKeySrt, _currentSrtApiProvider,
            _selectedChutesModelSrt, _selectedGeminiModelSrt, _selectedChatGPTModelSrt,
            _chutesCustomModelsSrt, _geminiCustomModelsSrt, _chatGptCustomModelsSrt,
            _geminiSrtTranslationRpm, _geminiSrtTranslationBatchSize, _geminiSrtThinkingBudget,
            _chatGptSrtBatchSize);
            settingsWin.Owner = this;

            if (settingsWin.ShowDialog() == true)
            {
                _googleDriveFolderId = settingsWin.GoogleDriveFolderId;
                _pathVSF = settingsWin.PathVSF;
                _ocrTextFolderName = settingsWin.OcrTextFolderName;
                _cmdVsfArgs = settingsWin.CmdVsfArgs;
                _customVsfOutputBaseDir = settingsWin.CustomVsfOutputBaseDir;
                _customSubtitleOutputDir = settingsWin.CustomSubtitleOutputDir;
                _selectedVsfOpenMethod = settingsWin.SelectedVsfOpenMethod;
                _selectedVsfProcessingMode = settingsWin.SelectedVsfProcessingMode;
                _vsfNumThreadsSearch = settingsWin.VsfNumThreadsSearch;
                _vsfNumThreadsClean = settingsWin.VsfNumThreadsClean;
                _useCuda = settingsWin.UseCuda;
                _deleteRawTexts = settingsWin.DeleteRawTexts;
                _deleteTexts = settingsWin.DeleteTexts;
                _compressRawTexts = settingsWin.CompressRawTexts;
                _geminiApiKeysOcr = settingsWin.GeminiApiKeysOcr;
                _geminiImagesPerRequestOcr = settingsWin.GeminiImagesPerRequestOcr;
                _geminiRequestsPerMinuteOcr = settingsWin.GeminiRequestsPerMinuteOcr;
                _geminiEnableMultiKeyOcr = settingsWin.GeminiEnableMultiKeyOcr;
                _selectedGeminiModelOcr = settingsWin.SelectedGeminiModelOcr;
                _geminiCustomModelsOcr = settingsWin.GeminiCustomModelsOcr;
                _chutesApiKeySrt = settingsWin.ChutesApiKeySrt;
                _geminiApiKeysSrt = settingsWin.GeminiApiKeysSrt;
                _geminiEnableMultiKeySrt = settingsWin.GeminiEnableMultiKeySrt;
                _currentSrtApiProvider = settingsWin.SelectedSrtApiProvider;
                _selectedChutesModelSrt = settingsWin.SelectedChutesModelSrt;
                _selectedGeminiModelSrt = settingsWin.SelectedGeminiModelSrt;
                _selectedChatGPTModelSrt = settingsWin.SelectedChatGPTModelSrt;
                _chutesCustomModelsSrt = settingsWin.ChutesCustomModelsSrt;
                _geminiCustomModelsSrt = settingsWin.GeminiCustomModelsSrt;
                _chatGptCustomModelsSrt = settingsWin.ChatGPTCustomModelsSrt;
                _geminiSrtTranslationRpm = settingsWin.GeminiSrtTranslationRpm;
                _geminiSrtTranslationBatchSize = settingsWin.GeminiSrtTranslationBatchSize;
                _geminiSrtThinkingBudget = settingsWin.GeminiSrtThinkingBudget;
                _chatGptSrtBatchSize = settingsWin.ChatGPTSrtBatchSize;

                SaveConfiguration();
                RebuildServicesFromConfig();
                UpdateSrtApiProviderControls();
                UpdateVsfProcessingModeRadioButtons();
            }
        }
        private void RebuildServicesFromConfig()
        {
            _geminiServiceOcr = new GeminiOcrService(
                _geminiApiKeysOcr, _geminiRequestsPerMinuteOcr, _geminiEnableMultiKeyOcr, _selectedGeminiModelOcr
            )
            { LogMessage = (msg) => LogMessage(msg) };

            _srtTranslationService = new SrtTranslationService(
                new SrtTranslationService.SrtApiConfig
                {
                    ChutesApiKey = _chutesApiKeySrt,
                    ChutesModel = _selectedChutesModelSrt,
                    GeminiApiKeys = _geminiApiKeysSrt,
                    GeminiModel = _selectedGeminiModelSrt,
                    UseGeminiMultiKey = _geminiEnableMultiKeySrt,
                    GeminiRpm = _geminiSrtTranslationRpm,
                    GeminiBatchSize = _geminiSrtTranslationBatchSize,
                    GeminiThinkingBudget = _geminiSrtThinkingBudget,
                    ChatGPTBatchSize = _chatGptSrtBatchSize,
                    ChatGPTModel = _selectedChatGPTModelSrt
                }
            )
            { LogMessage = (msg, isErr) => LogMessage(msg, isErr) };
            LoadGoogleAccounts();
        }
        private void UpdateVsfProcessingModeRadioButtons()
        {
            VsfModeCleanRadio.IsChecked = (_selectedVsfProcessingMode == VsfProcessingMode.CleanAndCreateTxtImages);
            VsfModeSearchOnlyRadio.IsChecked = (_selectedVsfProcessingMode == VsfProcessingMode.SearchSubtitlesOnly);
        }


        private void ShowShortcuts_Click(object sender, RoutedEventArgs e)
        {
            ShortcutsWindow shortcutsWin = new ShortcutsWindow { Owner = this };
            shortcutsWin.ShowDialog();
        }

        private void MenuM3u8Downloader_Click(object sender, RoutedEventArgs e)
        {
            m3u8 m3u8DownloaderWin = new m3u8 { Owner = this };
            m3u8DownloaderWin.Show();
        }

        #endregion

        #region Logging

        private void LogMessage(string message, bool isError = false)
        {
            System.Diagnostics.Debug.WriteLine(message);
        }

        #endregion

        #region Window Title Bar (Ported)
        private void TitleBar_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (e.ClickCount == 2) MaximizeButton_Click(sender, e); else DragMove();
        }

        private void CheckBox_Checked(object sender, RoutedEventArgs e)
        {

        }
        private void MainWindow_StateChanged(object sender, EventArgs e)
        {

        }
        private void MinimizeButton_Click(object sender, RoutedEventArgs e) => WindowState = WindowState.Minimized;
        private void MaximizeButton_Click(object sender, RoutedEventArgs e) => WindowState = WindowState == WindowState.Maximized ? WindowState.Normal : WindowState.Maximized;
        private void CloseButton_Click(object sender, RoutedEventArgs e) => Close();
        #endregion
        #region SRT Translation Logic (Ported)
        private bool IsSrtTranslatedTextError(string translatedText)
        {
            if (string.IsNullOrWhiteSpace(translatedText)) return true;

            string t = translatedText.Trim();
            try
            {
                if (_srtErrorMarkers != null && _srtErrorMarkers.Contains(t)) return true;
            }
            catch { /* an toàn */ }
            string[] errorKeywords =
            {
        "lỗi api", "too many requests", "forbidden", "service unavailable",
        "bad gateway", "gateway timeout", "rate limit", "overload",
        "http 429", "http 502", "http 503", "http 504", "429", "502", "503", "504"
    };

            foreach (var kw in errorKeywords)
            {
                if (t.IndexOf(kw, StringComparison.OrdinalIgnoreCase) >= 0) return true;
            }
            if (t.StartsWith("[Lỗi", StringComparison.OrdinalIgnoreCase)) return true;
            if (System.Text.RegularExpressions.Regex.IsMatch(t, @"\b(HTTP|Status)\s*(429|502|503|504)\b", System.Text.RegularExpressions.RegexOptions.IgnoreCase))
                return true;

            return false;
        }
        private List<SrtSubtitleLine> GetFailedTranslatedSrtLinesFromGrid()
        {
            var failed = SrtSubtitleLinesView
                .Where(l => !string.IsNullOrWhiteSpace(l.OriginalText) && IsSrtTranslatedTextError(l.TranslatedText))
                .ToList();
            return failed;
        }
        private async Task AutoRetryFailedSrtTranslationsAsync(CancellationToken token, int maxPasses = 3)
        {
            for (int pass = 1; pass <= maxPasses; pass++)
            {
                if (token.IsCancellationRequested) return;
                var failedLines = GetFailedTranslatedSrtLinesFromGrid();
                if (failedLines == null || failedLines.Count == 0) return;
                LogMessage($"[AutoRetry] Phát hiện {failedLines.Count} dòng lỗi. Thử lại lần {pass}/{maxPasses}.");
                await TranslateSrtLogic(token, failedLines);
                if (token.IsCancellationRequested) return;
                var remain = GetFailedTranslatedSrtLinesFromGrid();
                if (remain.Count == 0) return;

                await Task.Delay(TimeSpan.FromSeconds(Math.Min(4, pass)), token);
            }
        }

        private async void TranslateSrtButton_Click(object sender, RoutedEventArgs e)
        {
            if (!SrtSubtitleLinesView.Any())
            {
                CustomMessageBox.Show("Vui lòng tải file SRT trước khi dịch.", "Chưa có phụ đề", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            _masterCts = new CancellationTokenSource();

            try
            {
                var linesToTranslate = new List<SrtSubtitleLine>();
                var linesWithTranslation = SrtSubtitleLinesView.Where(l => !string.IsNullOrWhiteSpace(l.TranslatedText) && !_srtErrorMarkers.Contains(l.TranslatedText.Trim())).ToList();
                var linesWithErrorOrEmpty = SrtSubtitleLinesView.Where(l => string.IsNullOrWhiteSpace(l.TranslatedText) || _srtErrorMarkers.Contains(l.TranslatedText.Trim())).ToList();

                if (!linesWithErrorOrEmpty.Any() && linesWithTranslation.Any())
                {
                    var result = CustomMessageBox.Show("Tất cả các dòng đã có bản dịch. Bạn có muốn dịch lại toàn bộ không?", "Xác nhận dịch lại", MessageBoxButton.YesNo, MessageBoxImage.Question);
                    if (result == MessageBoxResult.Yes)
                    {
                        linesToTranslate = SrtSubtitleLinesView.ToList();
                    }
                    else
                    {
                        _masterCts.Dispose();
                        _masterCts = null;
                        return;
                    }
                }
                else if (linesWithTranslation.Any() && linesWithErrorOrEmpty.Any())
                {
                    var choice = CustomMessageBox.Show("Phát hiện có dòng đã dịch và dòng bị lỗi/trống.\n\n- Chọn 'Yes' để DỊCH LẠI TOÀN BỘ.\n- Chọn 'No' để CHỈ DỊCH CÁC DÒNG LỖI/TRỐNG.", "Tùy chọn dịch", MessageBoxButton.YesNo, MessageBoxImage.Question);
                    if (choice == MessageBoxResult.Yes)
                    {
                        linesToTranslate = SrtSubtitleLinesView.ToList();
                    }
                    else
                    {
                        linesToTranslate = linesWithErrorOrEmpty;
                    }
                }
                else
                {
                    linesToTranslate = SrtSubtitleLinesView.ToList();
                }

                if (linesToTranslate.Any())
                {
                    IsSrtTranslating = true;
                    UpdateUiForProcessing(true);
                    await TranslateSrtLogic(_masterCts.Token, linesToTranslate);
                    await AutoRetryFailedSrtTranslationsAsync(_masterCts.Token);

                    IsSrtTranslating = false;
                    UpdateUiForProcessing(false);
                }
            }
            catch (OperationCanceledException)
            {
                IsSrtTranslating = false;
                UpdateUiForProcessing(false);
            }
            catch (Exception ex)
            {
                IsSrtTranslating = false;
                UpdateUiForProcessing(false);
                CustomMessageBox.Show($"Đã xảy ra lỗi khi dịch phụ đề: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                _masterCts?.Dispose();
                _masterCts = null;
            }
        }

        private async void MergeDuplicateSrtOriginalsButton_Click(object sender, RoutedEventArgs e)
        {
            List<SrtSubtitleLine> removedLines = SrtFileUtils.MergeDuplicates(SrtSubtitleLinesView);
            int mergedCount = removedLines.Count;

            if (mergedCount > 0)
            {
                var clipsToRemoveFromTimeline = new List<TimelineClipViewModel>();
                foreach (var removedLine in removedLines)
                {
                    _currentProject.Subtitles.Remove(removedLine);

                    var clipVM = TimelineClips.FirstOrDefault(c => c.SourceData == removedLine);
                    if (clipVM != null)
                    {
                        clipsToRemoveFromTimeline.Add(clipVM);
                    }
                }

                foreach (var clipVM in clipsToRemoveFromTimeline)
                {
                    TimelineClips.Remove(clipVM);
                }

                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();
                _undoRedoService.AddState(CaptureEditorSnapshot());
                await SaveProjectCurrentAsync();

            }
            else
            {
            }
        }
        private void ExportTranslatedSrtButton_Click(object sender, RoutedEventArgs e)
        {
            if (!SrtSubtitleLinesView.Any()) return;
            var choice = CustomMessageBox.Show("Bạn muốn xuất file phụ đề chứa nội dung nào?\n\n- Chọn 'Yes' để xuất BẢN DỊCH.\n- Chọn 'No' để xuất VĂN BẢN GỐC.", "Tùy chọn xuất file", MessageBoxButton.YesNoCancel, MessageBoxImage.Question);

            if (choice == MessageBoxResult.Cancel)
            {
                return;
            }

            bool exportTranslated = (choice == MessageBoxResult.Yes);

            SaveFileDialog saveFileDialog = new SaveFileDialog
            {
                Filter = "SRT files (*.srt)|*.srt|VTT files (*.vtt)|*.vtt",
                Title = "Lưu file phụ đề",
                FileName = string.IsNullOrWhiteSpace(_currentSrtFilePath)
                    ? (exportTranslated ? "translated_sub.srt" : "original_sub.srt")
                    : $"{Path.GetFileNameWithoutExtension(_currentSrtFilePath)}{(exportTranslated ? "_translated" : "_original")}.srt"
            };

            if (saveFileDialog.ShowDialog() == true)
            {
                try
                {
                    var linesToExport = new List<SrtSubtitleLine>();
                    foreach (var line in SrtSubtitleLinesView)
                    {

                        var exportLine = new SrtSubtitleLine
                        {
                            Index = line.Index,
                            StartTime = line.StartTime,
                            Duration = line.Duration,
                            OriginalText = line.OriginalText,
                            TranslatedText = exportTranslated
                                ? (string.IsNullOrWhiteSpace(line.TranslatedText) ? line.OriginalText : line.TranslatedText)
                                : line.OriginalText
                        };
                        linesToExport.Add(exportLine);
                    }

                    SrtFileUtils.SaveToFile(saveFileDialog.FileName, linesToExport);
                    CustomMessageBox.Show("Xuất file thành công!", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                catch (Exception ex)
                {
                    CustomMessageBox.Show($"Lỗi khi xuất file: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        private async void StopSrtTranslationButton_Click(object sender, RoutedEventArgs e)
        {
            var sessionIdToCancel = _currentAioSessionId;
            _masterCts?.Cancel();

            if (!string.IsNullOrEmpty(sessionIdToCancel))
            {
                try
                {
                    CancelJobResponse result;
                    if (_currentSrtApiProvider == SrtApiProvider.AIOLauncherVIP)
                    {
                        result = await ApiService.CancelVipJobAsync(sessionIdToCancel);
                    }
                    else
                    {
                        result = await ApiService.CancelTranslationJobAsync(sessionIdToCancel);
                    }
                    
                    if (!result.Success)
                    {
                        LogMessage($"[CancelJob] {result.Message}");
                    }
                }
                catch (Exception ex)
                {
                    LogMessage($"[CancelJob] Lỗi khi hủy job: {ex.Message}");
                }
            }
        }

        private async Task TranslateSrtLogic(CancellationToken token, List<SrtSubtitleLine> specificLines = null)
        {

            RebuildSrtTranslationService();
            var linesToTranslate = (specificLines != null && specificLines.Any())
                ? specificLines
                : SrtSubtitleLinesView
                    .Where(l => !string.IsNullOrWhiteSpace(l.OriginalText) && (string.IsNullOrWhiteSpace(l.TranslatedText) || _srtErrorMarkers.Contains(l.TranslatedText.Trim())))
                    .ToList();

            if (!linesToTranslate.Any())
            {
                LogMessage("[Translate] Không có dòng nào hợp lệ để dịch.");
                return;
            }
            if (_currentSrtApiProvider == SrtApiProvider.AIOLauncher)
            {
                await TranslateWithAioLauncherApi(linesToTranslate, token);
            }
            else if (_currentSrtApiProvider == SrtApiProvider.AIOLauncherVIP)
            {
                await TranslateWithAioLauncherVipApi(linesToTranslate, token);
            }
            else
            {
                await TranslateWithThirdPartyApi(linesToTranslate, token);
            }
        }
        private async Task TranslateWithAioLauncherApi(List<SrtSubtitleLine> linesToTranslate, CancellationToken token)
        {
            bool acceptPartial = false;
            string systemInstruction;
            if (IsCustomPromptEnabled)
            {
                if (string.IsNullOrWhiteSpace(CurrentCustomPromptText))
                {
                    CustomMessageBox.Show("Prompt tùy chỉnh đang được bật nhưng nội dung lại trống. Vui lòng nhập prompt.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }
                systemInstruction = CurrentCustomPromptText.Trim() + CUSTOM_PROMPT_SUFFIX;
            }
            else
            {
                systemInstruction = _srtTranslationService.GetSystemInstructionForGeminiSrtTranslation(_selectedSrtGenreValue, _selectedSrtTargetLanguage);
            }
            while (!token.IsCancellationRequested)
            {
                var srtLinesForRequest = linesToTranslate.Select(l => new SrtLine(l.Index, l.OriginalText)).ToList();

                var response = await ApiService.StartTranslationJobAsync(_selectedSrtGenreValue, _selectedSrtTargetLanguage, srtLinesForRequest, systemInstruction, acceptPartial);

                switch (response.Status)
                {
                    case "Accepted":
                        _currentAioSessionId = response.SessionId;
                        _currentLoadingSessionId = response.SessionId; // THÊM MỚI
                        try
                        {
                            await PollForAioResults(response.SessionId, token);
                        }
                        finally
                        {
                            _currentAioSessionId = null;
                            _currentLoadingSessionId = null; // THÊM MỚI
                        }
                        return;

                    case "PartialContent":
                        var userChoice = CustomMessageBox.Show(response.Message, "Không đủ lượt dịch", MessageBoxButton.YesNo, MessageBoxImage.Question);
                        if (userChoice == MessageBoxResult.Yes)
                        {
                            acceptPartial = true;
                            continue;
                        }
                        else
                        {
                            return;
                        }

                    case "Error":
                    default:
                        CustomMessageBox.Show(response.Message, "Lỗi Dịch", MessageBoxButton.OK, MessageBoxImage.Error);
                        return;
                }
            }
        }
        private async Task PollForAioResults(string sessionId, CancellationToken token)
        {
            var totalLines = SrtSubtitleLinesView.Count;
            var translatedCount = 0;

            var startTime = DateTime.UtcNow;
            var timeout = TimeSpan.FromMinutes(15);
            int consecutiveEmptyPolls = 0;
            const int maxConsecutiveEmptyPolls = 30;
            int totalPolls = 0;

            LogMessage($"[Poll] Bắt đầu polling cho session {sessionId}...");

            while (!token.IsCancellationRequested)
            {
                totalPolls++;

                if (DateTime.UtcNow - startTime > timeout)
                {
                    LogMessage($"[Poll] TIMEOUT sau {totalPolls} lần poll.");
                    CustomMessageBox.Show(
                        "Quá trình dịch đã vượt quá thời gian cho phép (15 phút).",
                        "Timeout", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                try
                {
                    var result = await ApiService.GetTranslationResultsAsync(sessionId);

                    // DEBUG LOG
                    LogMessage($"[Poll #{totalPolls}] NewLines: {result.NewLines?.Count ?? 0}, IsCompleted: {result.IsCompleted}");

                    if (result.NewLines != null && result.NewLines.Any())
                    {
                        consecutiveEmptyPolls = 0;
                        foreach (var newLine in result.NewLines)
                        {
                            var lineToUpdate = SrtSubtitleLinesView.FirstOrDefault(l => l.Index == newLine.Index);
                            if (lineToUpdate != null)
                            {
                                lineToUpdate.TranslatedText = newLine.TranslatedText;
                            }
                        }
                        translatedCount += result.NewLines.Count;
                    }
                    else
                    {
                        consecutiveEmptyPolls++;
                    }

                    // ✅ QUAN TRỌNG: Thoát khi server báo hoàn thành
                    if (result.IsCompleted)
                    {
                        LogMessage($"[Poll] ✅ Hoàn thành! Tổng: {translatedCount} dòng");

                        if (!string.IsNullOrEmpty(result.ErrorMessage))
                        {
                            CustomMessageBox.Show(
                                $"Dịch hoàn thành với cảnh báo:\n\n{result.ErrorMessage}",
                                "Cảnh báo", MessageBoxButton.OK, MessageBoxImage.Warning);
                        }
                        return; // THOÁT KHỎI VÒNG LẶP
                    }

                    // Fallback: Nếu poll quá nhiều mà không có dữ liệu mới
                    if (consecutiveEmptyPolls >= maxConsecutiveEmptyPolls)
                    {
                        var translatedInView = SrtSubtitleLinesView.Count(l => !string.IsNullOrWhiteSpace(l.TranslatedText));
                        LogMessage($"[Poll] ⚠️ {consecutiveEmptyPolls} lần poll trống. Đã dịch: {translatedInView}/{totalLines}");

                        if (translatedInView >= totalLines * 0.9)
                        {
                            LogMessage($"[Poll] Đã dịch >= 90%. Coi như hoàn thành.");
                            return;
                        }
                        consecutiveEmptyPolls = 0;
                    }
                }
                catch (Exception ex)
                {
                    LogMessage($"[Poll] ❌ Lỗi: {ex.Message}");
                    consecutiveEmptyPolls++;
                    if (consecutiveEmptyPolls >= 10)
                    {
                        LogMessage($"[Poll] Quá nhiều lỗi. Thoát polling.");
                        return;
                    }
                }

                await Task.Delay(1000, token);
            }
        }

        private async Task TranslateWithAioLauncherVipApi(List<SrtSubtitleLine> linesToTranslate, CancellationToken token)
        {
            string systemInstruction;
            if (IsCustomPromptEnabled)
            {
                if (string.IsNullOrWhiteSpace(CurrentCustomPromptText))
                {
                    CustomMessageBox.Show("Prompt tùy chỉnh đang được bật nhưng nội dung lại trống. Vui lòng nhập prompt.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }
                systemInstruction = CurrentCustomPromptText.Trim() + CUSTOM_PROMPT_SUFFIX;
            }
            else
            {
                systemInstruction = _srtTranslationService.GetSystemInstructionForGeminiSrtTranslation(_selectedSrtGenreValue, _selectedSrtTargetLanguage);
            }

            var srtLinesForRequest = linesToTranslate.Select(l => new SrtLine(l.Index, l.OriginalText)).ToList();
            
            var response = await ApiService.StartVipTranslationAsync(_selectedSrtTargetLanguage, srtLinesForRequest, systemInstruction);

            if (response.Status == "Accepted")
            {
                _currentAioSessionId = response.SessionId;
                _currentLoadingSessionId = response.SessionId;
                try
                {
                    await PollForAioVipResults(response.SessionId, token);
                }
                finally
                {
                    _currentAioSessionId = null;
                    _currentLoadingSessionId = null;
                }
            }
            else
            {
                CustomMessageBox.Show(response.Message ?? "Lỗi không xác định", "Lỗi Dịch VIP", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private async Task PollForAioVipResults(string sessionId, CancellationToken token)
        {
            var totalLines = SrtSubtitleLinesView.Count;
            var translatedCount = 0;

            var startTime = DateTime.UtcNow;
            var timeout = TimeSpan.FromMinutes(15);
            int consecutiveEmptyPolls = 0;
            const int maxConsecutiveEmptyPolls = 30;
            int totalPolls = 0;

            LogMessage($"[Poll VIP] Bắt đầu polling cho session {sessionId}...");

            while (!token.IsCancellationRequested)
            {
                totalPolls++;

                if (DateTime.UtcNow - startTime > timeout)
                {
                    LogMessage($"[Poll VIP] TIMEOUT sau {totalPolls} lần poll.");
                    CustomMessageBox.Show(
                        "Quá trình dịch VIP đã vượt quá thời gian cho phép (15 phút).",
                        "Timeout", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                try
                {
                    var result = await ApiService.GetVipResultsAsync(sessionId);

                    LogMessage($"[Poll VIP #{totalPolls}] NewLines: {result.NewLines?.Count ?? 0}, IsCompleted: {result.IsCompleted}");

                    if (result.NewLines != null && result.NewLines.Any())
                    {
                        consecutiveEmptyPolls = 0;
                        foreach (var newLine in result.NewLines)
                        {
                            var lineToUpdate = SrtSubtitleLinesView.FirstOrDefault(l => l.Index == newLine.Index);
                            if (lineToUpdate != null)
                            {
                                lineToUpdate.TranslatedText = newLine.TranslatedText;
                            }
                        }
                        translatedCount += result.NewLines.Count;
                    }
                    else
                    {
                        consecutiveEmptyPolls++;
                    }

                    if (result.IsCompleted)
                    {
                        LogMessage($"[Poll VIP] ✅ Hoàn thành! Tổng: {translatedCount} dòng");

                        if (!string.IsNullOrEmpty(result.ErrorMessage))
                        {
                            CustomMessageBox.Show(
                                $"Dịch VIP hoàn thành với cảnh báo:\n\n{result.ErrorMessage}",
                                "Cảnh báo", MessageBoxButton.OK, MessageBoxImage.Warning);
                        }
                        return;
                    }

                    if (consecutiveEmptyPolls >= maxConsecutiveEmptyPolls)
                    {
                        var translatedInView = SrtSubtitleLinesView.Count(l => !string.IsNullOrWhiteSpace(l.TranslatedText));
                        LogMessage($"[Poll VIP] ⚠️ {consecutiveEmptyPolls} lần poll trống. Đã dịch: {translatedInView}/{totalLines}");

                        if (translatedInView >= totalLines * 0.9)
                        {
                            LogMessage($"[Poll VIP] Đã dịch >= 90%. Coi như hoàn thành.");
                            return;
                        }
                        consecutiveEmptyPolls = 0;
                    }
                }
                catch (Exception ex)
                {
                    LogMessage($"[Poll VIP] ❌ Lỗi: {ex.Message}");
                    consecutiveEmptyPolls++;
                    if (consecutiveEmptyPolls >= 10)
                    {
                        LogMessage($"[Poll VIP] Quá nhiều lỗi. Thoát polling.");
                        return;
                    }
                }

                await Task.Delay(2000, token); // Poll every 2 seconds for VIP API as recommended
            }
        }

        private async Task TranslateWithThirdPartyApi(List<SrtSubtitleLine> linesToTranslate, CancellationToken token)
        {
            var (canTranslate, message, remaining) = await ApiService.PreSrtTranslateCheckAsync(linesToTranslate.Count);

            if (!canTranslate)
            {
                CustomMessageBox.Show(message, "Không đủ lượt dịch", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            var results = await _srtTranslationService.TranslateAllSrtLinesAsync(
                linesToTranslate, _currentSrtApiProvider, _selectedSrtGenreValue, _selectedSrtTargetLanguage,
                (progress) => Dispatcher.Invoke(() => { /*  */ }),
                token
            );

            foreach (var result in results)
            {
                var lineToUpdate = SrtSubtitleLinesView.FirstOrDefault(l => l.Index == result.Key);
                if (lineToUpdate != null)
                {
                    lineToUpdate.TranslatedText = result.Value.text;
                }
            }
            LogMessage("[Translate3rdParty] Dịch hoàn tất.");
        }
        private void SrtApiProvider_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (!this.IsLoaded || !(SrtApiProviderComboBox.SelectedItem is SrtApiProvider selectedProvider)) return;
            _currentSrtApiProvider = selectedProvider;
            UpdateSrtApiProviderControls();
        }

        private void SrtTranslateModel_Changed(object sender, SelectionChangedEventArgs e)
        {
            if (!this.IsLoaded || SrtTranslateModelComboBox.SelectedItem == null) return;
            string selectedModel = SrtTranslateModelComboBox.SelectedItem.ToString();

            if (_currentSrtApiProvider == SrtApiProvider.ChutesAI)
                _selectedChutesModelSrt = selectedModel;
            else if (_currentSrtApiProvider == SrtApiProvider.Gemini)
                _selectedGeminiModelSrt = selectedModel;
            else if (_currentSrtApiProvider == SrtApiProvider.ChatGPT)
                _selectedChatGPTModelSrt = selectedModel;
        }

        private void SrtTargetLanguage_Changed(object sender, SelectionChangedEventArgs e)
        {
            if (SrtTargetLanguageComboBox.SelectedItem != null)
            {
                _selectedSrtTargetLanguage = SrtTargetLanguageComboBox.SelectedItem.ToString();
            }
        }
        private void SrtGenre_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (!this.IsLoaded || SrtGenreComboBox.SelectedItem == null) return;
            _selectedSrtGenreValue = SrtGenreComboBox.SelectedItem.ToString();
        }

        private void UpdateSrtApiProviderControls()
        {
            SrtApiProviderComboBox.SelectedItem = _currentSrtApiProvider;

            bool isGemini = _currentSrtApiProvider == SrtApiProvider.Gemini;
            bool isChatGPT = _currentSrtApiProvider == SrtApiProvider.ChatGPT;
            bool isChutes = _currentSrtApiProvider == SrtApiProvider.ChutesAI;
            bool isAIO = _currentSrtApiProvider == SrtApiProvider.AIOLauncher || _currentSrtApiProvider == SrtApiProvider.AIOLauncherVIP;
            SrtTranslateModelComboBox.IsEnabled = !isAIO;
            SrtTranslateModelComboBox.Items.Clear();

            if (isAIO)
            {
                SrtTranslateModelComboBox.ItemsSource = null;
            }
            else if (isGemini)
            {
                SrtTranslateModelComboBox.Items.Add(ApiConfig.DefaultGeminiModelSrt);
                foreach (var model in _geminiCustomModelsSrt) SrtTranslateModelComboBox.Items.Add(model);
                SrtTranslateModelComboBox.SelectedItem = _selectedGeminiModelSrt;
            }
            else if (isChatGPT)
            {
                foreach (var model in ApiConfig.DefaultChatGPTModelsSrt) SrtTranslateModelComboBox.Items.Add(model);
                foreach (var model in _chatGptCustomModelsSrt) SrtTranslateModelComboBox.Items.Add(model);
                SrtTranslateModelComboBox.SelectedItem = _selectedChatGPTModelSrt;
            }
            else
            {
                SrtTranslateModelComboBox.Items.Add(ApiConfig.DefaultChutesModelSrt);
                foreach (var model in _chutesCustomModelsSrt) SrtTranslateModelComboBox.Items.Add(model);
                SrtTranslateModelComboBox.SelectedItem = _selectedChutesModelSrt;
            }

            if (SrtTranslateModelComboBox.SelectedIndex == -1 && SrtTranslateModelComboBox.Items.Count > 0)
            {
                SrtTranslateModelComboBox.SelectedIndex = 0;
            }
        }

        private void RebuildSrtTranslationService()
        {
            _srtTranslationService = new SrtTranslationService(
                new SrtTranslationService.SrtApiConfig
                {
                    ChutesApiKey = _chutesApiKeySrt,
                    ChutesModel = _selectedChutesModelSrt,
                    GeminiApiKeys = _geminiApiKeysSrt,
                    GeminiModel = _selectedGeminiModelSrt,
                    UseGeminiMultiKey = _geminiEnableMultiKeySrt,
                    GeminiRpm = _geminiSrtTranslationRpm,
                    GeminiBatchSize = _geminiSrtTranslationBatchSize,
                    GeminiThinkingBudget = _geminiSrtThinkingBudget,
                    ChatGPTBatchSize = _chatGptSrtBatchSize,
                    ChatGPTModel = _selectedChatGPTModelSrt
                }
            )
            { LogMessage = (msg, isErr) => LogMessage(msg, isErr) };
        }

        #endregion
        #region File Handling (SRT Load, Drop) - Ported

        private async void BrowseSrtFileButton_Click(object sender, RoutedEventArgs e)
        {
            OpenFileDialog openFileDialog = new OpenFileDialog
            {
                Filter = "Subtitle files (*.srt;*.vtt;*.ass)|*.srt;*.vtt;*.ass|All files (*.*)|*.*",
                Title = "Chọn file phụ đề để dịch"
            };
            if (openFileDialog.ShowDialog() == true)
            {
                await LoadSrtFile(openFileDialog.FileName);
            }
        }


        private async Task LoadSrtFile(string filePath, bool addToTimelineAndProject = true)
        {
            try
            {
                var lines = SrtFileUtils.LoadFromFile(filePath);
                _currentSrtFilePath = filePath;
                if (addToTimelineAndProject)
                {
                    TimeSpan timeOffset = TimeSpan.Zero;
                    var videoClips = TimelineClips
                        .Where(c => c.ClipType == TimelineClipType.Video)
                        .OrderBy(c => c.StartTime)
                        .ToList();

                    if (videoClips.Any())
                    {
                        timeOffset = videoClips.First().StartTime;
                    }
                    var oldSubtitleClips = TimelineClips.Where(c => c.ClipType == TimelineClipType.Subtitle).ToList();
                    foreach (var clip in oldSubtitleClips)
                    {
                        TimelineClips.Remove(clip);
                    }
                    _currentProject.Subtitles.Clear();
                    var nonTextLines = SrtSubtitleLinesView.Where(l => !l.IsTextClip).ToList();
                    foreach (var line in nonTextLines)
                    {
                        SrtSubtitleLinesView.Remove(line);
                    }

                    var projectTemplate = GetTemplateAsStyleState();

                    foreach (var line in lines)
                    {
                        line.StartTime += timeOffset;
                        line.Style = projectTemplate.Clone();
                        line.Style.Width = null;
                        line.Style.FixedTextBoxWidth = 0;

                        SrtSubtitleLinesView.Add(line);
                        TimelineClips.Add(new TimelineClipViewModel(line));
                        _currentProject.Subtitles.Add(line);
                    }

                    RecalculateTrackAssignments();
                    RecalculateTotalDuration();
                    UpdateTimelineScaleAndRender();
                    UpdateSubtitleForCurrentTime();
                    if (TranslateTab != null) TranslateTab.IsChecked = true;
                }
                else
                {
                    SrtSubtitleLinesView.Clear();
                    foreach (var line in _currentProject.TextClips) SrtSubtitleLinesView.Add(line);
                    foreach (var line in lines) SrtSubtitleLinesView.Add(line);
                }
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Không thể tải hoặc parse file phụ đề.\nLỗi: {ex.Message}", "Lỗi Tải File", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void MediaPanel_DragOver(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                e.Effects = DragDropEffects.Copy;
            }
            else
            {
                e.Effects = DragDropEffects.None;
            }
            e.Handled = true;
        }

        private async void MediaPanel_Drop(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
                if (files == null || !files.Any()) return;

                LoadingOverlay.Visibility = Visibility.Visible;
                try
                {
                    foreach (var filePath in files)
                    {
                        var newAsset = await AddFileToMediaBinAsync(filePath);
                        if (newAsset != null && newAsset.Type == AssetType.Subtitle)
                        {
                            await LoadSrtFile(filePath, addToTimelineAndProject: false);
                            if (TranslateTab != null) TranslateTab.IsChecked = true;
                        }
                    }
                }
                finally
                {
                    LoadingOverlay.Visibility = Visibility.Collapsed;
                }
            }
        }
        private async Task<MediaAsset> AddFileToMediaBinAsync(string filePath)
        {
            var extension = Path.GetExtension(filePath).ToLowerInvariant();
            var asset = new MediaAsset { FilePath = filePath };

            try
            {
                if (new[] { ".mp4", ".mkv", ".avi", ".mov", ".wmv" }.Contains(extension))
                {
                    asset.Type = AssetType.Video;

                    if (!_filmstripServiceInstances.ContainsKey(filePath))
                    {
                        try
                        {
                            _filmstripServiceInstances[filePath] = FilmstripService.Open(filePath);
                        }
                        catch (Exception)
                        {
                            return null;
                        }
                    }

                    if (_filmstripServiceInstances.TryGetValue(filePath, out var filmstripService))
                    {
                        var mediaInfoForThumb = await FFProbe.AnalyseAsync(filePath);
                        var durationForThumb = mediaInfoForThumb.Duration;
                        var captureTime = durationForThumb.TotalSeconds > 10 ? TimeSpan.FromSeconds(durationForThumb.TotalSeconds * 0.1) : TimeSpan.FromSeconds(1);

                        BitmapImage thumbnailBitmap = await filmstripService.GetThumbnailAtAsync(captureTime, 120, CancellationToken.None);
                        if (thumbnailBitmap != null)
                        {
                            asset.ThumbnailSource = thumbnailBitmap;
                            asset.ThumbnailBase64 = Services.MediaProcessingService.ConvertBitmapImageToBase64(thumbnailBitmap);
                        }
                    }

                    var mediaInfo = await FFProbe.AnalyseAsync(filePath);
                    asset.Duration = mediaInfo.Duration;
                    var videoStream = mediaInfo.PrimaryVideoStream;
                    if (videoStream != null)
                    {
                        asset.Width = videoStream.Width;
                        asset.Height = videoStream.Height;
                    }

                    VideoImageAssets.Add(asset);
                }
                else if (new[] { ".mp3", ".wav", ".aac", ".m4a", ".ogg", ".flac" }.Contains(extension))
                {
                    asset.Type = AssetType.Audio;
                    var mediaInfo = await FFProbe.AnalyseAsync(filePath);
                    asset.Duration = mediaInfo.Duration;
                    AudioAssets.Add(asset);
                    QueueWaveformGeneration(asset);
                }
                else if (new[] { ".png", ".jpg", ".jpeg", ".bmp", ".gif", ".ico" }.Contains(extension))
                {
                    asset.Type = AssetType.Image;
                    asset.ThumbnailSource = LoadBitmapImage(filePath);
                    if (asset.ThumbnailSource != null)
                    {
                        asset.Width = asset.ThumbnailSource.PixelWidth;
                        asset.Height = asset.ThumbnailSource.PixelHeight;
                        asset.ThumbnailBase64 = Services.MediaProcessingService.ConvertBitmapImageToBase64(asset.ThumbnailSource);
                    }
                    asset.Duration = TimeSpan.FromSeconds(5);
                    VideoImageAssets.Add(asset);
                }
                else if (new[] { ".srt", ".ass", ".vtt" }.Contains(extension))
                {
                    asset.Type = AssetType.Subtitle;
                    try
                    {
                        var lines = await Task.Run(() => SrtFileUtils.LoadFromFile(filePath));
                        if (lines.Any())
                        {
                            var startTime = lines.Min(l => l.StartTime);
                            var endTime = lines.Max(l => l.EndTime);
                            asset.Duration = endTime - startTime;
                        }
                        else
                        {
                            asset.Duration = TimeSpan.FromSeconds(5);
                        }
                    }
                    catch (Exception)
                    {
                        asset.Duration = TimeSpan.FromSeconds(5);
                    }
                    SubtitleAssets.Add(asset);
                }
                else
                {
                    return null;
                }

                return asset;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[AddFileToMediaBinAsync] Error processing file {filePath}: {ex.Message}");
                return null;
            }
        }

        #endregion
        #region OCR Mode Selection Logic (Ported)

        private void CopyFailedImage(string imagePath, string reason)
        {
            try
            {
                if (!Directory.Exists(_desktopErrorFolderPath))
                {
                    Directory.CreateDirectory(_desktopErrorFolderPath);
                }

                if (File.Exists(imagePath))
                {
                    File.Copy(imagePath, Path.Combine(_desktopErrorFolderPath, Path.GetFileName(imagePath)), true);
                }
            }
            catch (Exception ex)
            {
            }
        }
        private void OcrMode_Click(object sender, RoutedEventArgs e)
        {
            if (sender is MenuItem selectedMenu)
            {
                if (selectedMenu == OcrModeGoogleCloudMenuItem)
                {
                    _currentOcrMode = OcrMode.GoogleCloud;
                }
                else if (selectedMenu == OcrModeGeminiApiMenuItem)
                {
                    _currentOcrMode = OcrMode.GeminiApi;
                }
                UpdateOcrModeMenuState();
                SaveConfiguration();
            }
        }
        private void UpdateOcrModeMenuState()
        {
            if (OcrModeGoogleCloudMenuItem == null || OcrModeGeminiApiMenuItem == null || OcrProviderGoogleCloudRadio == null || OcrProviderGeminiApiRadio == null)
            {
                return;
            }

            bool isGoogle = (_currentOcrMode == OcrMode.GoogleCloud);
            OcrModeGoogleCloudMenuItem.IsChecked = isGoogle;
            OcrModeGeminiApiMenuItem.IsChecked = !isGoogle;
            OcrProviderGoogleCloudRadio.IsChecked = isGoogle;
            OcrProviderGeminiApiRadio.IsChecked = !isGoogle;
        }
        #endregion
        #region Menu Logic (File, Tools) - Ported

        private void NewProjectMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var result = CustomMessageBox.Show("Tạo project mới sẽ xóa toàn bộ công việc chưa lưu. Bạn có chắc chắn?", "Xác nhận", MessageBoxButton.YesNo, MessageBoxImage.Warning);
            if (result == MessageBoxResult.Yes)
            {
                ResetApplicationState(true);
            }
        }
        private void ExportVideoButton_Click(object sender, RoutedEventArgs e)
        {
            CustomMessageBox.Show("Chức năng Xuất Video sẽ được tích hợp sau khi hoàn thiện tab Edit Sub.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private async void DownloadDefaultFonts_Click(object sender, RoutedEventArgs e)
        {
            var fontUrl = "https://github.com/google/fonts/raw/main/ofl/roboto/Roboto-Regular.ttf";
            try
            {
                await FontManager.DownloadFontAsync(fontUrl, new Progress<double>(p => { /* Cập nhật progress bar */ }));
                CustomMessageBox.Show("Tải font thành công!");
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Lỗi tải font: {ex.Message}");
            }
        }

        private void ImportFonts_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new Ookii.Dialogs.Wpf.VistaFolderBrowserDialog
            {
                Description = "Chọn thư mục chứa các file font (.ttf, .otf)",
                UseDescriptionForTitle = true
            };

            if (dialog.ShowDialog(this).GetValueOrDefault())
            {
                var fontFiles = Directory.GetFiles(dialog.SelectedPath, "*.*", SearchOption.TopDirectoryOnly)
                    .Where(f => f.EndsWith(".ttf", StringComparison.OrdinalIgnoreCase) || f.EndsWith(".otf", StringComparison.OrdinalIgnoreCase));

                int importedCount = 0;
                foreach (var fontFile in fontFiles)
                {
                    try
                    {
                        var destPath = Path.Combine(FontManager.FontFolder, Path.GetFileName(fontFile));
                        File.Copy(fontFile, destPath, true);
                        importedCount++;
                    }
                    catch (Exception ex)
                    {
                    }
                }

                if (importedCount > 0)
                {
                    CustomMessageBox.Show($"Đã import thành công {importedCount} font.");
                }
            }
        }

        #endregion
        #region New Project, Preset, and State Management Logic

        private async void ResetApplicationState(bool createNewProjectState)
        {
            await PauseTimelinePlayback();
            foreach (var service in _filmstripServiceInstances.Values)
            {
                service.Dispose();
            }
            _filmstripServiceInstances.Clear();

            if (createNewProjectState)
            {
                CurrentProject = ProjectManager.CreateNewProject();
                _currentProjectFilePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Projects", $"{_currentProject.ProjectName}.json");
            }
            CurrentProject.ProjectReferenceVideoWidth = DEFAULT_REFERENCE_WIDTH;
            CurrentProject.ProjectReferenceVideoHeight = DEFAULT_REFERENCE_HEIGHT;
            videoGrid.Width = DEFAULT_REFERENCE_WIDTH;
            videoGrid.Height = DEFAULT_REFERENCE_HEIGHT;
            SrtSubtitleLinesView.Clear();
            TimelineClips.Clear();
            VisibleTimelineClips.Clear();
            VideoImageAssets.Clear();
            AudioAssets.Clear();
            SubtitleAssets.Clear();
            TimelineAudioClips.Clear();

            _selectedSubtitle = null;
            _selectedTimelineClip = null;
            SelectedAudioClip = null;
            ActiveMediaAsset = null;
            _activeVideoClip = null;
            foreach (var visual in _activeVisuals.Values)
            {
                SubtitleRenderCanvas.Children.Remove(visual);
            }
            _activeVisuals.Clear();
            _playhead = TimeSpan.Zero;
            _totalTimelineDuration = TimeSpan.FromMinutes(5);
            _actualContentDuration = TimeSpan.Zero;
            _currentSrtFilePath = "";
            _currentVideoPath = null;
            _undoRedoService.Clear();

            VideoEntry.Text = "";
            ImagesEntry.Text = "";
            SubtitleEntry.Text = "";
            totalDurationTextBlock.Text = "00:00:00.000";
            UpdateEditorPanelFromState();
            UpdateTimelineScaleAndRender();
            UpdatePlaybackUI(TimeSpan.Zero);
            UpdateEditorPanelVisibility();

            if (createNewProjectState)
            {
                _undoRedoService.AddState(CaptureEditorSnapshot());
                SaveProjectCurrent();
            }
        }
        private void UpdateProjectStateBeforeSave()
        {
            if (_currentProject == null)
            {
                _currentProject = new ProjectState();
            }
            var timelineAssets = TimelineClips
                .Select(vm => vm?.SourceData as MediaAsset)
                .Where(ma => ma != null)
                .ToList();
            _currentProject.TimelineMediaClips = timelineAssets;
            var subs = SrtSubtitleLinesView.Where(line => line != null && !line.IsTextClip).ToList();
            var texts = SrtSubtitleLinesView.Where(line => line != null && line.IsTextClip).ToList();
            _currentProject.Subtitles = subs;
            _currentProject.TextClips = texts;
            var allAudioClips = TimelineClips
                .Select(vm => vm?.SourceData as TimelineAudioClip)
                .Where(tac => tac != null)
                .ToList();
            _currentProject.VoicedSubtitles = allAudioClips;
            if (CurrentProject.ProjectReferenceVideoWidth <= 0) CurrentProject.ProjectReferenceVideoWidth = 1280;
            if (CurrentProject.ProjectReferenceVideoHeight <= 0) CurrentProject.ProjectReferenceVideoHeight = 720;
        }
        private void LoadPreset_Click(object sender, RoutedEventArgs e)
        {
            if (sender is MenuItem menuItem && menuItem.Header is string presetName)
            {
                var presetState = PresetManager.LoadPreset(presetName);
                if (presetState != null)
                {
                    ApplyPreset(presetState);
                }
            }
        }
        private void DeleteCurrentProject_Click()
        {
            var result = CustomMessageBox.Show(
                $"Bạn có chắc chắn muốn xoá vĩnh viễn project hiện tại '{_currentProject.ProjectName}' không? Hành động này không thể hoàn tác.",
                "Xác nhận Xoá Project",
                MessageBoxButton.YesNo,
                MessageBoxImage.Warning
            );

            if (result == MessageBoxResult.Yes)
            {
                string projectToDeleteName = _currentProject.ProjectName;
                string projectToDeletePath = _currentProjectFilePath;
                ProjectManager.DeleteProject(projectToDeletePath);
                ResetApplicationState(true);
                CustomMessageBox.Show($"Đã xoá thành công project '{projectToDeleteName}'.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            else
            {
            }
        }

        private void ApplyPreset(ProjectState preset)
        {
            _currentProject.VsfCropTop = preset.VsfCropTop;
            _currentProject.VsfCropBottom = preset.VsfCropBottom;
            _currentProject.VsfCropLeft = preset.VsfCropLeft;
            _currentProject.VsfCropRight = preset.VsfCropRight;
            _topPercent = _currentProject.VsfCropTop;
            _bottomPercent = _currentProject.VsfCropBottom;
            _leftPercent = _currentProject.VsfCropLeft;
            _rightPercent = _currentProject.VsfCropRight;
            UpdateCropThumbsLayout();
            UpdateResultsText();

            _currentProject.TemplateX = preset.TemplateX;
            _currentProject.TemplateY = preset.TemplateY;
            _currentProject.TemplateScaleX = preset.TemplateScaleX;
            _currentProject.TemplateScaleY = preset.TemplateScaleY;
            _currentProject.TemplateRotation = preset.TemplateRotation;
            _currentProject.TemplateWidth = null;
            _currentProject.TemplateOpacity = preset.TemplateOpacity;
            _currentProject.TemplateFontFamily = preset.TemplateFontFamily;
            _currentProject.TemplateFontSize = preset.TemplateFontSize;
            _currentProject.TemplateFontColor = preset.TemplateFontColor;
            _currentProject.TemplateFontWeight = preset.TemplateFontWeight;
            _currentProject.TemplateIsItalic = preset.TemplateIsItalic;
            _currentProject.TemplateIsUnderlined = preset.TemplateIsUnderlined;
            _currentProject.TemplateCharacterSpacing = preset.TemplateCharacterSpacing;
            _currentProject.IsBackgroundEnabled = preset.IsBackgroundEnabled;
            _currentProject.TemplateBackgroundColor = preset.TemplateBackgroundColor;
            _currentProject.TemplateBackgroundPaddingX = preset.TemplateBackgroundPaddingX;
            _currentProject.TemplateBackgroundPaddingY = preset.TemplateBackgroundPaddingY;
            _currentProject.TemplateBackgroundCornerRadius = preset.TemplateBackgroundCornerRadius;
            _currentProject.TemplateBackgroundOpacity = preset.TemplateBackgroundOpacity;
            _currentProject.IsOutlineEnabled = preset.IsOutlineEnabled;
            _currentProject.TemplateOutlineColor = preset.TemplateOutlineColor;
            _currentProject.TemplateOutlineThickness = preset.TemplateOutlineThickness;
            _currentProject.IsShadowEnabled = preset.IsShadowEnabled;
            _currentProject.TemplateShadowColor = preset.TemplateShadowColor;
            _currentProject.TemplateShadowBlur = preset.TemplateShadowBlur;
            _currentProject.TemplateShadowDepth = preset.TemplateShadowDepth;
            _currentProject.TemplateShadowDirection = preset.TemplateShadowDirection;

            UpdateEditorPanelFromState();
            var newTemplate = _currentProject.GetTemplateAsStyleState();
            ApplyTemplateToAllSubtitlesAndUpdate(newTemplate, _selectedSubtitle);

            _undoRedoService.AddState(CaptureEditorSnapshot());
            SaveProjectCurrent();
        }

        private void LoadProjectMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new Microsoft.Win32.OpenFileDialog
            {
                Title = "Open project",
                Filter = "Project Files (*.json)|*.json|All files (*.*)|*.*",
                InitialDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Projects"),
                CheckFileExists = true,
                Multiselect = false
            };

            if (dialog.ShowDialog(this) == true)
            {
                try
                {
                    var loadedSnap = subphimv1.Services.ProjectManager.LoadSnapshot(dialog.FileName);
                    if (loadedSnap != null)
                    {
                        ApplySnapshot(loadedSnap);
                    }
                    else
                    {
                        CustomMessageBox.Show("Không thể đọc file project. File có thể bị lỗi hoặc không đúng định dạng.", "Lỗi Tải Project", MessageBoxButton.OK, MessageBoxImage.Error);
                    }
                }
                catch (Exception ex)
                {
                    CustomMessageBox.Show($"Đã xảy ra lỗi khi tải project:\n{ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }
        private void DeleteProjectMenuItem_SubmenuOpened(object sender, RoutedEventArgs e)
        {
            DeleteProjectMenuItem.Items.Clear();
            var projectPaths = ProjectManager.GetAllProjectPaths();

            if (!projectPaths.Any())
            {
                var noProjectsItem = new MenuItem { Header = "(Không có project nào)", IsEnabled = false };
                DeleteProjectMenuItem.Items.Add(noProjectsItem);
                return;
            }

            foreach (var path in projectPaths)
            {
                var menuItem = new MenuItem
                {
                    Header = Path.GetFileNameWithoutExtension(path),
                    Tag = path
                };
                menuItem.Click += DeleteProjectFile_Click;
                DeleteProjectMenuItem.Items.Add(menuItem);
            }
        }
        private void UpdatePresetMenu()
        {
            PresetMenuItem.Items.Clear();

            var presetNames = PresetManager.GetAllPresetNames();

            if (!presetNames.Any())
            {
                var createFirstItem = new MenuItem { Header = "Tạo preset mới..." };
                createFirstItem.Click += SaveCurrentPreset_Click;
                PresetMenuItem.Items.Add(createFirstItem);
            }
            else
            {
                var saveCurrentItem = new MenuItem { Header = "Lưu preset hiện tại..." };
                saveCurrentItem.Click += SaveCurrentPreset_Click;
                PresetMenuItem.Items.Add(saveCurrentItem);
                PresetMenuItem.Items.Add(new Separator());
                foreach (var name in presetNames)
                {
                    var loadItem = new MenuItem { Header = name };
                    loadItem.Click += LoadPreset_Click;
                    PresetMenuItem.Items.Add(loadItem);
                }
            }
        }

        private void SaveCurrentPreset_Click(object sender, RoutedEventArgs e)
        {

            if (!PresetManager.GetAllPresetNames().Any())
            {
                var result = CustomMessageBox.Show(
                   "Bạn có muốn sử dụng các cài đặt (thông số crop, style phụ đề) của project hiện tại để tạo preset mới không?",
                   "Tạo Preset",
                   MessageBoxButton.YesNo,
                   MessageBoxImage.Question
               );
                if (result == MessageBoxResult.No)
                {
                    return;
                }
            }

            string presetName = InputBox.Show("Nhập tên cho preset:", "Lưu Preset");

            if (!string.IsNullOrWhiteSpace(presetName))
            {
                UpdateProjectStateBeforeSave();
                PresetManager.SavePreset(_currentProject, presetName);
                UpdatePresetMenu();
            }
            else
            {
            }
        }

        private void DeleteProjectFile_Click(object sender, RoutedEventArgs e)
        {
            if (sender is MenuItem menuItem && menuItem.Tag is string path)
            {
                string projectName = Path.GetFileNameWithoutExtension(path);
                bool isDeletingCurrentProject = string.Equals(_currentProjectFilePath, path, StringComparison.OrdinalIgnoreCase);
                ProjectManager.DeleteProject(path);
                if (isDeletingCurrentProject)
                {
                    ResetApplicationState(true);
                }

            }
        }

        #endregion
        #region OCR Process Logic (Full Original Logic Ported)

        private async void StartButton_Click(object sender, RoutedEventArgs e)
        {
            if (!await CheckGoogleAccountsAndShowGuideAsync()) return;

            TranslateTab.IsChecked = true;
            _masterCts = new CancellationTokenSource();
            UpdateUiForProcessing(true);

            try
            {
                Action<int, string> updateProgressAction = (percent, message) =>
                {
                };

                bool ocrResult = await StartOcrProcessAsync(_masterCts.Token, updateProgressAction);
                UpdateUiForProcessing(false);

                if (ocrResult) { }
                else if (_masterCts.IsCancellationRequested)
                {
                    LogMessage("[OCR] Quá trình OCR đã bị hủy bởi người dùng.", isError: true);
                }
                else
                {
                    UpdateUiForProcessing(false);
                    CustomMessageBox.Show("Có lỗi xảy ra trong quá trình OCR.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                UpdateUiForProcessing(false);
                CustomMessageBox.Show($"Lỗi không mong muốn: {ex.Message}", "Lỗi nghiêm trọng", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                UpdateUiForProcessing(false);
                _masterCts?.Dispose();
                _masterCts = null;
            }
        }

        private async Task<bool> HandleOcrPostProcessingAsync(CancellationToken cancellationToken)
        {
            var failedLines = SrtSubtitleLinesView
                .Where(l => !string.IsNullOrWhiteSpace(l.OriginalText) &&
                            (l.OriginalText.Contains("HTTP 429") || l.OriginalText.Contains("HTTP 503") || l.OriginalText.Contains("Lỗi API không thể phục hồi")))
                .ToList();

            if (!failedLines.Any())
            {
                return true;
            }
            try
            {
                await Task.Delay(TimeSpan.FromMinutes(1), cancellationToken);
            }
            catch (OperationCanceledException)
            {
                return false;
            }
            foreach (var line in failedLines)
            {
                line.OriginalText = "[Đang OCR lại...]";
            }
            SrtLinesDataGrid.Items.Refresh();
            Action<int, string> dummyProgress = (percent, message) => { };
            bool retrySuccess = await StartOcrProcessAsync(cancellationToken, failedLines, dummyProgress);

            if (retrySuccess)
            {
            }
            else
            {
            }

            return retrySuccess;
        }
        private async Task<bool> StartOcrProcessAsync(CancellationToken cancellationToken, Action<int, string> updateProgressAction)
        {
            updateProgressAction(0, "Đang kiểm tra điều kiện...");
            if (!ValidateOcrPrerequisites(out string srtFilePath, out string imagesDirPath)) return false;

            var initialImageFiles = Directory.GetFiles(imagesDirPath, "*.*", SearchOption.TopDirectoryOnly)
                                           .Where(f => f.EndsWith(".jpg", StringComparison.OrdinalIgnoreCase) ||
                                               f.EndsWith(".png", StringComparison.OrdinalIgnoreCase) ||
                                               f.EndsWith(".jpeg", StringComparison.OrdinalIgnoreCase) ||
                                               f.EndsWith(".bmp", StringComparison.OrdinalIgnoreCase))
                                   .OrderBy(f => f, new NaturalStringComparer()).ToList();

            if (!initialImageFiles.Any())
            {
                CustomMessageBox.Show("Không tìm thấy file ảnh nào trong thư mục được chỉ định.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                return false;
            }
            updateProgressAction(5, "Đang tạo danh sách SRT từ ảnh...");
            var oldSubtitleClips = TimelineClips.Where(c => c.ClipType == TimelineClipType.Subtitle || c.ClipType == TimelineClipType.Text).ToList();
            foreach (var clip in oldSubtitleClips)
            {
                TimelineClips.Remove(clip);
            }
            _currentProject.Subtitles.Clear();
            SrtSubtitleLinesView.Clear();
            int initialSubtitleTrack = TrackLayoutManager.TEXT_TRACK_START; 
            var newLines = await PrepareSrtViewFromImagesNonBlockingAsync(
    initialImageFiles,
    srtFilePath,
    cancellationToken,
    initialSubtitleTrack);
            if (cancellationToken.IsCancellationRequested) return false;
            await StartOcrProcessAsync(cancellationToken, newLines, updateProgressAction);
            if (cancellationToken.IsCancellationRequested) return false;
            await HandleOcrPostProcessingAsync(cancellationToken);
            if (cancellationToken.IsCancellationRequested) return false;
            if (_currentOcrMode == OcrMode.GoogleCloud)
            {
                var linesToRemove = SrtSubtitleLinesView
                    .Where(line => !string.IsNullOrWhiteSpace(line.OriginalText) && line.OriginalText.Trim().Length == 1)
                    .ToList();

                if (linesToRemove.Any())
                {
                    LogMessage($"[GDRIVE_FILTER] Phát hiện {linesToRemove.Count} dòng có 1 ký tự, tiến hành xóa...");
                    foreach (var line in linesToRemove)
                    {
                        SrtSubtitleLinesView.Remove(line);
                    }
                }
            }
            var validLinesFromOcr = SrtSubtitleLinesView
                .Where(l => !string.IsNullOrWhiteSpace(l.OriginalText) &&
                            l.OriginalText != GeminiOcrService.NO_TEXT_INDICATOR &&
                            l.OriginalText != "[Đang chờ OCR...]")
                .ToList();

            var removedAfterMerge = SrtFileUtils.MergeDuplicates(new System.Collections.ObjectModel.ObservableCollection<SrtSubtitleLine>(validLinesFromOcr));
            var finalLines = validLinesFromOcr.Except(removedAfterMerge).ToList();
            SrtFileUtils.ReIndex(new System.Collections.ObjectModel.ObservableCollection<SrtSubtitleLine>(finalLines));
            SrtSubtitleLinesView.Clear();
            _currentProject.Subtitles.Clear();
            var clipsToRemove = TimelineClips.Where(c => c.SourceData is SrtSubtitleLine).ToList();
            foreach (var clip in clipsToRemove) TimelineClips.Remove(clip);

            if (finalLines.Any())
            {
                foreach (var srtLine in finalLines)
                {
                    SrtSubtitleLinesView.Add(srtLine);
                    _currentProject.Subtitles.Add(srtLine);
                    TimelineClips.Add(new TimelineClipViewModel(srtLine));
                }

                RecalculateTrackAssignments();
                UpdateTimelineScaleAndRender();
                SrtFileUtils.SaveToFile(srtFilePath, SrtSubtitleLinesView.ToList());
                return true;
            }
            else
            {
                RecalculateTrackAssignments();
                UpdateTimelineScaleAndRender();
                return true;
            }
        }
        private async Task<bool> StartOcrProcessAsync(CancellationToken cancellationToken, List<SrtSubtitleLine> linesToProcess, Action<int, string> updateProgressAction)
        {
            string tempRetryDir = null;
            var imagePathsToProcess = new List<string>();
            var pathToLineMap = new Dictionary<string, SrtSubtitleLine>();

            bool isRetrySession = linesToProcess.Any(l => l.OriginalText == "[Đang OCR lại...]");

            if (isRetrySession)
            {
                tempRetryDir = Path.Combine(Path.GetTempPath(), $"ocr_retry_{Guid.NewGuid()}");
                Directory.CreateDirectory(tempRetryDir);
                foreach (var line in linesToProcess)
                {
                    try
                    {
                        string newPath = Path.Combine(tempRetryDir, Path.GetFileName(line.ImagePath));
                        File.Copy(line.ImagePath, newPath, true);
                        imagePathsToProcess.Add(newPath);
                        pathToLineMap[newPath] = line;
                    }
                    catch (Exception ex)
                    {
                    }
                }
            }
            else
            {
                imagePathsToProcess = linesToProcess.Select(l => l.ImagePath).ToList();
                foreach (var line in linesToProcess)
                {
                    pathToLineMap[line.ImagePath] = line;
                }
            }

            if (!imagePathsToProcess.Any())
            {
                if (tempRetryDir != null) Directory.Delete(tempRetryDir, true);
                return false;
            }
            string rawTextsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "raw_texts_ocr");
            try { if (Directory.Exists(rawTextsDir)) Directory.Delete(rawTextsDir, true); Directory.CreateDirectory(rawTextsDir); }
            catch (Exception ex) { LogMessage($"[OCR][ERROR] Không thể tạo thư mục tạm: {ex.Message}", true); return false; }

            var filesToOcr = await PreprocessImagesAsync(imagePathsToProcess, cancellationToken);
            if (cancellationToken.IsCancellationRequested || !filesToOcr.Any())
            {
                if (tempRetryDir != null) Directory.Delete(tempRetryDir, true);
                return false;
            }

            bool success = await RunOcrTasks(filesToOcr, rawTextsDir, cancellationToken, updateProgressAction, pathToLineMap);


            if (tempRetryDir != null)
            {
                try
                {
                    Directory.Delete(tempRetryDir, true);
                }
                catch (Exception ex)
                {
                }
            }

            return success;
        }
        private Task<bool> StartOcrProcessAsync(CancellationToken cancellationToken)
        {
            Action<int, string> dummyProgress = (percent, message) => { };
            return StartOcrProcessAsync(cancellationToken, dummyProgress);
        }
        private async void AutomaticButton_Click(object sender, RoutedEventArgs e)
        {
            if (!await CheckGoogleAccountsAndShowGuideAsync()) return;
            var (canProcess, message) = await ApiService.TryStartProcessingAsync();
            if (!canProcess)
            {
                CustomMessageBox.Show(message, "Đã đạt giới hạn", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            if (!await EnsureVsfIsAvailableAsync()) return;
            TranslateTab.IsChecked = true;
            _masterCts = new CancellationTokenSource();
            var token = _masterCts.Token;

            _isAutoProcessing = true;
            UpdateUiForProcessing(true);
            bool vsfSuccess = false;
            bool ocrSuccess = false;
            bool srtTranslateSuccess = false;

            try
            {
                VsfService.VsfParameters vsfParams;
                var selectedVideoClips = TimelineClips.Where(c => c.IsSelected && c.ClipType == TimelineClipType.Video).ToList();

                if (selectedVideoClips.Count == 1)
                {
                    var clipVM = selectedVideoClips.First();
                    var mediaAsset = clipVM.SourceData as MediaAsset;
                    if (mediaAsset != null)
                    {
                        vsfParams = GetVsfParametersFromUi();
                        vsfParams.VideoPath = mediaAsset.FilePath;
                        vsfParams.StartTime = mediaAsset.TrimStartOffset.ToString(@"hh\:mm\:ss\:fff");
                        var effectiveDurationInSource = mediaAsset.Duration - mediaAsset.TrimStartOffset - mediaAsset.TrimEndOffset;
                        vsfParams.EndTime = (mediaAsset.TrimStartOffset + effectiveDurationInSource).ToString(@"hh\:mm\:ss\:fff");
                    }
                    else
                    {
                        vsfParams = GetVsfParametersFromUi();
                    }
                }
                else
                {
                    vsfParams = GetVsfParametersFromUi();
                }

                (vsfSuccess, string vsfResultPath) = await _vsfService.RunVSFProcessAsync(vsfParams, token);
                if (!vsfSuccess) throw new Exception("Tìm Sub thất bại. Kiểm tra Log.");
                if (token.IsCancellationRequested) throw new OperationCanceledException();
                ImagesEntry.Text = vsfResultPath;

                ocrSuccess = await StartOcrProcessAsync(token);

                if (!ocrSuccess && !token.IsCancellationRequested) throw new Exception("OCR thất bại. Kiểm tra Log.");
                if (token.IsCancellationRequested) throw new OperationCanceledException();
                if (!SrtSubtitleLinesView.Any(l => !string.IsNullOrWhiteSpace(l.OriginalText) && !l.OriginalText.StartsWith("[Lỗi")))
                {
                    UpdateUiForProcessing(false);
                    CustomMessageBox.Show("Quá trình OCR không tìm thấy văn bản nào để dịch.", "Hoàn tất", MessageBoxButton.OK, MessageBoxImage.Information);
                    throw new InvalidOperationException("OCR did not produce any valid lines.");
                }

                IsSrtTranslating = true;
                await TranslateSrtLogic(token);
                srtTranslateSuccess = !SrtSubtitleLinesView.Any(l => l.TranslatedText != null && _srtErrorMarkers.Contains(l.TranslatedText));
                IsSrtTranslating = false;

                if (srtTranslateSuccess && !string.IsNullOrWhiteSpace(SubtitleEntry.Text))
                {
                    try
                    {
                        SrtFileUtils.SaveToFile(SubtitleEntry.Text, SrtSubtitleLinesView.ToList());
                    }
                    catch (Exception ex)
                    {
                        LogMessage($"[AUTOMATIC] Lỗi lưu file SRT cuối cùng: {ex.Message}", true);
                    }
                }

                if (vsfSuccess && ocrSuccess && srtTranslateSuccess)
                {
                    UpdateUiForProcessing(false);

                }
                else
                {
                    throw new Exception("Một hoặc nhiều bước trong quy trình tự động đã thất bại.");
                }
            }
            catch (InvalidOperationException ocrEx) when (ocrEx.Message.Contains("OCR did not produce"))
            {
                LogMessage("[AUTOMATIC] OCR không tạo ra dòng nào, kết thúc quy trình.");
            }
            catch (OperationCanceledException)
            {
                LogMessage("[AUTOMATIC] Quy trình tự động đã bị hủy bởi người dùng.");
            }
            catch (Exception ex)
            {
                UpdateUiForProcessing(false);
                CustomMessageBox.Show($"Quy trình tự động đã thất bại.\n\nLỗi: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                _isAutoProcessing = false;
                IsSrtTranslating = false;
                UpdateUiForProcessing(false);
                _masterCts?.Dispose();
                _masterCts = null;
            }
        }
        private bool ValidateOcrPrerequisites(out string srtFilePath, out string imagesDirPath)
        {
            srtFilePath = SubtitleEntry.Text;
            imagesDirPath = ImagesEntry.Text;

            if (string.IsNullOrWhiteSpace(srtFilePath))
            {
                string baseName = !string.IsNullOrWhiteSpace(VideoEntry.Text)
                    ? Path.GetFileNameWithoutExtension(VideoEntry.Text)
                    : (!string.IsNullOrWhiteSpace(imagesDirPath) ? new DirectoryInfo(imagesDirPath).Name : "untitled_ocr");
                srtFilePath = Path.Combine(GetResolvedSubtitleOutputDirectory(), $"{baseName}.srt");
                SubtitleEntry.Text = srtFilePath;
            }

            if (string.IsNullOrWhiteSpace(imagesDirPath) || !Directory.Exists(imagesDirPath))
            {
                CustomMessageBox.Show("Thư mục ảnh không có ảnh.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                return false;
            }

            if (_currentOcrMode == OcrMode.GeminiApi && !_geminiApiKeysOcr.Any())
            {
                CustomMessageBox.Show("Chế độ Gemini API OCR yêu cầu API Key. Vui lòng vào Cài đặt.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                return false;
            }

            return true;
        }

        private async Task<List<SrtSubtitleLine>> PrepareSrtViewFromImages(List<string> imageFiles, string srtFilePath, CancellationToken token, int initialTrackIndex, TimeSpan? timeOffset = null, int startIndex = 1)
        {
            if (timeOffset == null)
            {
                await Dispatcher.InvokeAsync(() => {
                    SrtSubtitleLinesView.Clear();
                    _currentSrtFilePath = srtFilePath;
                });
            }

            var newLines = SrtFileUtils.CreateSrtLinesFromImageFiles(imageFiles, timeOffset ?? TimeSpan.Zero, startIndex);
            var projectTemplate = GetTemplateAsStyleState();
            foreach (var srtLine in newLines)
            {
                srtLine.TrackIndex = initialTrackIndex;

                srtLine.Style = projectTemplate.Clone();
                srtLine.Style.Width = null;
                srtLine.Style.FixedTextBoxWidth = 0;
            }
            if (timeOffset == null)
            {
                foreach (var srtLine in newLines)
                {
                    if (token.IsCancellationRequested) break;
                    await Dispatcher.InvokeAsync(() => SrtSubtitleLinesView.Add(srtLine));
                }
            }
            return newLines;
        }
        private async Task<List<string>> PreprocessImagesAsync(List<string> imageFiles, CancellationToken token)
        {
            var filesToOcr = new System.Collections.Concurrent.ConcurrentBag<string>();

            if (_selectedVsfProcessingMode == VsfProcessingMode.CleanAndCreateTxtImages)
            {
                int processedCount = 0;
                await Task.Run(() =>
                {
                    Parallel.ForEach(imageFiles, new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount, CancellationToken = token }, imagePath =>
                    {
                        if (ImageProcessingUtils.CropHorizontalTextRegion(imagePath, imagePath, 128, true) || File.Exists(imagePath))
                        {
                            filesToOcr.Add(imagePath);
                        }
                        Interlocked.Increment(ref processedCount);
                    });
                }, token);
            }
            else
            {
                foreach (var imagePath in imageFiles) filesToOcr.Add(imagePath);
            }

            return filesToOcr.ToList();
        }
        private async Task<bool> RunOcrTasks(
            List<string> imagePathsToProcess,
            string rawTextsDir,
            CancellationToken token,
            Action<int, string> updateProgressAction,
            Dictionary<string, SrtSubtitleLine> pathToLineMap = null,
            bool isBatchMode = false,
            OcrMode? forcedOcrMode = null) // Thêm tham số forcedOcrMode để cố định chế độ
        {
            long totalCompleted = 0;
            bool anyBatchFailed = false;

            try
            {
                if (!string.IsNullOrWhiteSpace(rawTextsDir))
                {
                    Directory.CreateDirectory(rawTextsDir);
                }
            }
            catch (Exception ex)
            {
                if (isBatchMode)
                {
                    LogToBatchPopup($"[OCR] Không thể chuẩn bị thư mục tạm: {ex.Message}");
                }
                else
                {
                    LogMessage($"[OCR] Không thể chuẩn bị thư mục tạm: {ex.Message}", true);
                }
                return false;
            }

            if (pathToLineMap == null)
            {
                pathToLineMap = SrtSubtitleLinesView
                    .Where(l => !string.IsNullOrEmpty(l.ImagePath))
                    .ToDictionary(l => l.ImagePath, l => l);
            }

            // [FIX] Ưu tiên dùng mode truyền vào (từ Batch), nếu không có thì mới lấy từ UI (_currentOcrMode)
            OcrMode effectiveMode = forcedOcrMode ?? _currentOcrMode;

            if (effectiveMode == OcrMode.GeminiApi)
            {
                // --- Giữ nguyên logic Gemini cũ ---
                int batchSize = _geminiImagesPerRequestOcr;
                var batches = imagePathsToProcess
                    .Select((file, index) => new { file, index })
                    .GroupBy(x => x.index / batchSize)
                    .Select(g => g.Select(x => x.file).ToList())
                    .ToList();

                using SemaphoreSlim limiter = new SemaphoreSlim(5);
                var tasks = new List<Task>();
                await Dispatcher.InvokeAsync(() => RebuildOcrServices());

                foreach (var batch in batches)
                {
                    if (token.IsCancellationRequested) break;
                    await limiter.WaitAsync(token);

                    tasks.Add(Task.Run(async () =>
                    {
                        try
                        {
                            var batchResults = await _geminiServiceOcr.ProcessImagesAsync(batch, token);
                            if (token.IsCancellationRequested) return;

                            Action processResult = () =>
                            {
                                foreach (var result in batchResults)
                                {
                                    if (pathToLineMap.TryGetValue(result.imagePath, out var lineToUpdate))
                                    {
                                        if (result.error == null) lineToUpdate.OriginalText = SrtFileUtils.ProcessOcrText(result.ocrText, effectiveMode);
                                        else { lineToUpdate.OriginalText = $"[Lỗi OCR: {result.error}]"; anyBatchFailed = true; }
                                    }
                                }
                            };

                            if (isBatchMode) processResult();
                            else await Dispatcher.InvokeAsync(processResult);

                            Interlocked.Add(ref totalCompleted, batch.Count);
                            int percentage = (int)((double)totalCompleted / imagePathsToProcess.Count * 90) + 10;
                            updateProgressAction?.Invoke(percentage, $"Đang xử lý... {totalCompleted} / {imagePathsToProcess.Count}");
                        }
                        catch (Exception ex)
                        {
                            anyBatchFailed = true;
                            if (isBatchMode) LogToBatchPopup($"Lỗi Gemini: {ex.Message}");
                        }
                        finally { limiter.Release(); }
                    }, token));
                }
                await Task.WhenAll(tasks);
                return !anyBatchFailed && !token.IsCancellationRequested;
            }
            else // Chế độ AIO (Google Cloud)
            {
                await Dispatcher.InvokeAsync(() => RebuildOcrServices());

                if (_googleAccounts == null || !_googleAccounts.Any())
                {
                    if (!isBatchMode) await Dispatcher.InvokeAsync(() => CustomMessageBox.Show("Lỗi", "Chưa cấu hình Google Accounts", MessageBoxButton.OK, MessageBoxImage.Error));
                    return false;
                }

                // 1. Lấy danh sách Account (đã được Random ở hàm SelectActiveAccountsForThisRun sửa bên trên)
                var activeAccounts = SelectActiveAccountsForThisRun();
                if (activeAccounts == null || !activeAccounts.Any()) return false;

                if (isBatchMode) LogToBatchPopup($"[OCR] bắt đầu.");
                else LogMessage($"[OCR] started...");

                // 2. [QUAN TRỌNG] Logic Phân Vùng (Partitioning) y hệt chế độ thường
                // Tạo Dictionary chứa list ảnh cho từng account
                var assignments = new Dictionary<GoogleAccountContext, List<string>>();
                foreach (var acc in activeAccounts)
                {
                    assignments[acc] = new List<string>();
                }

                // Chia bài: Duyệt từng ảnh, chia đều cho các account theo chỉ số i % số_acc
                for (int i = 0; i < imagePathsToProcess.Count; i++)
                {
                    var account = activeAccounts[i % activeAccounts.Count];
                    assignments[account].Add(imagePathsToProcess[i]);
                }

                // 3. Thực thi song song từng Account
                var allAccountTasks = new List<Task>();

                foreach (var kvp in assignments)
                {
                    var account = kvp.Key;
                    var imagesForThisAccount = kvp.Value;
                    if (imagesForThisAccount == null || imagesForThisAccount.Count == 0) continue;

                    // Mỗi Account chạy 1 Task riêng
                    allAccountTasks.Add(Task.Run(async () =>
                    {
                        try
                        {
                            // Gọi Processor của account đó (Bên trong Processor này đã có Semaphore 50 threads như mày nói)
                            var results = await account.OcrProcessor.ProcessBatchAsync(
                                imagesForThisAccount,
                                rawTextsDir,
                                account.DriveFolderId,
                                token
                            );

                            if (token.IsCancellationRequested) return;

                            // Xử lý kết quả trả về
                            Action processResult = () =>
                            {
                                foreach (var result in results)
                                {
                                    if (pathToLineMap.TryGetValue(result.imagePath, out var lineToUpdate))
                                    {
                                        if (result.error == null)
                                        {
                                            lineToUpdate.OriginalText = SrtFileUtils.ProcessOcrText(result.ocrText, effectiveMode);
                                        }
                                        else
                                        {
                                            lineToUpdate.OriginalText = $"[Lỗi OCR: {result.error}]";
                                            anyBatchFailed = true;
                                        }
                                    }
                                }
                            };

                            if (isBatchMode) processResult();
                            else await Dispatcher.InvokeAsync(processResult);

                            long done = Interlocked.Add(ref totalCompleted, results.Count);
                            int percentage = (int)((double)done / imagePathsToProcess.Count * 90) + 10;
                            updateProgressAction?.Invoke(percentage, $"Đang xử lý... {done} / {imagePathsToProcess.Count}");
                        }
                        catch (Exception ex)
                        {
                            anyBatchFailed = true;
                            if (isBatchMode) LogToBatchPopup($"Lỗi account {account.AccountName}: {ex.Message}");
                        }
                    }, token));
                }

                await Task.WhenAll(allAccountTasks);
                return !anyBatchFailed && !token.IsCancellationRequested;
            }
        }
        private void InitializeVsfThreadComboBox()
        {
            try
            {
                int parsedSearch = int.TryParse(_vsfNumThreadsSearch, out var s) ? s : -1;
                int parsedClean = int.TryParse(_vsfNumThreadsClean, out var c) ? c : -1;

                string valueToSelect;
                if (parsedSearch == -1 && parsedClean == -1)
                {
                    valueToSelect = "-1";
                }
                else if (parsedSearch > 0 && parsedSearch == parsedClean)
                {
                    valueToSelect = parsedSearch.ToString();
                }
                else
                {
                    valueToSelect = "-1";
                }

                if (VsfThreadComboBox != null)
                {
                    foreach (var item in VsfThreadComboBox.Items)
                    {
                        if (item is ComboBoxItem cbi && cbi.Tag?.ToString() == valueToSelect)
                        {
                            VsfThreadComboBox.SelectedItem = cbi;
                            return;
                        }
                    }
                    if (VsfThreadComboBox.Items.Count > 0)
                    {
                        VsfThreadComboBox.SelectedIndex = 0;
                    }
                }
            }
            catch
            {
            }
        }
        private void VsfThreadComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            try
            {
                if (!(sender is ComboBox cb) || !this.IsLoaded) return;
                int selectedThreads;
                string tag = (cb.SelectedItem as ComboBoxItem)?.Tag?.ToString();

                if (string.Equals(tag, "-1", StringComparison.OrdinalIgnoreCase))
                {
                    selectedThreads = EstimateRecommendedThreadCountForVsf();
                    if (VsfThreadNoteText != null)
                    {
                        VsfThreadNoteText.Text = $"Tự động: {selectedThreads} luồng.";
                    }
                }
                else
                {
                    if (!int.TryParse(tag, out selectedThreads)) selectedThreads = 2;
                    if (VsfThreadNoteText != null)
                    {
                        VsfThreadNoteText.Text = "";
                    }
                }
                _vsfNumThreadsSearch = selectedThreads.ToString();
                _vsfNumThreadsClean = selectedThreads.ToString();
                SaveConfiguration();
            }
            catch { }
        }
        private int EstimateRecommendedThreadCountForVsf()
        {
            try
            {
                int logicalProcessorCount = Environment.ProcessorCount;
                int[] allowedThreads = new[] { 2, 4, 6, 8, 12, 16 };
                int targetThreads = Math.Max(2, logicalProcessorCount / 2);
                int recommendedThreads = allowedThreads
                    .Where(threads => threads <= targetThreads)
                    .DefaultIfEmpty(2)
                    .Max();

                return recommendedThreads;
            }
            catch
            {
                return 4;
            }
        }

        private List<GoogleAccountContext> SelectActiveAccountsForThisRun()
        {
            if (_googleAccounts == null || _googleAccounts.Count == 0)
            {
                return new List<GoogleAccountContext>();
            }
            int recommendedAccounts = Math.Clamp(Environment.ProcessorCount, 2, 4); // Tối đa 4-6 account
            int takeCount = Math.Min(recommendedAccounts, _googleAccounts.Count);
            var selected = _googleAccounts.OrderBy(x => Guid.NewGuid()).Take(takeCount).ToList();
            return selected;
        }

        private void RebuildOcrServices()
        {
            _geminiServiceOcr = new GeminiOcrService(_geminiApiKeysOcr, _geminiRequestsPerMinuteOcr, _geminiEnableMultiKeyOcr, _selectedGeminiModelOcr)
            {
                LogMessage = (msg) => LogMessage(msg)
            };
            LoadGoogleAccounts();
        }
        public class NaturalStringComparer : IComparer<string>
        {
            private static readonly Regex _numberRegex = new Regex(@"\d+", RegexOptions.Compiled);

            public int Compare(string x, string y)
            {
                if (x == null) return y == null ? 0 : -1;
                if (y == null) return 1;

                var xParts = _numberRegex.Split(x);
                var yParts = _numberRegex.Split(y);

                int minParts = Math.Min(xParts.Length, yParts.Length);
                for (int i = 0; i < minParts; i++)
                {
                    int comparison = string.Compare(xParts[i], yParts[i], StringComparison.OrdinalIgnoreCase);
                    if (comparison != 0) return comparison;

                    if (i < xParts.Length - 1 && i < yParts.Length - 1)
                    {
                        var xNumber = ExtractNumber(x, i);
                        var yNumber = ExtractNumber(y, i);

                        comparison = xNumber.CompareTo(yNumber);
                        if (comparison != 0) return comparison;
                    }
                }

                return xParts.Length.CompareTo(yParts.Length);
            }

            private static int ExtractNumber(string input, int index)
            {
                var match = _numberRegex.Match(input, index);
                return match.Success ? int.Parse(match.Value) : 0;
            }
        }

        #endregion
        #region DataGrid Context Menu Logic (OCR/Translate Retry)
        private void DataGridRow_ContextMenuOpening(object sender, ContextMenuEventArgs e)
        {
            if (!(sender is DataGridRow row) || !(row.DataContext is SrtSubtitleLine srtLineOver))
            {
                e.Handled = true;
                return;
            }

            var rowContextMenu = new ContextMenu();
            var selectedItems = SrtLinesDataGrid.SelectedItems.Cast<SrtSubtitleLine>().ToList();
            bool isCurrentRowSelected = selectedItems.Contains(srtLineOver);
            if (!string.IsNullOrWhiteSpace(srtLineOver.OriginalText))
            {
                MenuItem retrySingle = new MenuItem { Header = $"Dịch lại dòng {srtLineOver.Index}", DataContext = srtLineOver };
                retrySingle.Click += RetryTranslateSingleSrtLine_Click;
                rowContextMenu.Items.Add(retrySingle);
            }
            if (selectedItems.Count > 1 && isCurrentRowSelected)
            {
                var validItemsToTranslate = selectedItems.Where(l => !string.IsNullOrWhiteSpace(l.OriginalText)).ToList();
                if (validItemsToTranslate.Any())
                {
                    MenuItem retrySelected = new MenuItem { Header = $"Dịch lại {validItemsToTranslate.Count} dòng đã chọn" };
                    retrySelected.Click += RetryTranslateSelectedSrtLines_Click;
                    rowContextMenu.Items.Add(retrySelected);
                }
            }
            bool hasOcrableItems = false;
            if (!string.IsNullOrWhiteSpace(srtLineOver.ImagePath) && File.Exists(srtLineOver.ImagePath))
            {
                if (rowContextMenu.HasItems) rowContextMenu.Items.Add(new Separator());
                MenuItem ocrSingle = new MenuItem { Header = $"OCR lại dòng {srtLineOver.Index}", DataContext = srtLineOver };
                ocrSingle.Click += ReOcrSingleSrtLine_Click;
                rowContextMenu.Items.Add(ocrSingle);
                hasOcrableItems = true;
            }
            if (selectedItems.Count > 1 && isCurrentRowSelected)
            {
                var validItemsToOcr = selectedItems.Where(l => !string.IsNullOrWhiteSpace(l.ImagePath) && File.Exists(l.ImagePath)).ToList();
                if (validItemsToOcr.Any())
                {
                    if (!hasOcrableItems && rowContextMenu.HasItems) rowContextMenu.Items.Add(new Separator());
                    MenuItem ocrSelected = new MenuItem { Header = $"OCR lại {validItemsToOcr.Count} dòng đã chọn" };
                    ocrSelected.Click += ReOcrSelectedSrtLines_Click;
                    rowContextMenu.Items.Add(ocrSelected);
                }
            }
            row.ContextMenu = rowContextMenu.HasItems ? rowContextMenu : null;
        }
        private async void RetryTranslateSingleSrtLine_Click(object sender, RoutedEventArgs e)
        {
            if (sender is MenuItem menuItem && menuItem.DataContext is SrtSubtitleLine lineToRetry)
            {
                await RunTranslationForSpecificLines(new List<SrtSubtitleLine> { lineToRetry });
            }
        }

        private async void RetryTranslateSelectedSrtLines_Click(object sender, RoutedEventArgs e)
        {
            var linesToRetry = SrtLinesDataGrid.SelectedItems.Cast<SrtSubtitleLine>()
                                 .Where(l => !string.IsNullOrWhiteSpace(l.OriginalText))
                                 .ToList();
            if (linesToRetry.Any())
            {
                await RunTranslationForSpecificLines(linesToRetry);
            }
        }

        private async void ReOcrSingleSrtLine_Click(object sender, RoutedEventArgs e)
        {
            if (sender is MenuItem menuItem && menuItem.DataContext is SrtSubtitleLine lineToOcr)
            {
                await RunOcrForSpecificLines(new List<SrtSubtitleLine> { lineToOcr });
            }
        }

        private async void ReOcrSelectedSrtLines_Click(object sender, RoutedEventArgs e)
        {
            var linesToOcr = SrtLinesDataGrid.SelectedItems.Cast<SrtSubtitleLine>().ToList();
            if (linesToOcr.Any())
            {
                await RunOcrForSpecificLines(linesToOcr);
            }
        }
        private async Task RunTranslationForSpecificLines(List<SrtSubtitleLine> linesToTranslate)
        {
            if (IsSrtTranslating)
            {
                CustomMessageBox.Show("Một tác vụ dịch đang chạy, vui lòng chờ hoàn tất.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }
            _masterCts = new CancellationTokenSource();
            IsSrtTranslating = true;
            UpdateUiForProcessing(true);

            try
            {
                foreach (var line in linesToTranslate) line.TranslatedText = "[Đang dịch lại...]";
                await TranslateSrtLogic(_masterCts.Token, linesToTranslate);
            }
            finally
            {
                IsSrtTranslating = false;
                UpdateUiForProcessing(false);
                _masterCts?.Dispose();
                _masterCts = null;
            }
        }
        private async Task RunOcrForSpecificLines(List<SrtSubtitleLine> linesToOcr)
        {
            if (_isAutoProcessing || IsSrtTranslating)
            {
                CustomMessageBox.Show("Một tác vụ khác đang chạy. Vui lòng chờ hoàn tất.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }
            var validLines = linesToOcr
                .Where(l => !string.IsNullOrWhiteSpace(l.ImagePath) && File.Exists(l.ImagePath))
                .ToList();

            if (!validLines.Any())
            {
                return;
            }
            UpdateUiForProcessing(true);
            _masterCts = new CancellationTokenSource();

            try
            {
                foreach (var line in validLines)
                {
                    line.OriginalText = "[Đang OCR lại...]";
                }
                string rawTextsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "raw_texts_re_ocr");
                if (Directory.Exists(rawTextsDir)) Directory.Delete(rawTextsDir, true);
                Directory.CreateDirectory(rawTextsDir);

                var imagePaths = validLines.Select(l => l.ImagePath).ToList();
                Action<int, string> dummyUpdateProgressAction = (percent, message) => {
                };
                bool ocrSuccess = await RunOcrTasks(imagePaths, rawTextsDir, _masterCts.Token, dummyUpdateProgressAction);
                UpdateUiForProcessing(false);
                if (ocrSuccess && !_masterCts.IsCancellationRequested)
                {
                    CustomMessageBox.Show("Hoàn tất OCR lại các dòng đã chọn.", "Thành công", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                else
                {
                    CustomMessageBox.Show("Quá trình OCR lại đã bị hủy hoặc gặp lỗi.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
            catch (Exception ex)
            {
                UpdateUiForProcessing(false);
                CustomMessageBox.Show($"Lỗi nghiêm trọng khi OCR lại: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                UpdateUiForProcessing(false);
                _masterCts?.Dispose();
                _masterCts = null;
            }
        }
        #endregion
        #region Timeline, Waveform & Volume Logic (New Implementation)

        private void TimelineScrollViewer_PreviewMouseWheel(object sender, MouseWheelEventArgs e)
        {
            if (Keyboard.Modifiers == ModifierKeys.Control)
            {
                e.Handled = true;

                double newPixelsPerSecond;
                if (e.Delta > 0)
                {
                    newPixelsPerSecond = this._pixelsPerSecond * ZOOM_STEP;
                }
                else
                {
                    newPixelsPerSecond = this._pixelsPerSecond / ZOOM_STEP;
                }
                UpdateZoom(newPixelsPerSecond, e);
            }
        }
        private double GetDynamicMinPixelsPerSecond()
        {
            if (_totalTimelineDuration.TotalSeconds <= 0 || TimelineScrollViewer.ViewportWidth <= 0)
                return MIN_PIXELS_PER_SECOND;
            double fitAll = TimelineScrollViewer.ViewportWidth / _totalTimelineDuration.TotalSeconds;
            double softLowerBound = Math.Max(0.01, fitAll * 0.95);
            return Math.Min(MIN_PIXELS_PER_SECOND, softLowerBound);
        }
        private void UpdateZoom(double newPixelsPerSecond, MouseWheelEventArgs e)
        {
            if (_totalTimelineDuration.TotalSeconds <= 0 || !IsLoaded) return;
            double oldPixelsPerSecond = this._pixelsPerSecond;
            if (Math.Abs(oldPixelsPerSecond) < 0.001) return;
            double minDyn = GetDynamicMinPixelsPerSecond();
            double clampedPps = Math.Clamp(newPixelsPerSecond, minDyn, MAX_PIXELS_PER_SECOND);
            System.Windows.Point mousePosInViewport = e.GetPosition(TimelineScrollViewer);
            double mouseAbsoluteX_Before = TimelineScrollViewer.HorizontalOffset + mousePosInViewport.X;
            TimeSpan timeAtMouse = TimeSpan.FromSeconds(mouseAbsoluteX_Before / oldPixelsPerSecond);
            this._pixelsPerSecond = clampedPps;
            double mouseAbsoluteX_After = timeAtMouse.TotalSeconds * this._pixelsPerSecond;
            double newScrollOffset = mouseAbsoluteX_After - mousePosInViewport.X;
            TimelineScrollViewer.ScrollToHorizontalOffset(Math.Max(0, newScrollOffset));
            UpdateTimelineScaleAndRender();
        }
        void TimelineScrollViewer_ScrollChanged(object sender, ScrollChangedEventArgs e)
        {
            if (e.HorizontalChange != 0 || e.ViewportWidthChange != 0 || e.ExtentWidthChange != 0)
            {
                _scrollDirty = true;
                if (!_scrollRenderDebounce.IsEnabled)
                    _scrollRenderDebounce.Start();
            }
        }
        private void UpdatePositionMarkerVisuals()
        {
            if (this._pixelsPerSecond <= 0 || TracksContainerGrid.ActualWidth <= 0 || _totalTimelineDuration.Ticks <= 0)
            {
                PositionMarkerThumb.Visibility = Visibility.Collapsed;
                return;
            }

            double absoluteX = _playhead.TotalSeconds * this._pixelsPerSecond;
            double visualX = absoluteX - TimelineScrollViewer.HorizontalOffset;

            if (double.IsNaN(visualX) || double.IsInfinity(visualX))
            {
                PositionMarkerThumb.Visibility = Visibility.Collapsed;
                return;
            }
            PositionMarkerThumb.Visibility = Visibility.Visible;
            if (PositionMarkerThumb.RenderTransform is TranslateTransform t)
            {
                t.X = visualX;
                t.Y = 0;
            }
            else
            {
                PositionMarkerThumb.RenderTransform = new TranslateTransform(visualX, 0);
            }
        }
        private void UpdatePlaybackUI(TimeSpan currentTime)
        {
            currentTimeTextBlock.Text = currentTime.ToString(@"hh\:mm\:ss\.fff");
            totalDurationTextBlock.Text = _actualContentDuration > TimeSpan.Zero ? _actualContentDuration.ToString(@"hh\:mm\:ss\.fff") : "00:00:00.000";
            UpdatePositionMarkerVisuals();
        }
        private TimeSpan ComputePositionInClip(TimeSpan timelineTime, TimelineClipViewModel clip)
        {
            if (clip == null) return TimeSpan.Zero;
            var pos = timelineTime - clip.StartTime;
            if (pos < TimeSpan.Zero) pos = TimeSpan.Zero;
            if (clip.SourceData is MediaAsset ma)
                pos = pos + ma.TrimStartOffset;

            var clipDur = clip.Duration;
            var guard = TimeSpan.FromMilliseconds(40);
            if (clipDur <= guard) return TimeSpan.Zero;
            if (pos > clipDur - guard) pos = clipDur - guard;
            if (pos < TimeSpan.Zero) pos = TimeSpan.Zero;
            return pos;
        }
        private async void FFMEPlayer_MediaEnded(object sender, EventArgs e)
        {
        }
        
        private async void FFMEPlayer_MediaOpened(object sender, Unosquare.FFME.Common.MediaOpenedEventArgs e)
        {
        }

        private void FFMEPlayer_PositionChanged(object sender, Unosquare.FFME.Common.PositionChangedEventArgs e)
        {
        }

        private void SelectedClip_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (_isSuppressingTimelineUpdate) return; // Don't handle property changes during undo/redo
            var changedAsset = sender as MediaAsset;
            if (changedAsset == null) return;
            var selectedClips = TimelineClips
                .Where(c => c.IsSelected && c.SourceData is MediaAsset)
                .ToList();
            if (!selectedClips.Any()) return;
            var transformProperties = new[] { nameof(MediaAsset.Scale), nameof(MediaAsset.ScaleX), nameof(MediaAsset.ScaleY), nameof(MediaAsset.PositionX), nameof(MediaAsset.PositionY), nameof(MediaAsset.Rotation), nameof(MediaAsset.IsUniformScale), nameof(MediaAsset.Speed), nameof(MediaAsset.VolumeDb) };
            if (!transformProperties.Contains(e.PropertyName)) return;
            object newValue = e.PropertyName switch
            {
                nameof(MediaAsset.Scale) => changedAsset.Scale,
                nameof(MediaAsset.ScaleX) => changedAsset.ScaleX,
                nameof(MediaAsset.ScaleY) => changedAsset.ScaleY,
                nameof(MediaAsset.PositionX) => changedAsset.PositionX,
                nameof(MediaAsset.PositionY) => changedAsset.PositionY,
                nameof(MediaAsset.Rotation) => changedAsset.Rotation,
                nameof(MediaAsset.IsUniformScale) => changedAsset.IsUniformScale,
                nameof(MediaAsset.Speed) => changedAsset.Speed,
                nameof(MediaAsset.VolumeDb) => changedAsset.VolumeDb,
                _ => null
            };
            if (newValue == null) return;
            foreach (var clipVM in selectedClips)
            {
                if (clipVM.SourceData is MediaAsset asset && asset != changedAsset)
                {
                    switch (e.PropertyName)
                    {
                        case nameof(MediaAsset.IsUniformScale): asset.IsUniformScale = (bool)newValue; break;
                        case nameof(MediaAsset.Scale): asset.Scale = (double)newValue; break;
                        case nameof(MediaAsset.ScaleX): asset.ScaleX = (double)newValue; break;
                        case nameof(MediaAsset.ScaleY): asset.ScaleY = (double)newValue; break;
                        case nameof(MediaAsset.Speed): asset.Speed = (double)newValue; break;
                        case nameof(MediaAsset.VolumeDb): asset.VolumeDb = (double)newValue; break;
                    }
                }
            }
            foreach (var clipVM in selectedClips)
            {
                if (clipVM.SourceData is MediaAsset asset)
                {
                    if (asset.Type == AssetType.Video)
                    {
                        UpdateVideoTransform(asset);
                        _audioEngine?.UpdateClipProperties(clipVM);
                    }
                    else if (asset.Type == AssetType.Image)
                    {
                        if (_activeImageOverlays.TryGetValue(asset, out var imageVisual))
                        {
                            ApplyTransformToImageVisual(imageVisual, asset);
                            _imageAdorner?.InvalidateVisual();
                        }
                    }
                    if (e.PropertyName == nameof(MediaAsset.Speed))
                    {
                        clipVM.RefreshPropertiesFromSource();
                    }
                }
            }

            if (e.PropertyName == nameof(MediaAsset.Speed))
            {
                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();
            }
        }
        private async void TimelineScrollViewer_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            try
            {
                var seekId = Guid.NewGuid().ToString("N").Substring(0, 8);
                if (_totalTimelineDuration.TotalSeconds <= 0)
                    return;
                var original = e.OriginalSource as DependencyObject;
                if (original != null)
                {
                    if (FindVisualParent<Thumb>(original) != null ||
                        FindVisualParent<System.Windows.Controls.Primitives.ScrollBar>(original) != null)
                    {
                        return;
                    }
                }
                if (_isSwitchingVideoSource || _isExplicitSeekInProgress)
                {
                    e.Handled = true;
                    return;
                }

                double absoluteClickX = e.GetPosition(TracksContainerGrid).X;
                if (absoluteClickX < 0) absoluteClickX = 0;

                var clickedTime = TimeSpan.FromSeconds(absoluteClickX / _pixelsPerSecond);

                e.Handled = true;
                await SeekTimeline(clickedTime, seekId); 
            }
            catch (Exception ex)
            {
            }
        }
        #endregion

        #region Waveform & Ruler Drawing (New)
        public string GetFfmpegVolumeArgument()
        {
            if (_mainAudioTrack != null && Math.Abs(_mainAudioTrack.VolumeDb) > 0.05)
            {
                string volumeArg = _mainAudioTrack.VolumeDb.ToString(System.Globalization.CultureInfo.InvariantCulture);
                string ffmpegArg = $"-af \"volume={volumeArg}dB\"";
                return ffmpegArg;
            }
            return string.Empty;
        }
        private void PositionMarker_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e) { }


        private void TimelineContainerGrid_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e) { }
        private void InitializeSubtitleStyler()
        {
            var controls = new Dictionary<string, FrameworkElement>
    {
        { "fontFamilyComboBox", FontFamilyComboBox },
        { "fontSizeSlider", FontSizeSlider },
        { "fontSizeTextBox", FontSizeTextBox },
        { "fontColorPicker", FontColorPicker },
        { "boldButton", BoldButton },
        { "italicButton", ItalicButton },
        { "underlineButton", UnderlineButton },
        { "characterSpacingSlider", CharacterSpacingSlider },
        { "backgroundSettingsPanel", BackgroundSettingsPanel },
        { "backgroundEnabledCheckBox", BackgroundEnabledCheckBox },
        { "backgroundColorPicker", BackgroundColorPicker },
        { "backgroundOpacitySlider", BackgroundOpacitySlider },
        { "backgroundCornerRadiusSlider", BackgroundCornerRadiusSlider },
        { "backgroundPaddingXSlider", BackgroundPaddingXSlider },
        { "backgroundPaddingYSlider", BackgroundPaddingYSlider },
        { "outlineEnabledCheckBox", OutlineEnabledCheckBox },
        { "shadowEnabledCheckBox", ShadowEnabledCheckBox },
        { "outlineSettingsPanel", OutlineSettingsPanel },
        { "shadowSettingsPanel", ShadowSettingsPanel },
        { "outlineColorPicker", OutlineColorPicker },
        { "outlineThicknessSlider", OutlineThicknessSlider },
        { "shadowColorPicker", ShadowColorPicker },
        { "shadowOpacitySlider", ShadowOpacitySlider },
        { "shadowBlurSlider", ShadowBlurSlider },
        { "shadowDepthSlider", ShadowDepthSlider },
        { "shadowDirectionSlider", ShadowDirectionSlider }
    };

        }
        private void DrawRuler(double pixelsPerSecond)
        {
            if (TimelineRulerHost == null || !TimelineRulerHost.IsVisible)
            {
                return;
            }

            _timelineRulerVisual.Redraw(
                pixelsPerSecond,
                TimelineScrollViewer.HorizontalOffset,
                TimelineScrollViewer.ViewportWidth,
                _totalTimelineDuration,
                _actualContentDuration);
        }

        #endregion
        private sealed class OverlayGeometry
        {
            public int W { get; set; }
            public int H { get; set; }
            public double X { get; set; }
            public double Y { get; set; }
        }
        private void ExportButton_Click(object sender, RoutedEventArgs e)
        {
            if (_actualContentDuration.TotalSeconds <= 0)
            {
                MessageBox.Show("Timeline trống hoặc không hợp lệ, không thể xuất video.", "Lỗi Timeline", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            if (!TimelineClips.Any(c => c.ClipType == TimelineClipType.Video || c.ClipType == TimelineClipType.Image))
            {
                MessageBox.Show("Timeline phải chứa ít nhất một clip Video hoặc Ảnh để có thể xuất.", "Thiếu nội dung hình ảnh", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var firstVideo = TimelineClips.FirstOrDefault(c => c.ClipType == TimelineClipType.Video);
            int defaultWidth = 1280;
            int defaultHeight = 720;

            if (firstVideo != null && firstVideo.SourceData is MediaAsset sourceAsset)
            {
                defaultWidth = sourceAsset.Width;
                defaultHeight = sourceAsset.Height;
            }

            var config = IniConfig.Load(_settingsFilePath);
            string lastGpu = config.GetValue("settings_export", "Last_Gpu_Accel", "auto");
            bool lastThreadLimitEnabled = config.GetBooleanValue("settings_export", "Last_Thread_Limit_Enabled", false);
            int lastThreadLimit = int.TryParse(config.GetValue("settings_export", "Last_Thread_Limit", "0"), out int threads) ? threads : 0;

            var exportWindow = new GenerateVideoWindow(
                _currentProject.ProjectName,
                _lastExportPath,
                defaultWidth,
                defaultHeight,
                _actualContentDuration,
                lastGpu,
                lastThreadLimitEnabled,
                lastThreadLimit
            )
            { Owner = this };

            exportWindow.OnGenerateClicked += async (settings) =>
            {
                _lastExportPath = settings.OutputPath;

                if (!config.ContainsKey("settings_export"))
                {
                    config["settings_export"] = new Dictionary<string, string>();
                }
                config["settings_export"]["Last_Gpu_Accel"] = settings.GpuAcceleration;
                config["settings_export"]["Last_Thread_Limit_Enabled"] = settings.IsThreadLimitEnabled.ToString();
                config["settings_export"]["Last_Thread_Limit"] = settings.ThreadLimit.ToString();
                IniConfig.Save(_settingsFilePath, config);

                SaveConfiguration();
                await ExecuteVideoExportAsync(settings, exportWindow);
            };

            exportWindow.Show();
        }
        private sealed class SmartCutMapItem
        {
            public SrtSubtitleLine Line { get; init; }
            public TimeSpan FinalStart { get; init; }
            public TimeSpan FinalEnd { get; init; }
        }

        private async Task<List<SmartCutMapItem>> BuildSmartCutTimelineForDynamicVideo()
        {
            var mapItems = await BuildSmartCutMapItemsAsync();
            return mapItems.OrderBy(i => i.FinalStart).ToList();
        }
        private static bool FileNameLooksLikeTts(string fileNameWithoutExt)
        {
            if (string.IsNullOrWhiteSpace(fileNameWithoutExt)) return false;
            if (System.Text.RegularExpressions.Regex.IsMatch(
                    fileNameWithoutExt,
                    @"^(?<idx>\d{1,5})(?:\D|_|$)",
                    System.Text.RegularExpressions.RegexOptions.IgnoreCase))
            {
                return true;
            }
            if (System.Text.RegularExpressions.Regex.IsMatch(
                    fileNameWithoutExt,
                    @"_(\d{6,})_(\d{6,})(?:\D|$)",
                    System.Text.RegularExpressions.RegexOptions.IgnoreCase))
            {
                return true;
            }
            if (System.Text.RegularExpressions.Regex.IsMatch(
                    fileNameWithoutExt,
                    @"\b(tts|voice[_\-]?sub|narration)\b",
                    System.Text.RegularExpressions.RegexOptions.IgnoreCase))
            {
                return true;
            }

            return false;
        }

        private static bool PathLooksLikeProjectTts(string absolutePath)
        {
            if (string.IsNullOrWhiteSpace(absolutePath)) return false;
            var marker = System.IO.Path.DirectorySeparatorChar + "Projects" + System.IO.Path.DirectorySeparatorChar + "TTS" + System.IO.Path.DirectorySeparatorChar;
            return absolutePath.IndexOf(marker, System.StringComparison.OrdinalIgnoreCase) >= 0;
        }

        private static bool IsLikelyTtsClip(TimelineAudioClip clip, IReadOnlyList<SrtSubtitleLine> allSrtLines)
        {
            if (clip == null || string.IsNullOrWhiteSpace(clip.FilePath) || !System.IO.File.Exists(clip.FilePath))
                return false;
            if (clip.IsTts) return true;
            if (clip.SourceSubtitleIndexSnapshot.HasValue) return true;
            if (!string.IsNullOrWhiteSpace(clip.CaptionTextSnapshot)) return true;
            var name = System.IO.Path.GetFileNameWithoutExtension(clip.FilePath);
            if (FileNameLooksLikeTts(name)) return true;
            if (PathLooksLikeProjectTts(clip.FilePath)) return true;
            if (allSrtLines != null && allSrtLines.Count > 0)
            {
                var isExactMatch = allSrtLines.Any(l =>
                    !string.IsNullOrWhiteSpace(l.VoicedAudioPath) &&
                    string.Equals(l.VoicedAudioPath, clip.FilePath, System.StringComparison.OrdinalIgnoreCase));
                if (isExactMatch) return true;
            }
            return false;
        }

        /// <summary>
        /// Lấy danh sách index của subtitle/text clips thực sự có trên timeline.
        /// Sử dụng cho việc lọc phụ đề trong chế độ StaticReview.
        /// </summary>
        private HashSet<int> GetTimelineSubtitleIndices()
        {
            return TimelineClips
                .Where(c => (c.ClipType == TimelineClipType.Subtitle || c.ClipType == TimelineClipType.Text) 
                    && c.SourceData is SrtSubtitleLine)
                .Select(c => ((SrtSubtitleLine)c.SourceData).Index)
                .ToHashSet();
        }

        /// <summary>
        /// Kiểm tra xem timeline có chứa phụ đề (Subtitle) hoặc text clip hay không.
        /// Ưu tiên kiểm tra TimelineClips vì đây là dữ liệu thực tế sau khi user chỉnh sửa timeline.
        /// Phương thức này được sử dụng để quyết định có tạo file ASS khi xuất video hay không.
        /// </summary>
        /// <returns>True nếu có ít nhất một phụ đề hoặc text clip trên timeline, ngược lại False</returns>
        private bool HasSubtitlesOrTextOnTimeline()
        {
            // Ưu tiên kiểm tra TimelineClips vì đây là dữ liệu thực tế trên timeline
            // User có thể đã xóa phụ đề khỏi timeline, trong trường hợp này họ không muốn burn subtitle
            var timelineSubsOrText = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Subtitle || c.ClipType == TimelineClipType.Text)
                .Select(c => c.SourceData as SrtSubtitleLine)
                .Where(s => s != null && !string.IsNullOrWhiteSpace(s.OriginalText))
                .ToList();

            if (timelineSubsOrText.Any())
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Kiểm tra xem danh sách phụ đề được truyền vào cho smart cut có entries hay không.
        /// Kết hợp cả smartCutTimeline và TextClips từ project.
        /// 
        /// LƯU Ý QUAN TRỌNG: Trong chế độ StaticReview, subtitleTimeline được tạo từ voice/TTS mapping
        /// để xử lý giãn/ghép video theo voice. Tuy nhiên, quyết định có burn phụ đề hay không
        /// phải dựa vào những gì thực sự có trên timeline (user có thể đã xóa phụ đề khỏi timeline
        /// để xuất video không có phụ đề).
        /// </summary>
        private bool HasSubtitlesForSmartCutExport(List<(SrtSubtitleLine Line, TimeSpan FinalStart, TimeSpan FinalEnd)> smartCutTimeline)
        {
            // Trong chế độ StaticReview, chỉ kiểm tra những phụ đề thực sự có trên timeline
            // KHÔNG dựa vào smartCutTimeline vì nó được tạo từ voice/TTS mapping cho mục đích timing
            if (_currentSmartCutMode == SmartCutMode.StaticReview)
            {
                // Lấy danh sách index của subtitle/text thực sự có trên timeline
                var timelineSubtitleIndices = GetTimelineSubtitleIndices();

                // Kiểm tra trong smartCutTimeline có entries nào match với timeline không
                // Filter by non-empty OriginalText first for better performance
                if (smartCutTimeline != null)
                {
                    var hasMatchingSubtitles = smartCutTimeline
                        .Where(item => !string.IsNullOrWhiteSpace(item.Line.OriginalText))
                        .Any(item => timelineSubtitleIndices.Contains(item.Line.Index));
                    if (hasMatchingSubtitles)
                    {
                        return true;
                    }
                }

                // Kiểm tra TextClips có trên timeline không
                if (_currentProject?.TextClips != null)
                {
                    var hasTextClipsOnTimeline = _currentProject.TextClips
                        .Where(tc => !string.IsNullOrWhiteSpace(tc.OriginalText))
                        .Any(tc => timelineSubtitleIndices.Contains(tc.Index));
                    if (hasTextClipsOnTimeline)
                    {
                        return true;
                    }
                }

                return false;
            }

            // Các chế độ khác: giữ nguyên logic cũ
            // Kiểm tra smartCutTimeline có entries không
            if (smartCutTimeline != null && smartCutTimeline.Any())
            {
                return true;
            }

            // Kiểm tra TextClips trong project (ngoài smartCutTimeline)
            if (_currentProject?.TextClips != null)
            {
                var hasTextClips = _currentProject.TextClips.Any(tc => !string.IsNullOrWhiteSpace(tc.OriginalText));
                if (hasTextClips)
                {
                    return true;
                }
            }

            return false;
        }

        private (List<TimelineAudioClip> ttsClips, List<TimelineAudioClip> bgFxClips) ClassifyAudioClipsForExport()
        {
            var allSrt = (_currentProject?.Subtitles ?? new List<SrtSubtitleLine>())
                         .Concat(_currentProject?.TextClips ?? new List<SrtSubtitleLine>())
                         .ToList();
            var timelineAudios = _currentProject?.VoicedSubtitles ?? new List<TimelineAudioClip>();
            var all = timelineAudios
                        .GroupBy(c => c.FilePath, StringComparer.OrdinalIgnoreCase)
                        .Select(g => g.First())
                        .Where(c => !string.IsNullOrWhiteSpace(c.FilePath) && System.IO.File.Exists(c.FilePath))
                        .ToList();

            var tts = new List<TimelineAudioClip>();
            var bg = new List<TimelineAudioClip>();
            foreach (var clip in all)
            {
                if (IsLikelyTtsClip(clip, allSrt))
                {
                    tts.Add(clip);
                }
                else
                {
                    bg.Add(clip);
                }
            }
            return (tts, bg);
        }

        private Dictionary<TimelineAudioClip, (TimeSpan Start, TimeSpan End)> ResolveTtsPlacementsForDynamic(
            List<TimelineAudioClip> ttsClips,
            List<(SrtSubtitleLine Line, TimeSpan FinalStart, TimeSpan FinalEnd)> smartCutTimeline)
        {
            var map = new Dictionary<TimelineAudioClip, (TimeSpan, TimeSpan)>();

            static string Norm(string s) => string.IsNullOrWhiteSpace(s) ? "" :
                System.Text.RegularExpressions.Regex.Replace(s, @"\s+", " ").Trim();

            foreach (var clip in ttsClips)
            {
                if (clip.SourceSubtitleIndexSnapshot.HasValue)
                {
                    var hit = smartCutTimeline.FirstOrDefault(x => x.Line.Index == clip.SourceSubtitleIndexSnapshot.Value);
                    if (hit.Line != null)
                    {
                        map[clip] = (hit.FinalStart, hit.FinalEnd);
                        continue;
                    }
                }
                if (!string.IsNullOrWhiteSpace(clip.CaptionTextSnapshot))
                {
                    var normalizedSnapshot = Norm(clip.CaptionTextSnapshot);
                    var hit = smartCutTimeline.FirstOrDefault(x =>
                        string.Equals(Norm(x.Line.OriginalText), normalizedSnapshot, StringComparison.OrdinalIgnoreCase) ||
                        Norm(x.Line.OriginalText).Contains(normalizedSnapshot));
                    if (hit.Line != null)
                    {
                        map[clip] = (hit.FinalStart, hit.FinalEnd);
                        continue;
                    }
                }
                var dur = clip.EffectiveDuration;
                map[clip] = (clip.StartTime, clip.StartTime + dur);
            }
            return map;
        }
        private async Task RunSmartCutDynamicPass2Async(string ffmpegPath, MediaAsset mainVideoAsset, string pass1WavPath, string tempAssPath, VideoExportSettings settings, GenerateVideoWindow progressWindow, CancellationToken cancellationToken)
        {
            if (mainVideoAsset == null || string.IsNullOrWhiteSpace(mainVideoAsset.FilePath) || !File.Exists(mainVideoAsset.FilePath))
                throw new FileNotFoundException("Không tìm thấy video chính cho pass 2.");
            if (string.IsNullOrWhiteSpace(pass1WavPath) || !File.Exists(pass1WavPath))
                throw new FileNotFoundException("Không tìm thấy WAV pass 1.");
            if (string.IsNullOrWhiteSpace(tempAssPath) || !File.Exists(tempAssPath))
                throw new FileNotFoundException("Không tìm thấy file ASS tạm.");
            var args = new StringBuilder();
            var inputMap = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            int inputIndex = 0;
            args.Append("-y -hide_banner ");
            args.Append($"-i \"{mainVideoAsset.FilePath}\" ");
            inputMap[mainVideoAsset.FilePath] = inputIndex++;
            args.Append($"-i \"{pass1WavPath}\" ");
            inputMap[pass1WavPath] = inputIndex++;
            int wavInputIndex = inputMap[pass1WavPath];
            var imageClips = TimelineClips.Where(c => c.ClipType == TimelineClipType.Image && c.SourceData is MediaAsset).ToList();
            var distinctImages = imageClips
                .Select(c => ((MediaAsset)c.SourceData).FilePath)
                .Where(p => !string.IsNullOrWhiteSpace(p))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToList();

            foreach (var imgPath in distinctImages)
            {
                args.Append($"-stream_loop -1 -i \"{imgPath}\" ");
                inputMap[imgPath] = inputIndex++;
            }
            var (_, bgFxClips) = ClassifyAudioClipsForExport();
            var distinctBgFx = bgFxClips
                .Select(b => b.FilePath)
                .Where(p => !string.IsNullOrWhiteSpace(p))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToList();

            foreach (var bg in distinctBgFx)
            {
                args.Append($"-i \"{bg}\" ");
                inputMap[bg] = inputIndex++;
            }
            var filterChains = new List<string>();
            string panZoomFilter;
            double zoom = mainVideoAsset.Scale;
            double posX = mainVideoAsset.PositionX;
            double posY = mainVideoAsset.PositionY;
            int W = settings.ResolutionWidth;
            int H = settings.ResolutionHeight;

            if (Math.Abs(zoom - 1.0) > 0.001 || Math.Abs(posX - 0.5) > 0.001 || Math.Abs(posY - 0.5) > 0.001)
            {
                string cover = $"max({W}/iw\\,{H}/ih)";
                string zoomExpr = $"max({zoom.ToString(CultureInfo.InvariantCulture)}\\,1)";
                string eff = $"({cover})*({zoomExpr})";
                string scaleFilter = $"scale=w=ceil(iw*{eff}):h=ceil(ih*{eff})";
                string cx = $"(iw - {W})/2 - ({posX.ToString(CultureInfo.InvariantCulture)} - 0.5)*{W}";
                string cy = $"(ih - {H})/2 - ({posY.ToString(CultureInfo.InvariantCulture)} - 0.5)*{H}";
                string cropX = $"x='max(0\\,min(iw-{W}\\,({cx})))'";
                string cropY = $"y='max(0\\,min(ih-{H}\\,({cy})))'";
                string cropFilter = $"crop={W}:{H}:{cropX}:{cropY}";
                panZoomFilter = $"{scaleFilter},{cropFilter}";
            }
            else
            {
                string cover = $"max({W}/iw\\,{H}/ih)";
                string scaleFilter = $"scale=w=ceil(iw*({cover})):h=ceil(ih*({cover}))";
                panZoomFilter = scaleFilter;
            }
            string currentVideoTag = "v_base";
            double sourceTotalSec = await ProbeDurationSecondsAsync(mainVideoAsset.FilePath);
            double baseTrimStartSec = mainVideoAsset?.TrimStartOffset.TotalSeconds ?? 0.0;
            double baseTrimEndSec = mainVideoAsset?.TrimEndOffset.TotalSeconds ?? 0.0;
            double effectiveEndSec = Math.Max(baseTrimStartSec, sourceTotalSec - baseTrimEndSec);
            filterChains.Add(
                $"[0:v]" +
                $"trim=start={baseTrimStartSec.ToString(CultureInfo.InvariantCulture)}:end={effectiveEndSec.ToString(CultureInfo.InvariantCulture)}," +
                $"setpts=PTS-STARTPTS," +
                $"{panZoomFilter}" +
                $"[v_base]");
            currentVideoTag = "v_base";

            double refW = CurrentProject?.ProjectReferenceVideoWidth > 0 ? CurrentProject.ProjectReferenceVideoWidth : 1280.0;
            double refH = CurrentProject?.ProjectReferenceVideoHeight > 0 ? CurrentProject.ProjectReferenceVideoHeight : 720.0;
            double scaleXFactor = settings.ResolutionWidth / refW;
            double scaleYFactor = settings.ResolutionHeight / refH;
            var overlayClips = imageClips.Where(c => c.TrackIndex != 0).OrderBy(c => c.StartTime).ToList();

            for (int i = 0; i < overlayClips.Count; i++)
            {
                var clip = overlayClips[i];
                var img = (MediaAsset)clip.SourceData;

                if (!inputMap.TryGetValue(img.FilePath, out int imgInputIndex))
                    continue;
                baseTrimEndSec = mainVideoAsset?.TrimStartOffset.TotalSeconds ?? 0.0;
                double tStart = Math.Max(0, clip.StartTime.TotalSeconds - baseTrimStartSec);
                double tEnd = Math.Max(tStart, clip.EndTime.TotalSeconds - baseTrimStartSec);

                if (tEnd <= tStart + 1e-6) continue;
                double imgAR = img.Height > 0 ? (double)img.Width / img.Height : 1.0;
                double initW_ref, initH_ref;
                if ((refW / refH) > imgAR) { initH_ref = refH; initW_ref = initH_ref * imgAR; }
                else { initW_ref = refW; initH_ref = initW_ref / imgAR; }
                double finalW_out = initW_ref * Math.Max(img.ScaleX, 0.0001) * scaleXFactor;
                double finalH_out = initH_ref * Math.Max(img.ScaleY, 0.0001) * scaleYFactor;
                int outW = Math.Max(1, (int)Math.Round(finalW_out));
                int outH = Math.Max(1, (int)Math.Round(finalH_out));
                double centerX_out = img.PositionX * refW * scaleXFactor;
                double centerY_out = img.PositionY * refH * scaleYFactor;
                double radians = (img.Rotation) * Math.PI / 180.0;
                string processedTag = $"processed_img_{i}";
                string nextVideoTag = $"v_with_img_{i}";
                if (Math.Abs(radians) < 1e-6)
                {
                    filterChains.Add(
                        $"[{imgInputIndex}:v]" +
                        $"scale={outW}:{outH}:flags=lanczos," +
                        $"format=rgba," +
                        $"fifo" +
                        $"[{processedTag}]"
                    );
                }
                else
                {
                    filterChains.Add(
                        $"[{imgInputIndex}:v]" +
                        $"scale={outW}:{outH}:flags=lanczos," +
                        $"format=rgba," +
                        $"rotate={radians.ToString(CultureInfo.InvariantCulture)}:c=black@0:ow='hypot(iw,ih)':oh='hypot(iw,ih)'," +
                        $"fifo" +
                        $"[{processedTag}]"
                    );
                }

                string ox = $"{centerX_out.ToString(CultureInfo.InvariantCulture)}-overlay_w/2";
                string oy = $"{centerY_out.ToString(CultureInfo.InvariantCulture)}-overlay_h/2";
                filterChains.Add(
                    $"[{currentVideoTag}][{processedTag}]" +
                    $"overlay=x='{ox}':y='{oy}':enable='between(t,{tStart.ToString(CultureInfo.InvariantCulture)},{tEnd.ToString(CultureInfo.InvariantCulture)})':shortest=1:eof_action=pass" +
                    $"[{nextVideoTag}]"
                );

                currentVideoTag = nextVideoTag;
            }
            string escapedAss = tempAssPath.Replace(@"\", @"\\").Replace(":", @"\:");
            string fontsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Fonts");
            if (!Directory.Exists(fontsDir)) fontsDir = @"C:\Windows\Fonts";
            string escapedFonts = fontsDir.Replace(@"\", @"\\").Replace(":", @"\:");
            if (CurrentProject?.Subtitles != null && CurrentProject.Subtitles.Count > 0)
            {
                _exportCachedBlurIntervals = CurrentProject.Subtitles
                    .OrderBy(s => s.StartTime)
                    .Select(s => (s.StartTime, s.EndTime))
                    .ToList();
            }
            else
            {
                _exportCachedBlurIntervals = null;
            }
            bool burnSubsForDynamic = CurrentProject?.Subtitles != null && CurrentProject.Subtitles.Count > 0;
            string blurChainDyn = BuildBlurBoxFilter(
                currentVideoTag,
                "video_blur_e",
                CurrentProject,
                burnSubsForDynamic,
                null
            );
            filterChains.Add(blurChainDyn);
            currentVideoTag = "video_blur_e";

            if (_isVideoFlipEnabled)
            {
                filterChains.Add($"[{currentVideoTag}]hflip[video_flipped]");
                currentVideoTag = "video_flipped";
            }

            filterChains.Add(
                $"[{currentVideoTag}]setsar=1[video_out_scaled];" +
                $"[video_out_scaled]subtitles=filename='{escapedAss}':fontsdir='{escapedFonts}':charenc=UTF-8[video_out]"
            );
            if (bgFxClips.Count == 0)
            {
                filterChains.Add($"[{wavInputIndex}:a]anull,alimiter=limit=0.97[final_audio]");
            }
            else
            {
                filterChains.Add($"[{wavInputIndex}:a]anull[a_pass1]");
                var mixInputs = new List<string> { "[a_pass1]" };

                for (int i = 0; i < bgFxClips.Count; i++)
                {
                    var bg = bgFxClips[i];
                    if (!inputMap.TryGetValue(bg.FilePath, out var bgIndex)) continue;

                    string processed = $"bg_audio_{i}";
                    string delayed = $"bg_delayed_{i}";

                    var clipFilters = new List<string>
            {
                $"volume={DbToGain(bg.VolumeDb).ToString(CultureInfo.InvariantCulture)}"
            };

                    var trimDuration = bg.OriginalDuration - bg.TrimStartOffset - bg.TrimEndOffset;
                    if (trimDuration > TimeSpan.Zero)
                        clipFilters.Add($"atrim=start={bg.TrimStartOffset.TotalSeconds.ToString(CultureInfo.InvariantCulture)}:duration={trimDuration.TotalSeconds.ToString(CultureInfo.InvariantCulture)}");

                    clipFilters.Add("asetpts=PTS-STARTPTS");

                    if (Math.Abs(bg.Speed - 1.0) > 0.01)
                    {
                        string atempo = BuildAtempoChain(bg.Speed);
                        if (!string.IsNullOrEmpty(atempo)) clipFilters.Add(atempo);
                    }

                    filterChains.Add($"[{bgIndex}:a]{string.Join(",", clipFilters)}[{processed}]");

                    long delayMs = (long)bg.StartTime.TotalMilliseconds;
                    filterChains.Add($"[{processed}]adelay={delayMs}|{delayMs}[{delayed}]");

                    mixInputs.Add($"[{delayed}]");
                }

                filterChains.Add($"{string.Join("", mixInputs)}amix=inputs={mixInputs.Count}:duration=first:normalize=0,alimiter=limit=0.97[final_audio]");
            }
            string finalFilter = string.Join(";", filterChains);
            args.Append($"-filter_complex \"{finalFilter}\" ");
            args.Append("-map \"[video_out]\" -map \"[final_audio]\" ");
            bool isHardwareEncoder = false;
            if (!string.IsNullOrWhiteSpace(settings.VideoCodec))
            {
                string lowerCodec = settings.VideoCodec.ToLowerInvariant();
                if (lowerCodec.Contains("_nvenc") ||
                    lowerCodec.Contains("_qsv") ||
                    lowerCodec.Contains("_amf"))
                {
                    isHardwareEncoder = true;
                }
            }

            if (isHardwareEncoder)
            {
                args.Append($"-c:v {settings.VideoCodec} ");
                args.Append($"-cq {settings.Crf} ");
                string hwPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "p4";
                args.Append($"-preset {hwPreset} ");
                args.Append("-vsync 0 ");
            }
            else
            {
                args.Append("-c:v libx264 ");
                args.Append($"-crf {settings.Crf} ");
                string cpuPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "medium";
                args.Append($"-preset {cpuPreset} ");
            }


            if (settings.IsThreadLimitEnabled && !isHardwareEncoder)
            {
                args.Append($"-threads {settings.ThreadLimit} ");
            }
            if (!string.IsNullOrEmpty(settings.Tune)) args.Append($"-tune {settings.Tune} ");
            if (!string.IsNullOrEmpty(settings.PixelFormat)) args.Append($"-pix_fmt {settings.PixelFormat} ");

            args.Append($"-c:a aac -b:a {settings.AudioBitrate} -ar 44100 ");
            if (settings.ForceStereo) args.Append("-ac 2 ");
            args.Append("-movflags +faststart ");
            args.Append("-shortest ");
            args.Append($"\"{settings.OutputPath}\"");

            System.Diagnostics.Debug.WriteLine($"\n\n--- FFMPEG DYNAMIC PASS 2 COMMAND ---\n\nffmpeg {args}\n\n--- END FFMPEG COMMAND ---\n\n");
            await ExecuteFfmpegWithProgress(ffmpegPath, args.ToString(), progressWindow, settings.OutputPath, cancellationToken);
        }

        private async Task<string> BuildDynamicAudioFirstPassAsync(
    MediaAsset mainVideoAsset,
    double slowFactor,
    string ffmpegPath,
    IProgress<(int step, string msg)> progress)
        {
            if (mainVideoAsset == null ||
                string.IsNullOrWhiteSpace(mainVideoAsset.FilePath) ||
                !System.IO.File.Exists(mainVideoAsset.FilePath))
            {
                throw new System.IO.FileNotFoundException("Không tìm thấy video chính cho pass 1.");
            }
            double mainVideoVolumeDb = (mainVideoAsset as MediaAsset)?.VolumeDb ?? 0.0;
            string bgVol = DbToGain(mainVideoVolumeDb).ToString(CultureInfo.InvariantCulture);

            var (ttsClips, _) = ClassifyAudioClipsForExport();
            if (!ttsClips.Any())
            {
                progress?.Report((10, "xử lý audio nền..."));

                string simpleWavOut = TempFileManager.CreateTempFile(".wav");
                TempFileManager.RegisterForCleanup(simpleWavOut);

                double simpleSlow = Math.Clamp(slowFactor, 0.1, 4.0);
                string simpleSlowChain = BuildAtempoChain(simpleSlow);
                string simpleRestoreChain = BuildAtempoChain(1.0 / simpleSlow);

                var simpleArgs = new StringBuilder();
                simpleArgs.Append($"-y -i \"{mainVideoAsset.FilePath}\" ");
                simpleArgs.Append($"-filter:a \"volume={bgVol},{simpleSlowChain},{simpleRestoreChain},alimiter=limit=0.95\" ");
                simpleArgs.Append($"-ac 2 -ar 48000 \"{simpleWavOut}\"");

                int simpleExitCode = await RunFfmpegAsync(ffmpegPath, simpleArgs.ToString(), CancellationToken.None);
                if (simpleExitCode != 0)
                    throw new Exception($"FFmpeg trả về mã lỗi {simpleExitCode}.");

                progress?.Report((25, "Hoàn tất xử lý audio nền."));
                return simpleWavOut;
            }

            var smartCutMapItems = await BuildSmartCutTimelineForDynamicVideo();
            var smartCutTimelineForDynamic = smartCutMapItems
                .Select(it => (it.Line, it.FinalStart, it.FinalEnd))
                .ToList();
            var ttsPlacement = ResolveTtsPlacementsForDynamic(ttsClips, smartCutTimelineForDynamic);
            double clampedSlow = Math.Clamp(slowFactor, 0.1, 4.0);
            string slowChain = BuildAtempoChain(clampedSlow);
            string restoreChain = BuildAtempoChain(1.0 / clampedSlow);
            var fc = new StringBuilder();
            var mixInputs = new List<string>();
            fc.Append($"[0:a]volume={bgVol}");
            if (!string.IsNullOrEmpty(slowChain))
            {
                fc.Append($",{slowChain}");
            }
            fc.Append(",asetpts=PTS-STARTPTS[bg0];");
            mixInputs.Add("[bg0]");

            int ttsIndex = 0;
            foreach (var tts in ttsClips.OrderBy(c => c.StartTime))
            {
                if (!ttsPlacement.TryGetValue(tts, out var placement)) continue;

                string escapedPath = EscapePathForFilterScript(tts.FilePath);
                string volume = DbToGain(tts.VolumeDb).ToString(CultureInfo.InvariantCulture);

                long originalStartMs = (long)placement.Start.TotalMilliseconds;
                long preMixDelayMs = (long)Math.Round(originalStartMs / clampedSlow);

                string label = $"tts{ttsIndex++}";
                fc.Append($"amovie='{escapedPath}',volume={volume}");
                fc.Append(",aformat=sample_fmts=fltp:sample_rates=48000:channel_layouts=stereo");
                fc.Append($",adelay={preMixDelayMs}|{preMixDelayMs}[{label}];");

                mixInputs.Add($"[{label}]");
            }

            fc.Append($"{string.Join("", mixInputs)}");
            fc.Append($"amix=inputs={mixInputs.Count}:duration=longest:normalize=0:dropout_transition=0,");
            fc.Append("alimiter=limit=0.95");
            if (!string.IsNullOrEmpty(restoreChain))
            {
                fc.Append($",{restoreChain}");
            }
            fc.Append("[aout]");

            string filterScriptPath = TempFileManager.CreateTempFile(".txt");
            await System.IO.File.WriteAllTextAsync(filterScriptPath, fc.ToString());
            TempFileManager.RegisterForCleanup(filterScriptPath);

            string wavOut = TempFileManager.CreateTempFile(".wav");
            TempFileManager.RegisterForCleanup(wavOut);

            string ffArgs =
                $"-i \"{mainVideoAsset.FilePath}\" " +
                $"-filter_complex_script \"{filterScriptPath}\" " +
                "-filter_threads 0 " +
                "-map \"[aout]\" -ac 2 -ar 48000 " +
                $"\"{wavOut}\"";

            progress?.Report((25, "Đang tạo data..."));

            int exitCode = await RunFfmpegAsync(ffmpegPath, "-y " + ffArgs, CancellationToken.None);
            if (exitCode != 0)
                throw new Exception($"FFmpeg trả về mã lỗi {exitCode}.");

            return wavOut;
        }

        private async Task<double> ProbeDurationSecondsAsync(string mediaPath)
        {
            try
            {
                var info = await FFProbe.AnalyseAsync(mediaPath);
                return info?.Duration.TotalSeconds ?? 0.0;
            }
            catch
            {
                return 0.0;
            }
        }

        private static async Task<int> RunFfmpegAsync(string ffmpegExe, string args, CancellationToken cancellationToken)
        {
            var tcs = new TaskCompletionSource<int>();
            var errorLog = new StringBuilder();

            using var p = new Process
            {
                StartInfo = new ProcessStartInfo(ffmpegExe, args)
                {
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    RedirectStandardError = true,
                    RedirectStandardOutput = true,
                    StandardOutputEncoding = Encoding.UTF8,
                    StandardErrorEncoding = Encoding.UTF8
                },
                EnableRaisingEvents = true
            };

            p.ErrorDataReceived += (sender, e) =>
            {
                if (e.Data != null)
                {
                    lock (errorLog)
                    {
                        errorLog.AppendLine(e.Data);
                    }
                }
            };

            p.OutputDataReceived += (sender, e) =>
            {
                if (e.Data != null)
                {
                }
            };

            p.Exited += (s, e) =>
            {
                try { p.CancelErrorRead(); } catch { }
                try { p.CancelOutputRead(); } catch { }
                tcs.TrySetResult(p.ExitCode);
            };

            using (cancellationToken.Register(() =>
            {
                try
                {
                    if (!p.HasExited)
                    {
                        p.Kill(true);
                    }
                }
                catch (InvalidOperationException) { }
                tcs.TrySetCanceled();
            }))
            {
                try
                {
                    if (!p.Start())
                    {
                        tcs.TrySetException(new InvalidOperationException("Không thể khởi chạy tiến trình FFmpeg."));
                        return await tcs.Task;
                    }
                    p.BeginOutputReadLine();
                    p.BeginErrorReadLine();
                }
                catch (Exception ex)
                {
                    tcs.TrySetException(new Exception($"Lỗi khi khởi chạy FFmpeg: {ex.Message}"));
                    return await tcs.Task;
                }

                var exitCode = await tcs.Task;

                if (cancellationToken.IsCancellationRequested)
                {
                    throw new OperationCanceledException();
                }

                if (exitCode != 0)
                {
                    string log;
                    lock (errorLog)
                    {
                        log = errorLog.ToString();
                    }
                    throw new Exception($"FFmpeg thoát với mã lỗi {exitCode}.\n\nFFmpeg Log:\n{log}");
                }
                return exitCode;
            }
        }
        private class AudioExportContext
        {
            public string OriginalPath { get; set; }
            public string TempProcessedPath { get; set; } // File đã xử lý hiệu ứng
            public string BackupPath { get; set; } // Đường dẫn backup của file gốc (cho StaticReview)
            public object SourceObject { get; set; } // TimelineAudioClip hoặc MediaAsset
        }

        // Hàm kiểm tra xem clip có hiệu ứng nâng cao không
        private bool HasAdvancedEffects(object source)
        {
            if (source is TimelineAudioClip tac)
            {
                return tac.PitchSemitones != 0 || tac.FormantShift != 0 || tac.ReverbMix > 0 ||
                       tac.EchoDelayMs > 0 || tac.DistortionAmount > 0 || tac.IsRobot || tac.IsTremolo ||
                       tac.LowCutFreq > 20 || tac.HighCutFreq < 19000 || Math.Abs(tac.MidBoostGain) > 0.1;
            }
            if (source is MediaAsset ma)
            {
                return ma.PitchSemitones != 0 || ma.FormantShift != 0 || ma.ReverbMix > 0 ||
                       ma.EchoDelayMs > 0 || ma.DistortionAmount > 0 || ma.IsRobot || ma.IsTremolo ||
                       ma.LowCutFreq > 20 || ma.HighCutFreq < 19000 || Math.Abs(ma.MidBoostGain) > 0.1;
            }
            return false;
        }

        // Hàm xử lý file audio: Đọc file gốc -> Apply Effect -> Ghi ra file mới
        private void RenderAudioWithEffects(string inputPath, string outputPath, object sourceData)
        {
            // Sử dụng AudioFileReader để đọc file
            using (var reader = new AudioFileReader(inputPath))
            {
                ISampleProvider source = reader;

                // 1. Apply SoundTouch (Speed/Pitch Correction) nếu cần
                // Lưu ý: FFmpeg trong ExecuteVideoExportAsync đã có filter 'atempo' để xử lý speed.
                // Tuy nhiên, để Pitch Correction hoạt động đúng với Advanced Effects, ta nên xử lý ở đây.
                // Nếu TimelineAudioClip có Speed != 1, ta set Speed=1 ở đây để FFmpeg xử lý duration, 
                // NHƯNG nếu user bật PitchCorrection, ta cần xử lý pitch giữ nguyên.

                // Đơn giản hóa: Chúng ta chỉ áp dụng Advanced Effects ở đây. 
                // Speed sẽ do FFmpeg lo. Pitch Shifting (Semitones) do AdvancedAudioEffectsProvider lo.

                // 2. Apply Advanced Effects
                var effects = new AdvancedAudioEffectsProvider(source);
                if (sourceData is TimelineAudioClip tac) AudioEffectsHelper.ApplyEffectsToProvider(effects, tac);
                else if (sourceData is MediaAsset ma) AudioEffectsHelper.ApplyEffectsToProvider(effects, ma);

                // 3. Xuất ra file WAV
                WaveFileWriter.CreateWaveFile16(outputPath, effects);
            }
        }
        private async Task ExecuteVideoExportAsync(VideoExportSettings settings, GenerateVideoWindow progressWindow)
        {
            if (_selectedVoiceoverMode == VoiceoverExportMode.Ducking && _currentSmartCutMode != SmartCutMode.None)
            {
                CustomMessageBox.Show("Chế độ lồng tiếng Volume Ducking chỉ hoạt động với chế độ xuất video thông thường, không tương thích với Smart Cut. Vui lòng tắt Smart Cut hoặc chọn chế độ lồng tiếng 'Mặc định'.", "Chế độ không tương thích", MessageBoxButton.OK, MessageBoxImage.Warning);
                progressWindow.MarkAsComplete(false);
                progressWindow.Close();
                return;
            }
            List<AudioExportContext> restoreContexts = new List<AudioExportContext>();

            // [MỚI] Flag kiểm tra chế độ Static Review
            bool isStaticReview = _currentSmartCutMode == SmartCutMode.StaticReview;

            string tempAssPath = null;
            string tempFilterScriptPath = null;
            Process ffmpegProcess = null;
            var cancellationTokenSource = new CancellationTokenSource();
            var ffmpegOutputLog = new StringBuilder();
            var logLock = new object();

            progressWindow.CancelButton.Click += (s, e) =>
            {
                if (!cancellationTokenSource.IsCancellationRequested)
                {
                    cancellationTokenSource.Cancel();
                }
            };

            try
            {
                // ================== [BẮT ĐẦU XỬ LÝ PRE-EXPORT AUDIO] ==================
                progressWindow.UpdateProgress(1, "Đang xử lý hiệu ứng âm thanh...");

                await Task.Run(() =>
                {
                    // Lấy tất cả clip Audio và Video có audio
                    var clipsToCheck = TimelineClips.Where(c => c.ClipType == TimelineClipType.Audio || c.ClipType == TimelineClipType.Video).ToList();

                    foreach (var clip in clipsToCheck)
                    {
                        if (!HasAdvancedEffects(clip.SourceData)) continue;

                        string originalPath = (clip.SourceData as TimelineAudioClip)?.FilePath ?? (clip.SourceData as MediaAsset)?.FilePath;
                        if (string.IsNullOrEmpty(originalPath) || !File.Exists(originalPath)) continue;

                        var ctx = new AudioExportContext
                        {
                            OriginalPath = originalPath,
                            SourceObject = clip.SourceData
                        };

                        if (isStaticReview)
                        {
                            // STATIC REVIEW: Phải ghi đè file gốc vì SmartCut dùng file gốc để cắt
                            string folder = Path.GetDirectoryName(originalPath);
                            string ext = Path.GetExtension(originalPath);
                            string backupPath = Path.Combine(folder, $"backup_{Guid.NewGuid()}{ext}");

                            // 1. Move file gốc thành file backup
                            File.Move(originalPath, backupPath);
                            ctx.BackupPath = backupPath;

                            // 2. Render hiệu ứng từ file backup -> file tên gốc
                            RenderAudioWithEffects(backupPath, originalPath, clip.SourceData);

                            // Không set TempProcessedPath vì ta đang dùng chính path gốc
                        }
                        else
                        {
                            // NORMAL / DYNAMIC: Tạo file temp, tráo đường dẫn trong Object
                            string tempWav = TempFileManager.CreateTempFile(".wav");
                            RenderAudioWithEffects(originalPath, tempWav, clip.SourceData);
                            ctx.TempProcessedPath = tempWav;

                            // Tráo đường dẫn tạm thời
                            if (clip.SourceData is TimelineAudioClip tac) tac.FilePath = tempWav;
                            else if (clip.SourceData is MediaAsset ma) ma.FilePath = tempWav;
                        }

                        restoreContexts.Add(ctx);
                    }
                });
                string ffmpegPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "ffmpeg.exe");
                if (!File.Exists(ffmpegPath)) throw new FileNotFoundException("Không tìm thấy file ffmpeg.exe!");

                progressWindow.UpdateProgress(0, "Đang tạo file phụ đề...");
                string assContent = GenerateAssFileContent(settings.ResolutionWidth, settings.ResolutionHeight);
                tempAssPath = TempFileManager.CreateTempFile(".ass");
                await File.WriteAllTextAsync(tempAssPath, assContent, Encoding.UTF8, cancellationTokenSource.Token);

                var argsBuilder = new StringBuilder();

                if (_currentSmartCutMode == SmartCutMode.StaticReview)
                {
                    await ExecuteStaticSmartCutExportAsync(
                        ffmpegPath,
                        settings,
                        progressWindow,
                        cancellationTokenSource.Token);
                    return;
                }
                else if (_currentSmartCutMode == SmartCutMode.ParallelDynamic)
                {
                    await ExecuteParallelSmartCutExportAsync(
                        ffmpegPath,
                        settings,
                        progressWindow,
                        cancellationTokenSource.Token);
                    return;
                }
                else if (_currentSmartCutMode == SmartCutMode.DynamicVideo)
                {
                    string assContentForDynamic = GenerateAssFileContent(settings.ResolutionWidth, settings.ResolutionHeight);
                    await File.WriteAllTextAsync(tempAssPath, assContentForDynamic, Encoding.UTF8, cancellationTokenSource.Token);
                    progressWindow.UpdateProgress(1, "Đang thu thập dữ liệu");
                    double slowFactor = _smartCutDynamicSpeed;
                    slowFactor = Math.Clamp(slowFactor, 0.1, 4.0);
                    var mainVideoClip = TimelineClips.FirstOrDefault(c => c.ClipType == TimelineClipType.Video);
                    if (mainVideoClip == null || mainVideoClip.SourceData is not MediaAsset mainVideoAsset
                        || string.IsNullOrWhiteSpace(mainVideoAsset.FilePath) || !File.Exists(mainVideoAsset.FilePath))
                    {
                        throw new Exception("Không tìm thấy video chính để xuất ở chế độ Dynamic.");
                    }
                    string pass1AudioPath = await BuildDynamicAudioFirstPassAsync(
                        mainVideoAsset,
                        slowFactor,
                        ffmpegPath,
                        new Progress<(int step, string msg)>(p => progressWindow.UpdateProgress(p.step, p.msg))
                    );
                    TempFileManager.RegisterForCleanup(pass1AudioPath);
                    progressWindow.UpdateProgress(50, "Xuất video...");
                    await RunSmartCutDynamicPass2Async(ffmpegPath, mainVideoAsset, pass1AudioPath, tempAssPath, settings, progressWindow, cancellationTokenSource.Token);

                    progressWindow.UpdateProgress(100, "Hoàn tất.");
                    progressWindow.MarkAsComplete(true);
                    return;
                }

                else
                {
                    // --- LOGIC XUẤT VIDEO THÔNG THƯỜNG ---
                    // Kiểm tra video dài > 1 tiếng (60 phút), tự động chia segment 30 phút
                    var mainVideoClipForNormal = TimelineClips.FirstOrDefault(c => c.ClipType == TimelineClipType.Video);
                    double totalContentDurationMinutes = _actualContentDuration.TotalMinutes;
                    const double maxMinutesForDirectNormalProcessing = 60.0; // 1 tiếng
                    
                    if (totalContentDurationMinutes >= maxMinutesForDirectNormalProcessing && mainVideoClipForNormal != null)
                    {
                        progressWindow.UpdateProgress(2, $"Video dài {totalContentDurationMinutes:F1} phút, đang phân đoạn...");
                        await ExecuteNormalExportWithSegmentationAsync(
                            ffmpegPath,
                            settings,
                            progressWindow,
                            cancellationTokenSource.Token
                        );
                        return;
                    }
                    
                    var inputMap = new Dictionary<string, int>();
                    int inputIndexCounter = 0;
                    string finalGpuAccel = "none";
                    string finalVideoCodec = settings.VideoCodec;
                    if (settings.GpuAcceleration == "auto")
                    {
                        var allGpus = await FfmpegGpuDetector.GetAvailableGpusAsync();
                        var bestGpu = FfmpegGpuDetector.GetBestAvailableGpu(allGpus);
                        if (bestGpu != null && bestGpu.FfmpegValue != "none")
                        {
                            finalGpuAccel = bestGpu.FfmpegValue;
                            finalVideoCodec = bestGpu.RecommendedCodec;
                        }
                    }
                    else if (settings.GpuAcceleration != "none")
                    {
                        finalGpuAccel = settings.GpuAcceleration;
                    }

                    if (finalGpuAccel != "none")
                    {
                        argsBuilder.Append($"-hwaccel {finalGpuAccel} ");
                    }
                    var visualInputClips = TimelineClips
    .Where(c => (c.ClipType == TimelineClipType.Video || c.ClipType == TimelineClipType.Image) && !string.IsNullOrEmpty(c.FilePath))
    .ToList();

                    foreach (var clip in visualInputClips)
                    {
                        if (!inputMap.ContainsKey(clip.FilePath))
                        {
                            inputMap[clip.FilePath] = inputIndexCounter++;
                        }
                    }
                    foreach (var path in inputMap.OrderBy(kvp => kvp.Value).Select(kvp => kvp.Key))
                    {
                        argsBuilder.Append($"-i \"{path}\" ");
                    }
                    argsBuilder.Append("-y ");

                    var filterChains = new List<string>();
                    var visualConcatInputs = new List<string>();
                    var audioFromVisualsConcatInputs = new List<string>();
                    var finalAudioMixInputs = new List<string>();
                    var (ttsClipsForNormal, bgFxClipsForNormal) = ClassifyAudioClipsForExport();
                    var mainTrackVisualClips = TimelineClips.Where(c => (c.ClipType == TimelineClipType.Video || c.ClipType == TimelineClipType.Image) && c.TrackIndex == 0).OrderBy(c => c.StartTime).ToList();

                    for (int i = 0; i < mainTrackVisualClips.Count; i++)
                    {
                        var clip = mainTrackVisualClips[i];
                        int mapIndex = inputMap[clip.FilePath];
                        double duration = clip.Duration.TotalSeconds;
                        string v_out = $"[v_out_{i}]";
                        string a_out = $"[a_out_{i}]";
                        var mediaAsset = clip.SourceData as MediaAsset;
                        double trimStart = mediaAsset?.TrimStartOffset.TotalSeconds ?? 0;
                        double clipVolumeDb = mediaAsset?.VolumeDb ?? 0.0;
                        double speed = mediaAsset?.Speed ?? 1.0;

                        string videoProcessingChain;
                        if (clip.ClipType == TimelineClipType.Video)
                        {
                            string ptsFilter = (Math.Abs(speed - 1.0) > 0.01) ? $",setpts=PTS/{speed.ToString(CultureInfo.InvariantCulture)}" : "";
                            videoProcessingChain = $"[{mapIndex}:v]trim=start={trimStart.ToString(CultureInfo.InvariantCulture)}:duration={(duration * speed).ToString(CultureInfo.InvariantCulture)}{ptsFilter},setpts=PTS-STARTPTS";
                        }
                        else
                        {
                            videoProcessingChain = $"[{mapIndex}:v]loop=loop=-1:size=1:start=0,setpts=PTS-STARTPTS,trim=duration={duration.ToString(CultureInfo.InvariantCulture)}";
                        }

                        string panZoomFilter;
                        if (mediaAsset != null)
                        {
                            double zoom = mediaAsset.Scale;
                            double posX = mediaAsset.PositionX;
                            double posY = mediaAsset.PositionY;

                            if (Math.Abs(zoom - 1.0) > 0.001 || Math.Abs(posX - 0.5) > 0.001 || Math.Abs(posY - 0.5) > 0.001)
                            {
                                int W = settings.ResolutionWidth;
                                int H = settings.ResolutionHeight;

                                string cover = $"max({W}/iw\\,{H}/ih)";
                                string zoomExpr = $"max({zoom.ToString(CultureInfo.InvariantCulture)}\\,1)";
                                string eff = $"({cover})*({zoomExpr})";
                                string scaleFilter = $"scale=w=ceil(iw*{eff}):h=ceil(ih*{eff})";

                                string cx = $"(iw - {W})/2 - ({posX.ToString(CultureInfo.InvariantCulture)} - 0.5)*{W}";
                                string cy = $"(ih - {H})/2 - ({posY.ToString(CultureInfo.InvariantCulture)} - 0.5)*{H}";
                                string cropX = $"x='max(0\\,min(iw-{W}\\,({cx})))'";
                                string cropY = $"y='max(0\\,min(ih-{H}\\,({cy})))'";

                                string cropFilter = $"crop={W}:{H}:{cropX}:{cropY}";
                                panZoomFilter = $"{scaleFilter},{cropFilter},scale='trunc(iw/2)*2:trunc(ih/2)*2'";
                            }
                            else
                            {
                                string cover = $"max({settings.ResolutionWidth}/iw\\,{settings.ResolutionHeight}/ih)";
                                string scaleFilter = $"scale=w=ceil(iw*({cover})):h=ceil(ih*({cover}))";
                                panZoomFilter = $"{scaleFilter},scale='trunc(iw/2)*2:trunc(ih/2)*2'";
                            }
                        }
                        else
                        {
                            string cover = $"max({settings.ResolutionWidth}/iw\\,{settings.ResolutionHeight}/ih)";
                            string scaleFilter = $"scale=w=ceil(iw*({cover})):h=ceil(ih*({cover}))";
                            panZoomFilter = $"{scaleFilter},scale='trunc(iw/2)*2:trunc(ih/2)*2'";
                        }


                        filterChains.Add($"{videoProcessingChain},{panZoomFilter},setsar=1{v_out}");

                        if (clip.ClipType == TimelineClipType.Video)
                        {
                            string atempoFilter = (Math.Abs(speed - 1.0) > 0.01) ? $",atempo={speed.ToString(CultureInfo.InvariantCulture)}" : "";
                            filterChains.Add(
                                $"[{mapIndex}:a]atrim=start={trimStart.ToString(CultureInfo.InvariantCulture)}:duration={(duration * speed).ToString(CultureInfo.InvariantCulture)},asetpts=PTS-STARTPTS{atempoFilter},volume={clipVolumeDb.ToString(CultureInfo.InvariantCulture)}dB,aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo{a_out}"
                            );
                        }
                        else
                        {
                            filterChains.Add($"anullsrc=channel_layout=stereo:sample_rate=44100,atrim=duration={duration.ToString(CultureInfo.InvariantCulture)},asetpts=PTS-STARTPTS{a_out}");
                        }

                        visualConcatInputs.Add(v_out);
                        audioFromVisualsConcatInputs.Add(a_out);
                    }

                    if (visualConcatInputs.Any())
                    {
                        filterChains.Add($"{string.Join("", visualConcatInputs)}concat=n={visualConcatInputs.Count}:v=1:a=0[v_concat]");
                        filterChains.Add($"{string.Join("", audioFromVisualsConcatInputs)}concat=n={audioFromVisualsConcatInputs.Count}:v=0:a=1[audio_vis_cat]");
                        filterChains.Add("[audio_vis_cat]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[audio_from_visuals]");
                        if (_selectedVoiceoverMode == VoiceoverExportMode.Ducking)
                        {
                            var (duckingChain, finalDuckedLabel) = BuildAudioDuckingFilterchain("[audio_from_visuals]");
                            if (!string.IsNullOrEmpty(duckingChain))
                            {
                                filterChains.Add(duckingChain);
                                finalAudioMixInputs.Add($"[{finalDuckedLabel}]");
                            }
                            else
                            {
                                finalAudioMixInputs.Add("[audio_from_visuals]");
                            }
                        }
                        else
                        {
                            finalAudioMixInputs.Add("[audio_from_visuals]");
                        }

                    }
                    else
                    {
                        filterChains.Add($"nullsrc=size={settings.ResolutionWidth}x{settings.ResolutionHeight}:duration={_actualContentDuration.TotalSeconds.ToString(CultureInfo.InvariantCulture)}[v_concat]");
                    }

                    string currentVideoTag = "v_concat";
                    var imageOverlayClips = TimelineClips.Where(c => c.ClipType == TimelineClipType.Image && c.TrackIndex != 0).ToList();
                    if (imageOverlayClips.Any())
                    {
                        for (int i = 0; i < imageOverlayClips.Count; i++)
                        {
                            var imageClip = imageOverlayClips[i];
                            if (imageClip.SourceData is not MediaAsset imageAsset) continue;

                            int imageInputIndex = inputMap[imageAsset.FilePath];
                            string nextVideoTag = $"v_with_img_{i}";
                            string processedTag = $"processed_img_{i}";

                            double refW = CurrentProject.ProjectReferenceVideoWidth > 0 ? CurrentProject.ProjectReferenceVideoWidth : DEFAULT_REFERENCE_WIDTH;
                            double refH = CurrentProject.ProjectReferenceVideoHeight > 0 ? CurrentProject.ProjectReferenceVideoHeight : DEFAULT_REFERENCE_HEIGHT;

                            double scaleXFactor = settings.ResolutionWidth / refW;
                            double scaleYFactor = settings.ResolutionHeight / refH;

                            double imgAR = imageAsset.Height > 0 ? (double)imageAsset.Width / imageAsset.Height : 1.0;

                            double initW_ref, initH_ref;
                            if ((refW / refH) > imgAR)
                            {
                                initH_ref = refH;
                                initW_ref = initH_ref * imgAR;
                            }
                            else
                            {
                                initW_ref = refW;
                                initH_ref = initW_ref / imgAR;
                            }

                            double finalW_out = initW_ref * Math.Max(imageAsset.ScaleX, 0.0001) * scaleXFactor;
                            double finalH_out = initH_ref * Math.Max(imageAsset.ScaleY, 0.0001) * scaleYFactor;
                            int origW = Math.Max(1, (int)Math.Round(finalW_out));
                            int origH = Math.Max(1, (int)Math.Round(finalH_out));

                            double centerX_out = imageAsset.PositionX * refW * scaleXFactor;
                            double centerY_out = imageAsset.PositionY * refH * scaleYFactor;

                            double radians = (imageAsset.Rotation) * Math.PI / 180.0;
                            double startTime = imageClip.StartTime.TotalSeconds;
                            double endTime = imageClip.EndTime.TotalSeconds;

                            string imgChain =
                                $"[{imageInputIndex}:v]" +
                                $"scale={origW}:{origH}:flags=lanczos," +
                                $"format=rgba," +
                                $"rotate='{radians.ToString(CultureInfo.InvariantCulture)}:c=none:ow=hypot(iw\\,ih):oh=hypot(iw\\,ih)'" +
                                $"[{processedTag}]";
                            filterChains.Add(imgChain);

                            string ox = $"{centerX_out.ToString(CultureInfo.InvariantCulture)} - overlay_w/2";
                            string oy = $"{centerY_out.ToString(CultureInfo.InvariantCulture)} - overlay_h/2";

                            string overlayChain =
                                $"[{currentVideoTag}][{processedTag}]" +
                                $"overlay=x='{ox}':y='{oy}':enable='between(t\\,{startTime.ToString(CultureInfo.InvariantCulture)}\\,{endTime.ToString(CultureInfo.InvariantCulture)})':format=auto" +
                                $"[{nextVideoTag}]";
                            filterChains.Add(overlayChain);

                            currentVideoTag = nextVideoTag;
                        }
                    }

                    var audioClipsOnTimeline = TimelineClips.Where(c => c.ClipType == TimelineClipType.Audio).ToList();
                    for (int j = 0; j < audioClipsOnTimeline.Count; j++)
                    {
                        var audioVM = audioClipsOnTimeline[j];
                        var audioClipSource = audioVM.SourceData as TimelineAudioClip;
                        if (audioClipSource == null || string.IsNullOrEmpty(audioClipSource.FilePath) || !File.Exists(audioClipSource.FilePath)) continue;
                        string escapedPath = EscapePathForFilterScript(audioClipSource.FilePath);

                        double finalDb = audioVM.VolumeDb;
                        if (ttsClipsForNormal.Contains(audioClipSource))
                        {
                            finalDb = ResolveDbOrDefault(audioVM.VolumeDb, +20.0);
                        }
                        var filters = new List<string>
    {
        $"atrim=start={audioClipSource.TrimStartOffset.TotalSeconds.ToString(CultureInfo.InvariantCulture)}:duration={audioClipSource.OriginalDuration.TotalSeconds.ToString(CultureInfo.InvariantCulture)}",
        "asetpts=PTS-STARTPTS"
    };
                        if (Math.Abs(audioClipSource.Speed - 1.0) > 0.01)
                        {
                            string atempoChain = BuildAtempoChain(audioClipSource.Speed);
                            if (!string.IsNullOrEmpty(atempoChain)) filters.Add(atempoChain);
                        }
                        if (Math.Abs(finalDb) > 0.01) filters.Add($"volume={finalDb.ToString(CultureInfo.InvariantCulture)}dB");
                        filterChains.Add(
                            $"amovie='{escapedPath}',{string.Join(",", filters)}," +
                            $"aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo" +
                            $"[a_processed_{j}]"
                        );

                        filterChains.Add($"[a_processed_{j}]adelay={(long)audioVM.StartTime.TotalMilliseconds}|{(long)audioVM.StartTime.TotalMilliseconds}[a_delayed_{j}]");
                        finalAudioMixInputs.Add($"[a_delayed_{j}]");
                    }

                    if (finalAudioMixInputs.Any())
                    {
                        filterChains.Add(
                            $"{string.Join("", finalAudioMixInputs)}" +
                            $"amix=inputs={finalAudioMixInputs.Count}:duration=longest:normalize=0," +
                            $"alimiter=limit=0.97" +
                            $"[final_audio]"
                        );
                    }
                    else
                    {
                        filterChains.Add("anullsrc=channel_layout=stereo:sample_rate=44100[final_audio]");
                    }

                    string escapedAss = tempAssPath.Replace(@"\", @"\\").Replace(":", @"\:");
                    string fontsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Fonts");
                    if (!Directory.Exists(fontsDir)) fontsDir = @"C:\Windows\Fonts";
                    string escapedFonts = fontsDir.Replace(@"\", @"\\").Replace(":", @"\:");
                    if (CurrentProject?.Subtitles != null && CurrentProject.Subtitles.Count > 0)
                    {
                        _exportCachedBlurIntervals = CurrentProject.Subtitles
                            .OrderBy(s => s.StartTime)
                            .Select(s => (s.StartTime, s.EndTime))
                            .ToList();
                    }
                    else
                    {
                        _exportCachedBlurIntervals = null;
                    }
                    bool burnSubsForNormal = CurrentProject?.Subtitles != null && CurrentProject.Subtitles.Count > 0;
                    string blurChainNormal = BuildBlurBoxFilter(
                        currentVideoTag,
                        "video_blur_e",
                        CurrentProject,
                        burnSubsForNormal,
                        null
                    );
                    filterChains.Add(blurChainNormal);
                    currentVideoTag = "video_blur_e";
                    if (_isVideoFlipEnabled)
                    {
                        filterChains.Add($"[{currentVideoTag}]hflip[video_flipped]");
                        currentVideoTag = "video_flipped";
                    }

                    string subtitleFilterLine = $"[{currentVideoTag}]subtitles=filename='{escapedAss}':fontsdir='{escapedFonts}':charenc=UTF-8[video_out]";
                    filterChains.Add(subtitleFilterLine);

                    string finalFilterComplex = string.Join(";", filterChains);

                    tempFilterScriptPath = TempFileManager.CreateTempFile(".txt");
                    await WriteTextNoBomAsync(
                        tempFilterScriptPath,
                        finalFilterComplex,
                        cancellationTokenSource.Token
                    );
                    argsBuilder.Append($"-filter_complex_script \"{tempFilterScriptPath}\" -filter_threads 0 ");
                    argsBuilder.Append("-map \"[video_out]\" -map \"[final_audio]\" ");
                }
                bool isHardwareEncoder = false;
                if (!string.IsNullOrWhiteSpace(settings.VideoCodec))
                {
                    string lowerCodec = settings.VideoCodec.ToLowerInvariant();
                    if (lowerCodec.Contains("_nvenc") ||
                        lowerCodec.Contains("_qsv") ||
                        lowerCodec.Contains("_amf"))
                    {
                        isHardwareEncoder = true;
                    }
                }
                if (isHardwareEncoder)
                {
                    argsBuilder.Append($"-c:v {settings.VideoCodec} ");
                    argsBuilder.Append($"-cq {settings.Crf} ");
                    string hwPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "p4";
                    argsBuilder.Append($"-preset {hwPreset} ");
                    const int fps = 30; 
                    argsBuilder.Append($"-vsync cfr -r {fps} ");
                }
                else
                {
                    argsBuilder.Append("-c:v libx264 ");
                    argsBuilder.Append($"-crf {settings.Crf} ");
                    string cpuPreset = !string.IsNullOrEmpty(settings.Preset) ? settings.Preset : "medium";
                    argsBuilder.Append($"-preset {cpuPreset} ");
                }
                if (settings.IsThreadLimitEnabled && !isHardwareEncoder)
                {
                    argsBuilder.Append($"-threads {settings.ThreadLimit} ");
                }
                if (!string.IsNullOrEmpty(settings.Tune))
                {
                    argsBuilder.Append($"-tune {settings.Tune} ");
                }
                if (!string.IsNullOrEmpty(settings.PixelFormat))
                {
                    argsBuilder.Append($"-pix_fmt {settings.PixelFormat} ");
                }
                argsBuilder.Append($"-c:a aac -b:a {settings.AudioBitrate} -ar 44100 ");
                if (settings.ForceStereo)
                {
                    argsBuilder.Append("-ac 2 ");
                }
                argsBuilder.Append("-movflags +faststart ");
                argsBuilder.Append("-shortest ");
                argsBuilder.Append($"\"{settings.OutputPath}\"");
                string finalArguments = argsBuilder.ToString();
                System.Diagnostics.Debug.WriteLine($"\n\n--- FFMPEG SMART CUT COMMAND ---\n\nffmpeg {finalArguments}\n\n--- END FFMPEG COMMAND ---\n\n");
                progressWindow.UpdateProgress(5, "Đang mã hóa...");
                var startInfo = new ProcessStartInfo
                {
                    FileName = ffmpegPath,
                    Arguments = finalArguments,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                };

                ffmpegProcess = new Process { StartInfo = startInfo, EnableRaisingEvents = true };
                var timeRegex = new Regex(@"time=(\d{2}):(\d{2}):(\d{2})\.(\d{2})");
                double totalDurationSeconds = _actualContentDuration.TotalSeconds;
                if (_currentSmartCutMode == SmartCutMode.StaticReview || _currentSmartCutMode == SmartCutMode.DynamicVideo)
                {
                    if (_smartCutSubtitleTimeline != null && _smartCutSubtitleTimeline.Count > 0)
                    {
                        totalDurationSeconds = _smartCutSubtitleTimeline.Last().FinalEnd.TotalSeconds;
                    }
                }
                ffmpegProcess.ErrorDataReceived += (s, e) =>
                {
                    if (e.Data == null || totalDurationSeconds <= 0) return;
                    lock (logLock) { ffmpegOutputLog.AppendLine(e.Data); }

                    var match = timeRegex.Match(e.Data);
                    if (match.Success)
                    {
                        var processedTime = TimeSpan.FromHours(double.Parse(match.Groups[1].Value)) +
                                            TimeSpan.FromMinutes(double.Parse(match.Groups[2].Value)) +
                                            TimeSpan.FromSeconds(double.Parse(match.Groups[3].Value)) +
                                            TimeSpan.FromMilliseconds(double.Parse(match.Groups[4].Value) * 10);
                        double progress = (processedTime.TotalSeconds / totalDurationSeconds) * 100;
                        progressWindow.UpdateProgress((int)progress, $"Đang mã hóa... {processedTime:hh\\:mm\\:ss}");
                    }
                };

                ffmpegProcess.Start();
                ffmpegProcess.BeginErrorReadLine();
                await ffmpegProcess.WaitForExitAsync(cancellationTokenSource.Token);

                if (cancellationTokenSource.IsCancellationRequested)
                {
                    if (File.Exists(settings.OutputPath)) { try { File.Delete(settings.OutputPath); } catch { } }
                    progressWindow.MarkAsComplete(false);
                }
                else if (ffmpegProcess.ExitCode == 0)
                {
                    progressWindow.UpdateProgress(100, "Hoàn thành!");
                    progressWindow.MarkAsComplete(true);
                }
                else
                {
                    string errorLog;
                    lock (logLock) { errorLog = ffmpegOutputLog.ToString(); }
                    var lastLines = string.Join("\n", errorLog.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries).TakeLast(15));
                    throw new Exception($"FFmpeg đã thoát với mã lỗi: {ffmpegProcess.ExitCode}.\n\n--- Log từ FFmpeg ---\n{lastLines}");
                }
            }
            catch (OperationCanceledException)
            {
                progressWindow.UpdateProgress((int)progressWindow.MainProgressBar.Value, "Đã hủy bỏ!");
                progressWindow.MarkAsComplete(false);
            }
            catch (Exception ex)
            {
                progressWindow.UpdateProgress((int)progressWindow.MainProgressBar.Value, "Xuất video thất bại!");
                CustomMessageBox.Show($"Có lỗi xảy ra trong quá trình xuất video.\n\nChi tiết: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                progressWindow.MarkAsComplete(false);
            }
            finally
            {
                foreach (var ctx in restoreContexts)
                {
                    try
                    {
                        if (isStaticReview)
                        {
                            // Static Review: Xóa file đã xử lý (đang mang tên gốc), trả lại file backup về tên gốc
                            if (File.Exists(ctx.OriginalPath)) File.Delete(ctx.OriginalPath);
                            if (File.Exists(ctx.BackupPath)) File.Move(ctx.BackupPath, ctx.OriginalPath);
                        }
                        else
                        {
                            // Normal: Trả lại đường dẫn gốc cho Object, xóa file temp
                            if (ctx.SourceObject is TimelineAudioClip tac) tac.FilePath = ctx.OriginalPath;
                            else if (ctx.SourceObject is MediaAsset ma) ma.FilePath = ctx.OriginalPath;

                            if (File.Exists(ctx.TempProcessedPath)) File.Delete(ctx.TempProcessedPath);
                        }
                    }
                    catch (Exception restoreEx)
                    {
                        Debug.WriteLine($"Lỗi khôi phục audio: {restoreEx.Message}");
                    }
                }
                if (ffmpegProcess != null && !ffmpegProcess.HasExited)
                {
                    try { ffmpegProcess.Kill(true); }
                    catch { }
                }
                if (tempAssPath != null && File.Exists(tempAssPath))
                {
                    try { File.Delete(tempAssPath); } catch { }
                }
                if (tempFilterScriptPath != null && File.Exists(tempFilterScriptPath))
                {
                    try { File.Delete(tempFilterScriptPath); } catch { }
                }
                cancellationTokenSource.Dispose();
            }
        }

        private (string filterChain, string finalDuckedLabel) BuildAudioDuckingFilterchain(string mainAudioInputLabel)
        {
            var ttsClips = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Audio && c.SourceData is TimelineAudioClip)
                .Select(c => c.SourceData as TimelineAudioClip)
                .Where(tac => tac != null)
                .OrderBy(tac => tac.StartTime)
                .ToList();

            if (!ttsClips.Any())
            {
                return (string.Empty, mainAudioInputLabel.Trim('[', ']'));
            }

            var filterBuilder = new StringBuilder();
            string currentLabel = mainAudioInputLabel.Trim('[', ']');
            int filterIndex = 0;
            const double DUCKED_VOLUME = 0.80;

            foreach (var clip in ttsClips)
            {
                string nextLabel = $"ducked_{filterIndex++}";
                var startTime = clip.StartTime;
                var endTime = clip.EndTime;

                if (endTime <= startTime)
                {
                    continue;
                }

                filterBuilder.Append(
                    $"[{currentLabel}]volume={DUCKED_VOLUME.ToString(CultureInfo.InvariantCulture)}:enable='between(t,{startTime.TotalSeconds.ToString(CultureInfo.InvariantCulture)},{endTime.TotalSeconds.ToString(CultureInfo.InvariantCulture)})'[{nextLabel}];"
                );
                currentLabel = nextLabel;
            }
            if (filterBuilder.Length == 0)
            {
                return (string.Empty, mainAudioInputLabel.Trim('[', ']'));
            }
            return (filterBuilder.ToString().TrimEnd(';'), currentLabel);
        }
        private static double ResolveDbOrDefault(double projectDb, double defaultDb)
        {
            if (Math.Abs(projectDb) < 0.01)
            {
                return defaultDb;
            }
            return projectDb;
        }
        private static async Task WriteTextNoBomAsync(string path, string content, CancellationToken ct)
        {
            string normalized = content.Replace("\r\n", "\n");
            var utf8NoBom = new System.Text.UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
            using (var fs = new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.None))
            using (var sw = new StreamWriter(fs, utf8NoBom))
            {
                await sw.WriteAsync(normalized.AsMemory(), ct);
                await sw.FlushAsync();
            }
        }
        private static string EscapePathForFilterScript(string path)
        {
            if (string.IsNullOrEmpty(path)) return path;
            return path
                .Replace(@"\", @"\\")
                .Replace(":", @"\:")
                .Replace("'", @"\'");
        }
        private async Task ExecuteFfmpegWithProgress(string ffmpegPath, string arguments, GenerateVideoWindow progressWindow, string outputPath, CancellationToken cancellationToken, double? durationOverride = null)
        {
            var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = ffmpegPath,
                    Arguments = arguments,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    StandardErrorEncoding = System.Text.Encoding.UTF8
                },
                EnableRaisingEvents = true
            };
            var timeRegex = new Regex(@"time=\s*(\d+):(\d+):(\d+)\.(\d+)");
            double totalDurationSeconds = durationOverride ?? (_actualContentDuration.TotalSeconds > 0 ? _actualContentDuration.TotalSeconds : 1);
            var tcs = new TaskCompletionSource<bool>();
            var errorLog = new StringBuilder();

            process.ErrorDataReceived += (sender, e) =>
            {
                if (e.Data == null) return;
                errorLog.AppendLine(e.Data);
                var match = timeRegex.Match(e.Data);
                if (match.Success)
                {
                    var processedTime = TimeSpan.FromHours(double.Parse(match.Groups[1].Value)) +
                                        TimeSpan.FromMinutes(double.Parse(match.Groups[2].Value)) +
                                        TimeSpan.FromSeconds(double.Parse(match.Groups[3].Value)) +
                                        TimeSpan.FromMilliseconds(double.Parse(match.Groups[4].Value) * 10);

                    double progressPercentage = (processedTime.TotalSeconds / totalDurationSeconds) * 100;
                    progressWindow.Dispatcher.Invoke(() =>
                    {
                        progressWindow.UpdateProgress((int)Math.Min(100, progressPercentage), $"Đang mã hóa... {processedTime:hh\\:mm\\:ss}");
                    });
                }
            };
            process.Exited += (sender, e) =>
            {
                if (System.IO.File.Exists(outputPath))
                {
                    try
                    {
                        System.Threading.Thread.Sleep(200);
                    }
                    catch (Exception) { }
                }
                if (process.ExitCode == 0)
                {
                    tcs.TrySetResult(true);
                }
                else if (cancellationToken.IsCancellationRequested)
                {
                    tcs.TrySetCanceled();
                }
                else
                {
                    tcs.TrySetException(new Exception($"FFmpeg exited with error code {process.ExitCode}.\n\n--- Full FFMpeg Log ---\n{errorLog.ToString()}"));
                }
                process.Dispose();
            };

            using (cancellationToken.Register(() =>
            {
                try
                {
                    if (!process.HasExited)
                    {
                        process.Kill(true);
                    }
                }
                catch (InvalidOperationException) { }
                tcs.TrySetCanceled();
            }))
            {
                process.Start();
                process.BeginErrorReadLine();
                await tcs.Task;
            }
        }
        private static double SnapToFps(double seconds, double fps)
        {
            return Math.Round(seconds * fps) / fps;
        }
        private static TimeSpan SnapToFps(TimeSpan ts, double fps)
        {
            return TimeSpan.FromSeconds(SnapToFps(ts.TotalSeconds, fps));
        }
        private static string Fmt6(double seconds)
        {
            return seconds.ToString("0.000000", CultureInfo.InvariantCulture);
        }
        private string GenerateAssFileContentForSmartCut(int playResX, int playResY, List<(SrtSubtitleLine Line, TimeSpan FinalStart, TimeSpan FinalEnd)> smartCutTimeline)
        {
            const double REFERENCE_HEIGHT = 720.0;
            double scaleFactor = playResY / REFERENCE_HEIGHT;
            var sb = new StringBuilder();
            sb.AppendLine("[Script Info]");
            sb.AppendLine($"Title: Generated by AIOSubPhim - {DateTime.Now}");
            sb.AppendLine($"PlayResX: {playResX}");
            sb.AppendLine($"PlayResY: {playResY}");
            sb.AppendLine("WrapStyle: 2");
            sb.AppendLine("ScaledBorderAndShadow: yes");
            sb.AppendLine();
            sb.AppendLine("[V4+ Styles]");
            sb.AppendLine("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding");
            string primary = HexToAssStyleColor(_currentProject.TemplateFontColor, _currentProject.TemplateOpacity);
            string secondary = primary;
            string outline = HexToAssStyleColor(_currentProject.TemplateOutlineColor, _currentProject.TemplateOpacity);
            string back = "&H00000000";
            int boldFlag = (_currentProject.TemplateFontWeight >= 600) ? -1 : 0;
            int italicFlag = _currentProject.TemplateIsItalic ? -1 : 0;
            int underlineFlag = _currentProject.TemplateIsUnderlined ? -1 : 0;
            double assDefaultFontSize = _currentProject.TemplateFontSize * scaleFactor / 0.985;
            sb.AppendLine(
                $"Style: Default,{_currentProject.TemplateFontFamily}," +
                $"{assDefaultFontSize.ToString("F2", CultureInfo.InvariantCulture)}," +
                            $"{primary},{secondary},{outline},{back}," +
                $"{boldFlag},{italicFlag},{underlineFlag},0," +
                $"100,100,{_currentProject.TemplateCharacterSpacing},0,1," +
                $"{_currentProject.TemplateOutlineThickness}," +
                $"{_currentProject.TemplateShadowDepth},5,10,10,10,1");
            sb.AppendLine(
        $"Style: ShapeBG,{_currentProject.TemplateFontFamily}," +
        $"{assDefaultFontSize.ToString("F2", CultureInfo.InvariantCulture)}," +
                $"&H00FFFFFF,&H00000000,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,0,0,2,10,10,10,1");
            sb.AppendLine();
            sb.AppendLine("[Events]");
            sb.AppendLine("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text");
            var allEntries = new List<(SrtSubtitleLine Line, TimeSpan FinalStart, TimeSpan FinalEnd, bool IsFromSmartCut)>();
            
            // Trong chế độ StaticReview, chỉ bao gồm phụ đề thực sự có trên timeline
            // Vì smartCutTimeline được tạo từ voice/TTS mapping (cho mục đích timing)
            // nhưng user có thể đã xóa phụ đề khỏi timeline để xuất video không có phụ đề
            HashSet<int> timelineSubtitleIndices = null;
            if (_currentSmartCutMode == SmartCutMode.StaticReview)
            {
                timelineSubtitleIndices = GetTimelineSubtitleIndices();
            }
            
            if (smartCutTimeline != null && smartCutTimeline.Any())
            {
                foreach (var item in smartCutTimeline)
                {
                    // Trong StaticReview mode, chỉ bao gồm phụ đề có trên timeline
                    if (_currentSmartCutMode == SmartCutMode.StaticReview && 
                        timelineSubtitleIndices != null && 
                        !timelineSubtitleIndices.Contains(item.Line.Index))
                    {
                        continue; // Bỏ qua phụ đề không có trên timeline
                    }
                    allEntries.Add((item.Line, item.FinalStart, item.FinalEnd, true));
                }
            }
            if (_currentProject?.TextClips != null)
            {
                var smartCutIndices = new HashSet<int>(smartCutTimeline?.Select(x => x.Line.Index) ?? Enumerable.Empty<int>());

                foreach (var textClip in _currentProject.TextClips)
                {
                    // Trong StaticReview mode, chỉ bao gồm TextClip có trên timeline
                    if (_currentSmartCutMode == SmartCutMode.StaticReview && 
                        timelineSubtitleIndices != null && 
                        !timelineSubtitleIndices.Contains(textClip.Index))
                    {
                        continue; // Bỏ qua TextClip không có trên timeline
                    }
                    
                    if (!smartCutIndices.Contains(textClip.Index) && !string.IsNullOrWhiteSpace(textClip.OriginalText))
                    {
                        allEntries.Add((textClip, textClip.StartTime, textClip.EndTime, false));
                    }
                }
            }
            if (!allEntries.Any())
            {
                return sb.ToString();
            }
            allEntries = allEntries.OrderBy(x => x.FinalStart).ToList();

            foreach (var item in allEntries)
            {
                var line = item.Line;
                const double fps = 30.0;
                var startQ = SnapToFps(item.FinalStart, fps);
                var endQ = SnapToFps(item.FinalEnd, fps);
                string start = startQ.ToString(@"h\:mm\:ss\.ff", CultureInfo.InvariantCulture);
                string end = endQ.ToString(@"h\:mm\:ss\.ff", CultureInfo.InvariantCulture);

                string rawText = _currentProject.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated && !string.IsNullOrWhiteSpace(line.TranslatedText)
            ? line.TranslatedText
            : line.OriginalText;
                StyleState style;
                if (line.IsTextClip)
                {
                    style = (line.Style ?? _currentProject.GetTemplateAsStyleState()).Clone();
                }
                else
                {
                    style = (line.Style ?? _currentProject.GetTemplateAsStyleState()).Clone();
                }
                double effectiveWrapWidthPx = ComputeEffectiveWrapWidthPx(style, scaleFactor, rawText);


                bool isTranslated = (_currentProject?.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated);
                string manualOverride = isTranslated ? line.AssOverrideTranslated : line.AssOverrideOriginal;

                string textForAss;
                if (line.HasManualAssOverride && !string.IsNullOrEmpty(manualOverride))
                {
                    textForAss = manualOverride.Replace("\r\n", @"\N").Replace("\n", @"\N");
                }
                else
                {
                    string tempRaw = rawText ?? string.Empty;
                    if (style.AllowAutoWrap && effectiveWrapWidthPx < double.PositiveInfinity)
                        textForAss = WrapTextForAssSmart(tempRaw, style, effectiveWrapWidthPx, scaleFactor);
                    else
                        textForAss = tempRaw.Replace("\r\n", @"\N").Replace("\n", @"\N");
                }
                var styleForMeasure = style.Clone();
                styleForMeasure.ScaleX = 1.0;
                styleForMeasure.ScaleY = 1.0;

                var (measuredWLogical, measuredHLogical) = MeasureTextBoxPixels_UsingTextBlock(
                    textForAss.Replace("\\N", "\n"),
                    styleForMeasure,
                    scaleFactor,
                    double.PositiveInfinity
                );
                double contentWpx = measuredWLogical * style.ScaleX * scaleFactor;
                double contentHpx = measuredHLogical * style.ScaleY * scaleFactor;
                var (padXpx, padYpx) = ComputeFinalPaddingPx(style, scaleFactor);
                double rectW = contentWpx + (padXpx * 2.0);
                double rectH = contentHpx + (padYpx * 2.0);
                int px = (int)Math.Round(style.X * playResX);
                int py = (int)Math.Round(style.Y * playResY);
                if (style.IsBackgroundEnabled)
                {
                    int left = (int)Math.Floor(px - rectW / 2.0);
                    int top = (int)Math.Floor(py - rectH / 2.0);
                    double rx = style.BackgroundCornerRadius * style.ScaleX * scaleFactor;
                    double ry = style.BackgroundCornerRadius * style.ScaleY * scaleFactor;
                    string path = (style.BackgroundCornerRadius > 0)
                        ? BuildRoundedRectPath(rectW, rectH, rx, ry)
                        : BuildTopLeftRectPath(rectW, rectH);
                    var (assColorNoAlpha, assAlpha) = HexToAssColorAndAlpha(style.BackgroundColorHex, style.Opacity);

                    var bgTags = new StringBuilder();
                    bgTags.Append(@"\an7");
                    bgTags.Append($"\\pos({left},{top})");
                    if (Math.Abs(style.Rotation) > double.Epsilon)
                    {
                        int orgAbsX = left + (int)Math.Round(rectW / 2.0);
                        int orgAbsY = top + (int)Math.Round(rectH / 2.0);
                        bgTags.Append($"\\org({orgAbsX},{orgAbsY})");
                        bgTags.Append($"\\frz{(-style.Rotation).ToString("F2", CultureInfo.InvariantCulture)}");
                    }

                    bgTags.Append($"\\1c{assColorNoAlpha}\\1a{assAlpha}\\bord0\\shad0\\p1");

                    sb.AppendLine($"Dialogue: 0,{start},{end},ShapeBG,,0,0,0,,{{{bgTags}}}{path}{{\\p0}}");
                }
                string textTags = GenerateAssOverrideTags_TextOnly(style, playResX, playResY, rectW, padXpx, scaleFactor);
                sb.AppendLine($"Dialogue: 1,{start},{end},Default,,0,0,0,,{{{textTags}}}{textForAss}");
            }
            return sb.ToString();
        }
        private string GenerateAssFileContent(int playResX, int playResY)
        {
            const double REFERENCE_HEIGHT = 720.0;
            double scaleFactor = playResY / REFERENCE_HEIGHT;
            var sb = new StringBuilder();
            sb.AppendLine("[Script Info]");
            sb.AppendLine($"Title: Generated by AIOSubPhim - {DateTime.Now}");
            sb.AppendLine($"PlayResX: {playResX}");
            sb.AppendLine($"PlayResY: {playResY}");
            sb.AppendLine("WrapStyle: 2");
            sb.AppendLine("ScaledBorderAndShadow: yes");
            sb.AppendLine();
            sb.AppendLine("[V4+ Styles]");
            sb.AppendLine("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding");
            string primary = HexToAssStyleColor(_currentProject.TemplateFontColor, _currentProject.TemplateOpacity);
            string secondary = primary;
            string outline = HexToAssStyleColor(_currentProject.TemplateOutlineColor, _currentProject.TemplateOpacity);
            string back = "&H00000000";
            int boldFlag = (_currentProject.TemplateFontWeight >= 600) ? -1 : 0;
            int italicFlag = _currentProject.TemplateIsItalic ? -1 : 0;
            int underlineFlag = _currentProject.TemplateIsUnderlined ? -1 : 0;
            double assDefaultFontSize = _currentProject.TemplateFontSize * scaleFactor / 0.988;
            sb.AppendLine(
                $"Style: Default,{_currentProject.TemplateFontFamily}," +
                $"{assDefaultFontSize.ToString("F2", CultureInfo.InvariantCulture)}," +
                            $"{primary},{secondary},{outline},{back}," +
                $"{boldFlag},{italicFlag},{underlineFlag},0," +
                $"100,100,{_currentProject.TemplateCharacterSpacing},0,1," +
                $"{_currentProject.TemplateOutlineThickness}," +
                $"{_currentProject.TemplateShadowDepth},5,10,10,10,1");

            sb.AppendLine(
        $"Style: ShapeBG,{_currentProject.TemplateFontFamily}," +
        $"{assDefaultFontSize.ToString("F2", CultureInfo.InvariantCulture)}," +
                $"&H00FFFFFF,&H00000000,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,0,0,2,10,10,10,1");

            sb.AppendLine();
            sb.AppendLine("[Events]");
            sb.AppendLine("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text");
            var timelineSubtitleLines = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Subtitle || c.ClipType == TimelineClipType.Text)
                .Select(c => c.SourceData as SrtSubtitleLine)
                .Where(s => s != null)
                .Distinct()
                .OrderBy(x => x.StartTime)
                .ToList();
            foreach (var line in timelineSubtitleLines)
            {
                string start = line.StartTime.ToString(@"h\:mm\:ss\.ff", CultureInfo.InvariantCulture);
                string end = line.EndTime.ToString(@"h\:mm\:ss\.ff", CultureInfo.InvariantCulture);

                string rawText = _currentProject.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated && !string.IsNullOrWhiteSpace(line.TranslatedText)
            ? line.TranslatedText
            : line.OriginalText;
                StyleState style;
                if (line.IsTextClip)
                {
                    style = (line.Style ?? _currentProject.GetTemplateAsStyleState()).Clone();
                }
                else
                {
                    style = (line.Style ?? _currentProject.GetTemplateAsStyleState()).Clone();
                }
                double effectiveWrapWidthPx = ComputeEffectiveWrapWidthPx(style, scaleFactor, rawText);

                bool isTranslated = (_currentProject?.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated);
                string manualOverride = isTranslated ? line.AssOverrideTranslated : line.AssOverrideOriginal;

                string textForAss;
                if (line.HasManualAssOverride && !string.IsNullOrEmpty(manualOverride))
                {
                    textForAss = manualOverride.Replace("\r\n", @"\N").Replace("\n", @"\N");
                }
                else
                {
                    string tempRaw = rawText ?? string.Empty;
                    if (style.AllowAutoWrap && effectiveWrapWidthPx < double.PositiveInfinity)
                        textForAss = WrapTextForAssSmart(tempRaw, style, effectiveWrapWidthPx, scaleFactor);
                    else
                        textForAss = tempRaw.Replace("\r\n", @"\N").Replace("\n", @"\N");
                }
                var styleForMeasure = style.Clone();
                styleForMeasure.ScaleX = 1.0;
                styleForMeasure.ScaleY = 1.0;

                var (measuredWLogical, measuredHLogical) = MeasureTextBoxPixels_UsingTextBlock(
                    textForAss.Replace("\\N", "\n"),
                    styleForMeasure,
                    scaleFactor,
                    double.PositiveInfinity
                );
                double contentWpx = measuredWLogical * style.ScaleX * scaleFactor;
                double contentHpx = measuredHLogical * style.ScaleY * scaleFactor;
                var (padXpx, padYpx) = ComputeFinalPaddingPx(style, scaleFactor);
                double rectW = contentWpx + (padXpx * 2.0);
                double rectH = contentHpx + (padYpx * 2.0);
                int px = (int)Math.Round(style.X * playResX);
                int py = (int)Math.Round(style.Y * playResY);
                if (style.IsBackgroundEnabled)
                {
                    int left = (int)Math.Floor(px - rectW / 2.0);
                    int top = (int)Math.Floor(py - rectH / 2.0);
                    double rx = style.BackgroundCornerRadius * style.ScaleX * scaleFactor;
                    double ry = style.BackgroundCornerRadius * style.ScaleY * scaleFactor;
                    string path = (style.BackgroundCornerRadius > 0)
                        ? BuildRoundedRectPath(rectW, rectH, rx, ry)
                        : BuildTopLeftRectPath(rectW, rectH);

                    var (assColorNoAlpha, assAlpha) = HexToAssColorAndAlpha(style.BackgroundColorHex, style.Opacity);
                    var bgTags = new StringBuilder();
                    bgTags.Append(@"\an7");
                    bgTags.Append($"\\pos({left},{top})");
                    if (Math.Abs(style.Rotation) > double.Epsilon)
                    {
                        int orgAbsX = left + (int)Math.Round(rectW / 2.0);
                        int orgAbsY = top + (int)Math.Round(rectH / 2.0);
                        bgTags.Append($"\\org({orgAbsX},{orgAbsY})");
                        bgTags.Append($"\\frz{(-style.Rotation).ToString("F2", CultureInfo.InvariantCulture)}");
                    }

                    bgTags.Append($"\\1c{assColorNoAlpha}\\1a{assAlpha}\\bord0\\shad0\\p1");

                    sb.AppendLine($"Dialogue: 0,{start},{end},ShapeBG,,0,0,0,,{{{bgTags}}}{path}{{\\p0}}");
                }
                string textTags = GenerateAssOverrideTags_TextOnly(style, playResX, playResY, rectW, padXpx, scaleFactor);
                sb.AppendLine($"Dialogue: 1,{start},{end},Default,,0,0,0,,{{{textTags}}}{textForAss}");
            }
            return sb.ToString();
        }
        private static (double padXpx, double padYpx) ComputeFinalPaddingPx(StyleState style, double scaleFactor)
        {
            double sx = (style?.ScaleX ?? 1.0);
            double sy = (style?.ScaleY ?? 1.0);
            double padXpx = (style?.BackgroundPaddingX ?? 0.0) * sx * scaleFactor;
            double padYpx = (style?.BackgroundPaddingY ?? 0.0) * sy * scaleFactor;
            return (padXpx, padYpx);
        }
        private (double measuredWpx, double measuredHpx) MeasureTextBoxPixels_UsingTextBlock(string text, StyleState style, double scaleFactor, double wrapWidthPx)
        {
            var tb = new TextBlock
            {
                Text = text ?? string.Empty,
                TextWrapping = TextWrapping.NoWrap,
                TextTrimming = TextTrimming.None
            };
            tb.FontFamily = new System.Windows.Media.FontFamily(style.FontFamilyName ?? "Arial");
            tb.FontWeight = FontWeight.FromOpenTypeWeight(style.FontWeightValue);
            tb.FontStyle = style.IsItalic ? FontStyles.Italic : FontStyles.Normal;
            double correctedFontSize = style.FontSize * WPF_FONT_SIZE_CORRECTION_FACTOR;
            tb.FontSize = correctedFontSize;
            tb.TextAlignment = TextAlignment.Center;
            tb.Measure(new System.Windows.Size(double.PositiveInfinity, double.PositiveInfinity));
            System.Windows.Size desired = tb.DesiredSize;
            return (desired.Width, desired.Height);
        }
        private double ComputeEffectiveWrapWidthPx(StyleState style, double pxPerLogicalUnit, string rawTextForMeasure)
        {
            if (style.FixedTextBoxWidth > 1.0)
                return Math.Max(1.0, style.FixedTextBoxWidth);
            if (style.Width.HasValue && style.Width.Value > 1.0)
            {
                double totalPreviewPx = style.Width.Value * pxPerLogicalUnit;
                double padLR = (style.IsBackgroundEnabled ? (2.0 * style.BackgroundPaddingX * pxPerLogicalUnit) : 0.0);
                double contentPreviewPx = Math.Max(1.0, totalPreviewPx - padLR);
                return contentPreviewPx;
            }
            var styleForMeasure = style.Clone();
            styleForMeasure.ScaleX = 1.0;
            styleForMeasure.ScaleY = 1.0;
            var (wLogical, _) = MeasureTextBoxPixels_UsingTextBlock(
                (rawTextForMeasure ?? string.Empty).Replace("\\N", "\n"),
                styleForMeasure,
                pxPerLogicalUnit,
                double.PositiveInfinity
            );
            double measuredPreviewPx = wLogical * style.ScaleX;
            var videoRect = GetReferenceVideoFrameRect();
            double videoWidthPx = Math.Max(1.0, videoRect.Width);
            double padXPreviewPx = (style.IsBackgroundEnabled
                ? (style.BackgroundPaddingX * style.ScaleX * pxPerLogicalUnit)
                : 0.0);
            double videoLimitForTextPx = Math.Max(1.0, videoWidthPx - 2.0 * padXPreviewPx);
            if (measuredPreviewPx <= videoLimitForTextPx)
                return double.PositiveInfinity;
            return videoLimitForTextPx;
        }

        private string WrapTextForAssSmart(string raw, StyleState style, double effectiveWrapWidthPx, double pxPerLogicalUnit)
        {
            if (double.IsPositiveInfinity(effectiveWrapWidthPx))
                return (raw ?? string.Empty).Replace("\r\n", @"\N").Replace("\n", @"\N");

            raw ??= string.Empty;
            var tb = new System.Windows.Controls.TextBlock
            {
                FontFamily = new System.Windows.Media.FontFamily(style.FontFamilyName),
                FontSize = style.FontSize * pxPerLogicalUnit * WPF_FONT_SIZE_CORRECTION_FACTOR,

                FontWeight = System.Windows.FontWeight.FromOpenTypeWeight(style.FontWeightValue),
                FontStyle = style.IsItalic ? FontStyles.Italic : FontStyles.Normal,
                TextWrapping = TextWrapping.NoWrap
            };
            double Measure(string text)
            {
                tb.Text = text;
                tb.Measure(new System.Windows.Size(double.PositiveInfinity, double.PositiveInfinity));
                return tb.DesiredSize.Width;
            }
            var userBlocks = raw.Replace("\r\n", "\n").Split('\n');

            var ass = new System.Text.StringBuilder();
            for (int b = 0; b < userBlocks.Length; b++)
            {
                string block = userBlocks[b];
                if (string.IsNullOrEmpty(block))
                {
                    if (ass.Length > 0) ass.Append("\\N");
                    continue;
                }
                var tokens = System.Text.RegularExpressions.Regex.Matches(block, @"\S+|\s+|[^\w\s]")
                                .Select(m => m.Value).ToList();

                string current = string.Empty;

                foreach (var tok in tokens)
                {
                    string candidate = current + tok;
                    double w = Measure(candidate);

                    if (w <= effectiveWrapWidthPx || current.Length == 0)
                    {
                        current = candidate;
                    }
                    else
                    {
                        if (ass.Length > 0) ass.Append("\\N");
                        ass.Append(current.TrimEnd());
                        current = tok.TrimStart();
                    }
                }

                if (!string.IsNullOrEmpty(current))
                {
                    if (ass.Length > 0) ass.Append("\\N");
                    ass.Append(current.TrimEnd());
                }
            }

            return ass.ToString();
        }
        private void ComputeAndStoreManualAssOverrideForResize(SrtSubtitleLine anyLine, StyleState styleOfAnyLine, double committedActualWidthPx)
        {
            if (anyLine == null || styleOfAnyLine == null) return;
            double pxPerLogical = ComputePlayerScaleFactor();
            double padLRpx = styleOfAnyLine.IsBackgroundEnabled ? (2.0 * styleOfAnyLine.BackgroundPaddingX * styleOfAnyLine.ScaleX * pxPerLogical) : 0.0;
            double newFixedTextWidthPx = Math.Max(1.0, committedActualWidthPx - padLRpx);
            double newLogicalWidth = Math.Max(1.0, newFixedTextWidthPx / pxPerLogical);
            _currentProject.TemplateWidth = newLogicalWidth;
            IEnumerable<SrtSubtitleLine> all =
                (_currentProject.Subtitles ?? Enumerable.Empty<SrtSubtitleLine>())
                .Concat(_currentProject.TextClips ?? Enumerable.Empty<SrtSubtitleLine>());

            foreach (var line in all)
            {
                var st = (line.Style ?? _currentProject.GetTemplateAsStyleState()).Clone();

                st.Width = newLogicalWidth;
                st.FixedTextBoxWidth = newFixedTextWidthPx;
                line.Style = st;

                bool isTranslated = (_currentProject?.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated);
                string raw = isTranslated ? (line.TranslatedText ?? "") : (line.OriginalText ?? "");
                double wrapWidthPx = ComputeEffectiveWrapWidthPx(st, pxPerLogical, raw);
                string wrapped = WrapTextForAssSmart(raw, st, wrapWidthPx, pxPerLogical);
                if (isTranslated)
                    line.AssOverrideTranslated = wrapped;
                else
                    line.AssOverrideOriginal = wrapped;

                line.HasManualAssOverride = true;
            }

            SaveProjectCurrent();
        }
        private void CollectAndSendPaddingSample(SrtSubtitleLine line, FrameworkElement visual)
        {
            try
            {
                if (line == null || visual == null) return;
                if (!(visual is Border outer)) return;
                if (!(outer.Child is Border inner)) return;
                if (!(inner.Child is FrameworkElement textElem)) return;
                var style = line.Style ?? new Models.StyleState();

                outer.UpdateLayout();
                inner.UpdateLayout();
                textElem.UpdateLayout();
                double contentW = textElem.ActualWidth;
                double padLR = inner.Padding.Left + inner.Padding.Right;
                double previewNoScaleW = contentW + padLR;
                double previewScaledW = previewNoScaleW * style.ScaleX;
                double renderSizeW = outer.RenderSize.Width;
                var canvas = outer.Parent as Canvas;
                if (canvas == null) return;
                System.Windows.Rect bounds = new System.Windows.Rect(new System.Windows.Point(0, 0), outer.RenderSize);
                GeneralTransform toCanvas = outer.TransformToAncestor(canvas);
                System.Windows.Rect transformed = toCanvas.TransformBounds(bounds);
                double transformedW = transformed.Width;
                string text = (textElem is TextBlock tb) ? tb.Text : (textElem as TextBox)?.Text ?? "";
            }
            catch (Exception ex)
            {
            }
        }
        private string BuildRoundedRectPath(double widthPx, double heightPx, double rx, double ry)
        {
            double w = Math.Max(0, widthPx);
            double h = Math.Max(0, heightPx);
            double rX = Math.Min(Math.Max(0, rx), w / 2.0);
            double rY = Math.Min(Math.Max(0, ry), h / 2.0);

            if (rX <= 0.0001 && rY <= 0.0001)
                return BuildTopLeftRectPath(w, h);
            const double K = 0.5522847498307936;
            double cX = rX * K;
            double cY = rY * K;
            int W = (int)Math.Round(w);
            int H = (int)Math.Round(h);
            int RX = (int)Math.Round(rX);
            int RY = (int)Math.Round(rY);
            int CX = (int)Math.Round(cX);
            int CY = (int)Math.Round(cY);
            var sb = new StringBuilder();
            sb.Append($"m {RX} 0 ");
            sb.Append($"l {W - RX} 0 ");
            sb.Append($"b {W - RX + CX} 0 {W} {RY - CY} {W} {RY} ");
            sb.Append($"l {W} {H - RY} ");
            sb.Append($"b {W} {H - RY + CY} {W - RX + CX} {H} {W - RX} {H} ");
            sb.Append($"l {RX} {H} ");
            sb.Append($"b {RX - CX} {H} 0 {H - RY + CY} 0 {H - RY} ");
            sb.Append($"l 0 {RY} ");
            sb.Append($"b 0 {RY - CY} {RX - CX} 0 {RX} 0");
            return sb.ToString();
        }

        private string BuildTopLeftRectPath(double widthPx, double heightPx)
        {
            int w = (int)Math.Round(widthPx);
            int h = (int)Math.Round(heightPx);
            return $"m 0 0 l {w} 0 {w} {h} 0 {h}";
        }
        private static (string assColorNoAlpha, string assAlpha) HexToAssColorAndAlpha(string hex, double opacityFactor = 1.0)
        {
            try
            {
                var c = (System.Windows.Media.Color)ColorConverter.ConvertFromString(hex);
                double opHex = c.A / 255.0;
                double opFinal = Math.Max(0, Math.Min(1, opacityFactor)) * opHex;
                byte assAA = (byte)(255 - Math.Round(opFinal * 255.0));
                string color = $"&H{c.B:X2}{c.G:X2}{c.R:X2}&";
                string alpha = $"&H{assAA:X2}&";
                return (color, alpha);
            }
            catch
            {
                return ("&HFFFFFF&", "&H00&");
            }
        }
        private string GenerateAssOverrideTags_TextOnly(StyleState style, int playResX, int playResY, double rectW, double padXpx, double scaleFactor)
        {
            if (style == null) return string.Empty;
            var inv = CultureInfo.InvariantCulture;
            var sb = new StringBuilder();
            int alignmentTag;
            int px = (int)Math.Round(style.X * playResX);
            int py = (int)Math.Round(style.Y * playResY);

            int textX = px;
            int textY = py;

            switch (style.Alignment)
            {
                case 1:
                    alignmentTag = 4;
                    int backgroundLeftEdge = px - (int)Math.Round(rectW / 2.0);
                    textX = backgroundLeftEdge + (int)Math.Round(padXpx);
                    break;
                case 3:
                    alignmentTag = 6;
                    int backgroundRightEdge = px + (int)Math.Round(rectW / 2.0);
                    textX = backgroundRightEdge - (int)Math.Round(padXpx);
                    break;
                case 4:
                case 2:
                default:
                    alignmentTag = 5;
                    break;
            }
            sb.Append($"\\an{alignmentTag}");
            sb.Append(@"\q2");
            sb.Append($"\\pos({textX},{textY})");
            if (Math.Abs(style.Rotation) > double.Epsilon)
            {
                sb.Append($"\\org({px},{py})");
                sb.Append($"\\frz{(-style.Rotation).ToString("F2", inv)}");

            }
            sb.Append($"\\fscx{(style.ScaleX * 100.0).ToString("F2", inv)}");
            sb.Append($"\\fscy{(style.ScaleY * 100.0).ToString("F2", inv)}");
            sb.Append($"\\fn{style.FontFamilyName ?? "Arial"}");
            double assOverrideFontSize = style.FontSize * scaleFactor / 0.988;

            sb.Append($"\\fs{assOverrideFontSize.ToString("F2", inv)}");
            sb.Append($"\\b{(style.FontWeightValue > 500 ? 1 : 0)}");
            sb.Append($"\\i{(style.IsItalic ? 1 : 0)}");
            sb.Append($"\\u{(style.IsUnderlined ? 1 : 0)}");
            var (ass1c, ass1a) = HexToAssColorAndAlpha(style.FontColorHex, style.Opacity);
            sb.Append($"\\1c{ass1c}\\1a{ass1a}");
            if (style.EdgeStyle == TextEdgeStyle.Outline && !style.IsBackgroundEnabled)
            {
                var (ass3c, ass3a) = HexToAssColorAndAlpha(style.OutlineColorHex, style.Opacity);
                sb.Append($"\\3c{ass3c}\\3a{ass3a}");
                sb.Append($"\\bord{style.OutlineThickness.ToString("F2", inv)}");
                sb.Append("\\shad0");
            }
            else if (style.EdgeStyle == TextEdgeStyle.Shadow && !style.IsBackgroundEnabled)
            {
                var (ass4c, ass4a) = HexToAssColorAndAlpha(style.ShadowColorHex, style.Opacity);
                sb.Append($"\\4c{ass4c}\\4a{ass4a}");
                sb.Append($"\\shad{style.ShadowDepth.ToString("F2", inv)}");
                sb.Append($"\\blur{style.ShadowBlur.ToString("F2", inv)}");
                sb.Append("\\bord0");
            }
            else
            {
                sb.Append("\\bord0\\shad0");
            }

            return sb.ToString();
        }
        private static string HexToAssStyleColor(string hex, double masterOpacity)
        {
            try
            {
                var c = (System.Windows.Media.Color)ColorConverter.ConvertFromString(hex);
                double opHex = c.A / 255.0;
                double opFinal = Math.Max(0, Math.Min(1, masterOpacity)) * opHex;
                byte assAA = (byte)(255 - Math.Round(opFinal * 255.0));
                return $"&H{assAA:X2}{c.B:X2}{c.G:X2}{c.R:X2}";
            }
            catch
            {
                return "&H00FFFFFF";
            }
        }
        #region Subtitle Clip Drag-Move Logic

        private void SubtitleClip_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (e.OriginalSource is Border || e.OriginalSource is TextBlock || e.OriginalSource is Grid || e.OriginalSource is Canvas || e.OriginalSource is System.Windows.Controls.Image)
            {
                if (sender is FrameworkElement element && element.DataContext is TimelineClipViewModel vm)
                {
                    _isDraggingClip = true;
                    _draggedClipVM = vm;
                    _dragInitialMouseX = e.GetPosition(TracksContainerGrid).X;
                    _dragInitialStartTime = vm.StartTime;
                    _dragInitialEndTime = vm.EndTime;

                    element.CaptureMouse();
                    e.Handled = true;
                }
            }
        }
        private void SubtitleClip_PreviewMouseMove(object sender, MouseEventArgs e)
        {
            if (!_isDraggingTimelineClip || _draggedTimelineClip == null) return;

            System.Windows.Point currentMousePos = e.GetPosition(TracksContainerGrid);
            double deltaX = currentMousePos.X - _dragClipStartPoint.X;
            double deltaY = currentMousePos.Y - _dragClipStartPoint.Y;
            _draggedTimelineClip.X = _dragClipInitialX + deltaX;
            _draggedTimelineClip.Y = _dragClipInitialY + deltaY;
        }

        private void SubtitleClip_PreviewMouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            if (_isDraggingClip)
            {

                if (sender is FrameworkElement element)
                {
                    element.ReleaseMouseCapture();
                }
                UpdateTimelineScaleAndRender();
                _undoRedoService.AddState(CaptureEditorSnapshot());
                SaveProjectCurrent();
                if (_draggedClipVM != null)
                {

                }

                _isDraggingClip = false;
                _draggedClipVM = null;
                e.Handled = true;
            }
        }
        #endregion

        private string BuildBlurBoxFilter(string videoInLabel, string videoOutLabel, ProjectState project, bool burnSubtitles, TimeSpan? forceFullDuration = null, bool emitDebug = false)
        {
            static string Q(string expr)
            {
                if (string.IsNullOrEmpty(expr)) return "''";
                return "'" + expr.Replace("\\", "\\\\").Replace("'", "\\'") + "'";
            }
            bool isStaticReview = _currentSmartCutMode == SmartCutMode.StaticReview;
            if (project != null)
            {

                if (project.BlurRectNormalized != null)
                {
                }
            }
            var effectiveRect = project?.BlurRectNormalized ?? (isStaticReview ? new System.Windows.Rect(0, 0, 1, 1) : null);
            var effectiveBlurMode = project?.BlurMode ?? ProjectState.BlurApplyMode.None;
            if (effectiveRect == null && effectiveBlurMode != ProjectState.BlurApplyMode.None)
            {
                effectiveRect = new System.Windows.Rect(0, 0, 1, 1);
            }
            if (isStaticReview && effectiveBlurMode == ProjectState.BlurApplyMode.PerSubtitle)
            {
                effectiveBlurMode = ProjectState.BlurApplyMode.AllTime;
            }
            if (project == null ||
                effectiveBlurMode == ProjectState.BlurApplyMode.None ||
                effectiveRect == null)
            {
                string skipReason = project == null ? "project is null" :
                                   effectiveBlurMode == ProjectState.BlurApplyMode.None ? "BlurMode is None" :
                                   "BlurRectNormalized is null";
                return $"[{videoInLabel}]null[{videoOutLabel}]";
            }
            var ci = System.Globalization.CultureInfo.InvariantCulture;
            var rect = effectiveRect.Value;
            double nx = Math.Max(0.0, Math.Min(1.0, rect.X));
            double ny = Math.Max(0.0, Math.Min(1.0, rect.Y));
            double nw = Math.Max(0.0, Math.Min(1.0, rect.Width));
            double nh = Math.Max(0.0, Math.Min(1.0, rect.Height));
            string wExprCrop = $"max(1,{nw.ToString(ci)}*iw)";
            string hExprCrop = $"max(1,{nh.ToString(ci)}*ih)";
            string xExprCrop = $"clip({nx.ToString(ci)}*iw,0,iw-({wExprCrop}))";
            string yExprCrop = $"clip({ny.ToString(ci)}*ih,0,ih-({hExprCrop}))";
            string wExprOv = wExprCrop.Replace("iw", "main_w").Replace("ih", "main_h");
            string hExprOv = hExprCrop.Replace("iw", "main_w").Replace("ih", "main_h");
            string xExprOv = $"clip({nx.ToString(ci)}*main_w,0,main_w-({wExprOv}))";
            string yExprOv = $"clip({ny.ToString(ci)}*main_h,0,main_h-({hExprOv}))";
            double sigma = Math.Max(0.1, project.BlurPreviewRadius * 0.75);
            string enableExpr = "1";
            var intervalsSeconds = new List<(double Start, double End)>();

            if (isStaticReview)
            {
                double fullDurSeconds = 0;
                if (forceFullDuration.HasValue && forceFullDuration.Value > TimeSpan.Zero)
                {
                    fullDurSeconds = forceFullDuration.Value.TotalSeconds;
                }
                else if (_actualContentDuration > TimeSpan.Zero)
                {
                    fullDurSeconds = _actualContentDuration.TotalSeconds;
                }
                else if (_totalTimelineDuration > TimeSpan.Zero)
                {
                    fullDurSeconds = _totalTimelineDuration.TotalSeconds;
                }

                if (fullDurSeconds > 0)
                {
                    enableExpr = $"between(t,0,{fullDurSeconds.ToString(ci)})";
                    intervalsSeconds.Add((0.0, fullDurSeconds));
                }
                else
                {
                    enableExpr = "1";
                }
            }
            else if (effectiveBlurMode == ProjectState.BlurApplyMode.AllTime)
            {
                if (forceFullDuration.HasValue && forceFullDuration.Value > TimeSpan.Zero)
                {
                    double T = forceFullDuration.Value.TotalSeconds;
                    enableExpr = $"between(t,0,{T.ToString(ci)})";
                    intervalsSeconds.Add((0.0, T));
                }
                else
                {
                    enableExpr = "1";
                }
            }
            else
            {
                if (_currentSmartCutMode == SmartCutMode.StaticReview &&
                    _smartCutSubtitleTimeline != null && _smartCutSubtitleTimeline.Count > 0)
                {
                    foreach (var item in _smartCutSubtitleTimeline)
                    {
                        double s = Math.Max(0.0, item.FinalStart.TotalSeconds);
                        double e = Math.Max(s + 1e-6, item.FinalEnd.TotalSeconds);
                        intervalsSeconds.Add((s, e));
                    }
                }
                else
                {
                    if (burnSubtitles)
                    {
                        foreach (var line in project.Subtitles.OrderBy(l => l.StartTime))
                        {
                            double s = Math.Max(0.0, line.StartTime.TotalSeconds);
                            double e = Math.Max(s + 1e-6, line.EndTime.TotalSeconds);
                            intervalsSeconds.Add((s, e));
                        }
                    }
                    else
                    {
                        if (_exportCachedBlurIntervals != null && _exportCachedBlurIntervals.Count > 0)
                        {
                            foreach (var (start, end) in _exportCachedBlurIntervals)
                            {
                                double s = Math.Max(0.0, start.TotalSeconds);
                                double e = Math.Max(s + 1e-6, end.TotalSeconds);
                                intervalsSeconds.Add((s, e));
                            }
                        }
                        else
                        {
                            foreach (var line in project.Subtitles.OrderBy(l => l.StartTime))
                            {
                                double s = Math.Max(0.0, line.StartTime.TotalSeconds);
                                double e = Math.Max(s + 1e-6, line.EndTime.TotalSeconds);
                                intervalsSeconds.Add((s, e));
                            }
                        }
                    }
                }
                _exportCachedBlurIntervals = intervalsSeconds
                    .Select(iv => (TimeSpan.FromSeconds(iv.Start), TimeSpan.FromSeconds(iv.End)))
                    .ToList();
                if (intervalsSeconds.Count == 0)
                {
                    enableExpr = "0";
                }
                else
                {
                    var parts = intervalsSeconds.Select(iv =>
                        $"between(t,{iv.Start.ToString(ci)},{iv.End.ToString(ci)})");
                    enableExpr = string.Join("+", parts);
                }
            }
            string inOrig = $"{videoInLabel}_orig";
            string inCrop = $"{videoInLabel}_crop";
            string blurred = $"{videoInLabel}_blurred";
            string afterOverlay = $"{videoOutLabel}_tmpov";
            var sb = new System.Text.StringBuilder();
            sb.Append($"[{videoInLabel}]split[{inOrig}][{inCrop}];");
            sb.Append($"[{inCrop}]crop=w={Q(wExprCrop)}:h={Q(hExprCrop)}:x={Q(xExprCrop)}:y={Q(yExprCrop)},gblur=sigma={sigma.ToString(ci)}[{blurred}];");
            sb.Append($"[{inOrig}][{blurred}]overlay=x={Q(xExprOv)}:y={Q(yExprOv)}:enable='{enableExpr}'[{afterOverlay}]");
            if (emitDebug)
            {
                sb.Append($";[{afterOverlay}]drawbox=x={Q(xExprOv)}:y={Q(yExprOv)}:w={Q(wExprOv)}:h={Q(hExprOv)}:t=4:color=white@0.6[{videoOutLabel}]");
                try
                {
                    int exportW = (int)(project.ProjectReferenceVideoWidth > 0 ? project.ProjectReferenceVideoWidth : 1920);
                    int exportH = (int)(project.ProjectReferenceVideoHeight > 0 ? project.ProjectReferenceVideoHeight : 1080);
                    double wPx = Math.Max(1, nw * exportW);
                    double hPx = Math.Max(1, nh * exportH);
                    double xPx = Math.Max(0, Math.Min(nx * exportW, exportW - wPx));
                    double yPx = Math.Max(0, Math.Min(ny * exportH, exportH - hPx));
                    var log = new System.Text.StringBuilder();
                    log.AppendLine("=== BLUR DEBUG (Top-Left based) ===");
                    log.AppendLine($"Preview Normalized: X={nx.ToString(ci)}, Y={ny.ToString(ci)}, W={nw.ToString(ci)}, H={nh.ToString(ci)}");
                    log.AppendLine($"Export Size (est.): {exportW}x{exportH}");
                    log.AppendLine($"Pixel (approx.): X={xPx:F2}, Y={yPx:F2}, W={wPx:F2}, H={hPx:F2}");
                    log.AppendLine($"CROP  w={wExprCrop}  h={hExprCrop}  x={xExprCrop}  y={yExprCrop}");
                    log.AppendLine($"OVER  w={wExprOv}    h={hExprOv}    x={xExprOv}    y={yExprOv}");
                    log.AppendLine($"enable={enableExpr}");
                    var path = System.IO.Path.Combine(System.IO.Path.GetTempPath(), "AIOSubPhim_blur_debug.txt");
                    System.IO.File.WriteAllText(path, log.ToString());
                }
                catch { /* tránh crash  */ }
            }
            else
            {
                sb.Append($";[{afterOverlay}]null[{videoOutLabel}]");
            }

            return sb.ToString();
        }


        private void DownloadTtsButton_Click(object sender, RoutedEventArgs e)
        {
            if (string.IsNullOrEmpty(_currentTtsAudioPath) || !File.Exists(_currentTtsAudioPath))
            {
                CustomMessageBox.Show("Không có file âm thanh nào để tải về.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            var saveFileDialog = new SaveFileDialog
            {
                Title = "Lưu file âm thanh",
                Filter = "MP3 Audio (*.mp3)|*.mp3|WAV Audio (*.wav)|*.wav|All Files (*.*)|*.*",
                FileName = $"TTS_{DateTime.Now:yyyyMMdd_HHmmss}{Path.GetExtension(_currentTtsAudioPath)}"
            };

            if (saveFileDialog.ShowDialog() == true)
            {
                try
                {
                    File.Copy(_currentTtsAudioPath, saveFileDialog.FileName, true);
                }
                catch (Exception ex)
                {
                    CustomMessageBox.Show($"Lỗi khi lưu file: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }
        private BitmapImage LoadBitmapImage(string filePath)
        {
            if (string.IsNullOrEmpty(filePath) || !File.Exists(filePath))
            {
                return null;
            }
            try
            {
                var bitmap = new BitmapImage();
                bitmap.BeginInit();
                bitmap.UriSource = new Uri(filePath);
                bitmap.CacheOption = BitmapCacheOption.OnLoad;
                bitmap.EndInit();
                bitmap.Freeze();
                return bitmap;
            }
            catch (Exception ex)
            {
                return null;
            }
        }
        public static async Task<BitmapImage> GenerateVideoThumbnailAsync(string videoPath)
        {
            string thumbnailPath = TempFileManager.CreateTempFile(".jpg");
            try
            {
                var mediaInfo = await FFProbe.AnalyseAsync(videoPath);
                var duration = mediaInfo.Duration;
                var captureTime = duration.TotalSeconds > 10 ? TimeSpan.FromSeconds(duration.TotalSeconds * 0.1) : TimeSpan.FromSeconds(1);
                var snapshotSuccess = await FFMpeg.SnapshotAsync(videoPath, thumbnailPath, new System.Drawing.Size(120, -1), captureTime);
                if (!snapshotSuccess || !File.Exists(thumbnailPath))
                {
                    return null;
                }
                var bitmap = new BitmapImage();
                bitmap.BeginInit();
                bitmap.UriSource = new Uri(thumbnailPath);
                bitmap.CacheOption = BitmapCacheOption.OnLoad;
                bitmap.EndInit();
                bitmap.Freeze();
                return bitmap;
            }
            catch (Exception ex)
            {

                return null;
            }
            finally
            {
                if (File.Exists(thumbnailPath))
                {
                    try
                    {
                        File.Delete(thumbnailPath);
                    }
                    catch (Exception ex)
                    {
                    }
                }
            }
        }
        private async Task GenerateAndDisplayFilmstripAsync(TimelineClipViewModel clipVM, bool force = false)
        {
            if (clipVM == null ||
                clipVM.ClipType != TimelineClipType.Video ||
                string.IsNullOrEmpty(clipVM.FilePath))
            {
                return;
            }

            if (!_filmstripServiceInstances.TryGetValue(clipVM.FilePath, out var service))
            {
                return;
            }

            if (clipVM.SourceData is not MediaAsset mediaAsset)
            {
                return;
            }
            var trimStart = mediaAsset.TrimStartOffset;
            var trimEnd = mediaAsset.TrimEndOffset;
            var srcDuration = mediaAsset.Duration;
            var speed = mediaAsset.Speed <= 0 ? 1.0 : mediaAsset.Speed;
            var trimmed = srcDuration - trimStart - trimEnd;
            if (trimmed <= TimeSpan.Zero)
            {
                await Dispatcher.InvokeAsync(() => clipVM.FilmstripThumbnails.Clear());
                return;
            }
            var effectiveTimelineDuration = TimeSpan.FromSeconds(trimmed.TotalSeconds / speed);
            var clipWidthPx = Math.Max(1.0, effectiveTimelineDuration.TotalSeconds * _pixelsPerSecond);
            var desiredCount = (int)Math.Ceiling(clipWidthPx / FILMSTRIP_TILE_WIDTH);
            if (desiredCount < 1) desiredCount = 1;
            if (desiredCount > FILMSTRIP_MAX_FRAMES_PER_CLIP)
                desiredCount = FILMSTRIP_MAX_FRAMES_PER_CLIP;
            if (!force && _filmstripLayout.TryGetValue(clipVM, out var last) && last.Count > 0)
            {
                var delta = Math.Abs(desiredCount - last.Count) / (double)last.Count;
                if (delta < FILMSTRIP_REGEN_ZOOM_EPS)
                {
                    return;
                }
            }
            if (_filmstripTasks.TryRemove(clipVM, out var oldCts))
            {
                try { oldCts.Cancel(); } catch { }
                oldCts.Dispose();
            }
            var newCts = new CancellationTokenSource();
            if (!_filmstripTasks.TryAdd(clipVM, newCts))
            {
                newCts.Dispose();
                return;
            }

            var ct = newCts.Token;

            try
            {
                var stamps = new TimeSpan[desiredCount];
                var stepTimelineSeconds = effectiveTimelineDuration.TotalSeconds / desiredCount;
                if (stepTimelineSeconds <= 0)
                    stepTimelineSeconds = effectiveTimelineDuration.TotalSeconds;

                for (int i = 0; i < desiredCount; i++)
                {
                    double centerTimelineSec = (i + 0.5) * stepTimelineSeconds;
                    if (centerTimelineSec > effectiveTimelineDuration.TotalSeconds)
                        centerTimelineSec = effectiveTimelineDuration.TotalSeconds;
                    var tSrc = trimStart + TimeSpan.FromSeconds(centerTimelineSec * speed);
                    if (tSrc < TimeSpan.Zero) tSrc = TimeSpan.Zero;
                    if (tSrc > srcDuration) tSrc = srcDuration;

                    stamps[i] = tSrc;
                }
                var images = new BitmapImage[desiredCount];
                var tasks = new Task[desiredCount];
                for (int i = 0; i < desiredCount; i++)
                {
                    var idx = i;
                    tasks[idx] = Task.Run(async () =>
                    {
                        if (ct.IsCancellationRequested) return;
                        var img = await service.GetThumbnailAtAsync(stamps[idx], FILMSTRIP_TARGET_HEIGHT, ct)
                                               .ConfigureAwait(false);
                        images[idx] = img;
                    }, ct);
                }
                await Task.WhenAll(tasks).ConfigureAwait(false);
                if (ct.IsCancellationRequested) return;
                await Dispatcher.InvokeAsync(() =>
                {
                    if (ct.IsCancellationRequested) return;

                    clipVM.FilmstripThumbnails.Clear();
                    for (int i = 0; i < images.Length; i++)
                    {
                        var img = images[i];
                        if (img != null)
                        {
                            clipVM.FilmstripThumbnails.Add(img);
                        }
                    }
                    _filmstripLayout[clipVM] = (_pixelsPerSecond, desiredCount);
                });
            }
            catch (OperationCanceledException)
            {
            }
            catch (Exception ex)
            {
            }
            finally
            {
                if (_filmstripTasks.TryGetValue(clipVM, out var current) && current == newCts)
                {
                    _filmstripTasks.TryRemove(clipVM, out _);
                    newCts.Dispose();
                }
            }
        }
        private void UpdateFilmstripsForZoom()
        {
            if (VisibleTimelineClips == null || VisibleTimelineClips.Count == 0)
                return;

            foreach (var clip in VisibleTimelineClips)
            {
                if (clip == null) continue;
                if (clip.ClipType != TimelineClipType.Video) continue;
                if (string.IsNullOrEmpty(clip.FilePath)) continue;
                if (!_filmstripServiceInstances.ContainsKey(clip.FilePath)) continue;

                _ = GenerateAndDisplayFilmstripAsync(clip, force: false);
            }
        }
        private async void ImportMediaButton_Click(object sender, RoutedEventArgs e)
        {
            var openFileDialog = new OpenFileDialog
            {
                Title = "Chọn các tệp media",
                Filter = "Tất cả media|*.mp4;*.mkv;*.avi;*.mov;*.mp3;*.wav;*.aac;*.png;*.jpg;*.jpeg;*.bmp;*.gif;*.ico|Video|*.mp4;*.mkv;*.avi;*.mov|Âm thanh|*.mp3;*.wav;*.aac|Ảnh|*.png;*.jpg;*.jpeg;*.bmp;*.gif;*.ico",
                Multiselect = true
            };

            if (openFileDialog.ShowDialog() == true)
            {
                LoadingOverlay.Visibility = Visibility.Visible;

                var newVideoImageAssets = new List<MediaAsset>();
                var newAudioAssets = new List<MediaAsset>();

                foreach (var filePath in openFileDialog.FileNames)
                {
                    var extension = Path.GetExtension(filePath).ToLowerInvariant();
                    var asset = new MediaAsset { FilePath = filePath };

                    try
                    {
                        if (new[] { ".mp4", ".mkv", ".avi", ".mov" }.Contains(extension))
                        {
                            asset.Type = AssetType.Video;

                            if (!_filmstripServiceInstances.ContainsKey(filePath))
                            {
                                try
                                {
                                    _filmstripServiceInstances[filePath] = FilmstripService.Open(filePath);
                                }
                                catch (Exception ex)
                                {
                                    continue;
                                }
                            }

                            if (_filmstripServiceInstances.TryGetValue(filePath, out var filmstripService))
                            {
                                var mediaInfoForThumb = await FFProbe.AnalyseAsync(filePath);
                                var durationForThumb = mediaInfoForThumb.Duration;
                                var captureTime = durationForThumb.TotalSeconds > 10 ? TimeSpan.FromSeconds(durationForThumb.TotalSeconds * 0.1) : TimeSpan.FromSeconds(1);

                                BitmapImage thumbnailBitmap = await filmstripService.GetThumbnailAtAsync(captureTime, 120, CancellationToken.None);
                                if (thumbnailBitmap != null)
                                {
                                    asset.ThumbnailSource = thumbnailBitmap;
                                    asset.ThumbnailBase64 = Services.MediaProcessingService.ConvertBitmapImageToBase64(thumbnailBitmap);
                                }
                            }

                            var mediaInfo = await FFProbe.AnalyseAsync(filePath);
                            asset.Duration = mediaInfo.Duration;
                            var videoStream = mediaInfo.PrimaryVideoStream;
                            if (videoStream != null)
                            {
                                asset.Width = videoStream.Width;
                                asset.Height = videoStream.Height;
                            }

                            newVideoImageAssets.Add(asset);
                        }
                        else if (new[] { ".mp3", ".wav", ".aac" }.Contains(extension))
                        {
                            asset.Type = AssetType.Audio;
                            var mediaInfo = await FFProbe.AnalyseAsync(filePath);
                            asset.Duration = mediaInfo.Duration;
                            newAudioAssets.Add(asset);
                            QueueWaveformGeneration(asset);
                        }
                        else if (new[] { ".png", ".jpg", ".jpeg", ".bmp", ".gif", ".ico" }.Contains(extension))
                        {
                            asset.Type = AssetType.Image;
                            asset.ThumbnailSource = LoadBitmapImage(filePath);
                            if (asset.ThumbnailSource != null)
                            {
                                asset.Width = asset.ThumbnailSource.PixelWidth;
                                asset.Height = asset.ThumbnailSource.PixelHeight;
                                asset.ThumbnailBase64 = Services.MediaProcessingService.ConvertBitmapImageToBase64(asset.ThumbnailSource);
                            }
                            asset.Duration = TimeSpan.FromSeconds(5);
                            newVideoImageAssets.Add(asset);
                        }
                    }
                    catch (Exception ex)
                    {
                    }
                }

                foreach (var asset in newVideoImageAssets)
                {
                    VideoImageAssets.Add(asset);
                }
                foreach (var asset in newAudioAssets)
                {
                    AudioAssets.Add(asset);
                }

                LoadingOverlay.Visibility = Visibility.Collapsed;
            }
        }
        private async void ImportSubtitleButton_Click(object sender, RoutedEventArgs e)
        {
            OpenFileDialog openFileDialog = new OpenFileDialog
            {
                Filter = "Subtitle files (*.srt;*.ass)|*.srt;*.ass|All files (*.*)|*.*",
                Title = "Chọn file phụ đề",
                Multiselect = true
            };

            if (openFileDialog.ShowDialog() == true)
            {
                LoadingOverlay.Visibility = Visibility.Visible;
                try
                {
                    foreach (var filePath in openFileDialog.FileNames)
                    {
                        var asset = new MediaAsset
                        {
                            FilePath = filePath,
                            Type = AssetType.Subtitle,
                        };

                        try
                        {
                            var lines = await Task.Run(() => SrtFileUtils.LoadFromFile(filePath));
                            if (lines.Any())
                            {
                                var startTime = lines.Min(l => l.StartTime);
                                var endTime = lines.Max(l => l.EndTime);
                                asset.Duration = endTime - startTime;
                            }
                            else
                            {
                                asset.Duration = TimeSpan.FromSeconds(5);
                            }
                        }
                        catch (Exception ex)
                        {
                            asset.Duration = TimeSpan.FromSeconds(5);
                        }
                        SubtitleAssets.Add(asset);
                    }
                }
                finally
                {
                    LoadingOverlay.Visibility = Visibility.Collapsed;
                }
            }
        }
        private void AddTextClip_Click(object sender, RoutedEventArgs e)
        {
            var newClipStyle = new StyleState();
            newClipStyle.FontSize = _currentProject.TemplateFontSize;
            newClipStyle.X = 0.5;
            newClipStyle.Y = 0.5;
            newClipStyle.ScaleX = 1.2;
            newClipStyle.ScaleY = 1.2;
            newClipStyle.Rotation = 0;
            newClipStyle.Width = null;
            newClipStyle.FontColorHex = "#FFFFFFFF";
            newClipStyle.EdgeStyle = TextEdgeStyle.None;
            newClipStyle.IsBackgroundEnabled = false;

            var newTextClipLine = new SrtSubtitleLine
            {
                IsTextClip = true,
                Index = (_currentProject.Subtitles.Count + _currentProject.TextClips.Count + 1),
                StartTime = _playhead,
                Duration = TimeSpan.FromSeconds(3),
                Style = newClipStyle
            };

            if (CurrentProject.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated)
            {
                newTextClipLine.TranslatedText = "Văn bản mới";
                newTextClipLine.OriginalText = string.Empty;
            }
            else
            {
                newTextClipLine.OriginalText = "Văn bản mới";
                newTextClipLine.TranslatedText = string.Empty;
            }
            var newClipVM = new TimelineClipViewModel(newTextClipLine);
            int assignedTrack = _trackLayoutManager.AutoAssignTrack(
                TimelineClipType.Text,
                newClipVM.StartTime,
                newClipVM.Duration,
                TimelineClips
            );
            newClipVM.TrackIndex = assignedTrack;
            newTextClipLine.TrackIndex = assignedTrack; 
            _currentProject.TextClips.Add(newTextClipLine);
            SrtSubtitleLinesView.Add(newTextClipLine);
            TimelineClips.Add(newClipVM);
            RecalculateTotalDuration();
            UpdateTimelineScaleAndRender();
            SrtLinesDataGrid.SelectedItem = newTextClipLine;
            SrtLinesDataGrid.ScrollIntoView(newTextClipLine);
            DisplaySubtitleOnPlayer(newTextClipLine);
            _undoRedoService.AddState(CaptureEditorSnapshot());
            SaveProjectCurrent();
        }
        private void MediaAsset_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (sender is FrameworkElement element && element.DataContext is MediaAsset asset)
            {
                _dragStartPoint = e.GetPosition(null);
                ActiveMediaAsset = asset;
            }
        }
        private async Task HandleCreateSubtitlesForVideoAsync(MediaAsset asset)
        {
            if (asset == null)
            {
                CustomMessageBox.Show("Không thể xác định được clip video.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            string videoPath = asset.FilePath;
            if (string.IsNullOrEmpty(videoPath) || !File.Exists(videoPath))
            {
                CustomMessageBox.Show("Đường dẫn của clip video không hợp lệ hoặc file không tồn tại.", "Lỗi File", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            if (_isTimelinePlaying)
            {
                await PauseTimelinePlayback();
            }
            try
            {
                LoadingOverlay.Visibility = Visibility.Visible;
                SubtitleTab.IsChecked = true;
                ModeOcrRadio.IsChecked = true;
                if (IsBatchSubtitleMode) IsBatchSubtitleMode = false;
                TimeSpan? freezePosition = null;
                if (!string.IsNullOrEmpty(_currentVideoPath) &&
                    string.Equals(_currentVideoPath, videoPath, StringComparison.OrdinalIgnoreCase))
                {
                    if (_activeVideoClip != null)
                    {
                        freezePosition = ComputePositionInClip(_playhead, _activeVideoClip);
                    }
                    else
                    {
                        freezePosition = _newPlaybackController?.Position ?? TimeSpan.Zero;
                    }
                }
                else
                {
                    if (_activeVideoClip != null &&
                        _activeVideoClip.SourceData is MediaAsset activeAsset &&
                        string.Equals(activeAsset.FilePath, videoPath, StringComparison.OrdinalIgnoreCase))
                    {
                        freezePosition = ComputePositionInClip(_playhead, _activeVideoClip);
                    }
                    else
                    {
                        freezePosition = TimeSpan.Zero;
                    }
                }
                bool setupSuccess = await SetupMediaPlayerForDisplayAsync(videoPath, freezePosition);
                if (!setupSuccess)
                {
                    CustomMessageBox.Show("Không thể tải video để tạo phụ đề. Vui lòng kiểm tra lại file.", "Lỗi Tải Video", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Đã xảy ra lỗi khi chuẩn bị tạo phụ đề:\n\n{ex.Message}", "Lỗi Không Mong Muốn", MessageBoxButton.OK, MessageBoxImage.Error);
                await ResetVideoPlayerState();
            }
            finally
            {
                LoadingOverlay.Visibility = Visibility.Collapsed;
            }
        }
        private async void CreateSubtitlesMenuItem_Click(object sender, RoutedEventArgs e)
        {
            if (sender is MenuItem menuItem && menuItem.DataContext is MediaAsset asset)
            {
                if (asset.Type == AssetType.Video)
                {
                    await HandleCreateSubtitlesForVideoAsync(asset);
                }
                else
                {
                    CustomMessageBox.Show("Chức năng này chỉ áp dụng cho các clip video.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                }
            }
        }
        private double _currentVideoFps = 30.0;
        private async Task<bool> SetupMediaPlayerForDisplayAsync(string videoPath, TimeSpan? freezePosition = null)
        {
            if (string.IsNullOrEmpty(videoPath) || !File.Exists(videoPath))
                return false;
            await PauseTimelinePlayback();
            bool localSwitching = false;
            try
            {
                _isSwitchingVideoSource = true;
                localSwitching = true;
                if (!string.IsNullOrEmpty(_currentVideoPath) &&
                    string.Equals(_currentVideoPath, videoPath, StringComparison.OrdinalIgnoreCase))
                {
                    if (freezePosition.HasValue)
                    {
                        int token = NewTransportVersion();
                        await WaitForSeekSettleAsync(freezePosition.Value, token);
                    }
                    UpdatePlaybackUI(freezePosition ?? _newPlaybackController?.Position ?? TimeSpan.Zero);
                    return true;
                }
                IMediaAnalysis mediaInfo = await FFProbe.AnalyseAsync(videoPath);
                var videoStream = mediaInfo.PrimaryVideoStream;
                if (videoStream == null) throw new InvalidDataException("File không chứa luồng video hợp lệ.");
                try
                {
                    if (videoStream.FrameRate > 1.0)
                        _currentVideoFps = videoStream.FrameRate;
                    else
                        _currentVideoFps = 30.0;
                }
                catch
                {
                    _currentVideoFps = 30.0;
                }
                _currentVideoPath = videoPath;
                VideoEntry.Text = _currentVideoPath;

                _videoNativeWidth = videoStream.Width;
                _videoNativeHeight = videoStream.Height;
                ApplyReferenceSurfaceSize();
                UpdateCropThumbsLayout();
                TimeSpan target = freezePosition ?? TimeSpan.Zero;
                int openToken = NewTransportVersion();
                await WaitForSeekSettleAsync(target, openToken);
                _totalTimelineDuration = mediaInfo.Duration;
                totalDurationTextBlock.Text = _totalTimelineDuration.ToString(@"hh\:mm\:ss\.fff");
                UpdatePlaybackUI(target);
                return true;
            }
            catch
            {
                await ResetVideoPlayerState();
                return false;
            }
            finally
            {
                if (localSwitching)
                    _isSwitchingVideoSource = false;
            }
        }

        public class TimelineAudioClipViewModel : INotifyPropertyChanged
        {
            public TimelineAudioClip Source { get; set; }

            private double _x;
            public double X
            {
                get => _x;
                set { if (_x != value) { _x = value; OnPropertyChanged(nameof(X)); } }
            }

            private double _y;
            public double Y
            {
                get => _y;
                set { if (_y != value) { _y = value; OnPropertyChanged(nameof(Y)); } }
            }

            private double _width;
            public double Width
            {
                get => _width;
                set { if (_width != value) { _width = value; OnPropertyChanged(nameof(Width)); } }
            }

            public double Height { get; set; }
            public int TrackIndex { get; set; }
            public string FileName => Path.GetFileName(Source.FilePath);
            public List<float> WaveformData => Source.WaveformData;

            public event PropertyChangedEventHandler PropertyChanged;
            protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
            {
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
            }
        }
        private void MediaAsset_PreviewMouseMove(object sender, MouseEventArgs e)
        {
            if (e.LeftButton == MouseButtonState.Pressed && sender is FrameworkElement element)
            {
                System.Windows.Point position = e.GetPosition(null);
                if (Math.Abs(position.X - _dragStartPoint.X) > SystemParameters.MinimumHorizontalDragDistance ||
                    Math.Abs(position.Y - _dragStartPoint.Y) > SystemParameters.MinimumVerticalDragDistance)
                {
                    if (element.DataContext is MediaAsset asset)
                    {
                        DataObject data = new DataObject(typeof(MediaAsset), asset);
                        DragDrop.DoDragDrop(element, data, DragDropEffects.Copy);
                    }
                }
            }
        }
        private void TimelineClip_Container_Loaded(object sender, RoutedEventArgs e)
        {
            if (sender is ContentPresenter container && container.DataContext is TimelineClipViewModel vm)
            {
                if (vm.ClipType == TimelineClipType.Subtitle)
                {

                }
            }
        }
        private void BatchOptionCheckBox_Checked(object sender, RoutedEventArgs e)
        {
            if (_isUpdatingBatchCheckboxes) return;

            _isUpdatingBatchCheckboxes = true;
            try
            {
                var changedCheckBox = sender as CheckBox;
                if (changedCheckBox == null) return;
                if (changedCheckBox.Name == "BatchOnlyCreateOriginalSrtCheckBox" && changedCheckBox.IsChecked == true)
                {
                    BatchTranslateCheckBox.IsChecked = false;
                }
                else if (changedCheckBox.Name == "BatchTranslateCheckBox" && changedCheckBox.IsChecked == true)
                {
                    BatchOnlyCreateOriginalSrtCheckBox.IsChecked = false;
                }
            }
            finally
            {
                _isUpdatingBatchCheckboxes = false;
            }
        }
        private void UpdateProjectReferenceDimensions(MediaAsset newAsset)
        {
            bool isProjectUnsized = CurrentProject.ProjectReferenceVideoWidth <= 0 || CurrentProject.ProjectReferenceVideoHeight <= 0;
            bool noVideoExistsOnTimeline = !TimelineClips.Any(c => c.ClipType == TimelineClipType.Video && c.SourceData != newAsset);

            if (newAsset.Type == AssetType.Video && (isProjectUnsized || noVideoExistsOnTimeline))
            {
                if (newAsset.Width > 0 && newAsset.Height > 0)
                {
                    CurrentProject.ProjectReferenceVideoWidth = newAsset.Width;
                    CurrentProject.ProjectReferenceVideoHeight = newAsset.Height;
                }
            }
        }
        private async void Timeline_Drop(object sender, DragEventArgs e)
        {
            PositionMarkerThumb.IsHitTestVisible = true;
            if (_dropHighlightBorder != null) _dropHighlightBorder.Visibility = Visibility.Collapsed;
            if (_snapGuideline != null) _snapGuideline.Visibility = Visibility.Collapsed;

            if (!e.Data.GetDataPresent(DataFormats.FileDrop) && !e.Data.GetDataPresent(typeof(MediaAsset)))
            {
                return;
            }

            if (_isTimelinePlaying)
            {
                await PauseTimelinePlayback();
            }
            MediaAsset droppedVideoAsset = null;
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
                if (files == null || !files.Any()) return;

                LoadingOverlay.Visibility = Visibility.Visible;
                try
                {
                    foreach (var filePath in files)
                    {
                        var asset = await AddFileToMediaBinAsync(filePath);
                        if (asset == null) continue;
                        System.Windows.Point dropPositionInGrid = e.GetPosition(TracksContainerGrid);
                        if (asset.Type == AssetType.Video)
                        {
                            var lastVideoClip = TimelineClips
                                .Where(c => c.ClipType == TimelineClipType.Video && c.TrackIndex == 0)
                                .OrderBy(c => c.StartTime)
                                .LastOrDefault();

                            TimeSpan startTime = lastVideoClip != null ? lastVideoClip.EndTime : TimeSpan.Zero;

                            var newClipInstance = asset.Clone();
                            _currentProject.TimelineMediaClips.Add(newClipInstance);
                            var newVM = new TimelineClipViewModel(newClipInstance);
                            newVM.StartTime = startTime;
                            newVM.TrackIndex = 0;
                            QueueWaveformGeneration(newClipInstance);
                            TimelineClips.Add(newVM);
                            droppedVideoAsset = newClipInstance;
                        }
                        else if (asset.Type == AssetType.Subtitle)
                        {
                            double mouseAbsoluteX = dropPositionInGrid.X;
                            TimeSpan finalDroppedTime = TimeSpan.FromSeconds(Math.Max(0, mouseAbsoluteX / this._pixelsPerSecond));
                            int targetTrackIndex = CalculateTrackIndexFromY(dropPositionInGrid.Y);
                            targetTrackIndex = EnforceTrackTypeRules(asset.Type.ToTimelineClipType(), targetTrackIndex);
                            await LoadSrtFromAssetAsync(asset, finalDroppedTime, targetTrackIndex);
                        }
                        else
                        {
                            double mouseAbsoluteX = dropPositionInGrid.X;
                            TimeSpan finalDroppedTime = TimeSpan.FromSeconds(Math.Max(0, mouseAbsoluteX / this._pixelsPerSecond));
                            int targetTrackIndex = CalculateTrackIndexFromY(dropPositionInGrid.Y);
                            targetTrackIndex = EnforceTrackTypeRules(asset.Type.ToTimelineClipType(), targetTrackIndex);

                            TimelineClipViewModel newVM;
                            if (asset.Type == AssetType.Audio)
                            {
                                var newAudioClip = new TimelineAudioClip
                                {
                                    FilePath = asset.FilePath,
                                    OriginalDuration = asset.Duration,
                                    VolumeDb = asset.VolumeDb,
                                    Speed = asset.Speed,
                                    WavePeaks = asset.WavePeaks
                                };
                                _currentProject.VoicedSubtitles.Add(newAudioClip);
                                TimelineAudioClips.Add(newAudioClip);
                                newVM = new TimelineClipViewModel(newAudioClip);
                                QueueWaveformGeneration(newAudioClip);
                            }
                            else
                            {
                                var newClipInstance = asset.Clone();
                                _currentProject.TimelineMediaClips.Add(newClipInstance);
                                newVM = new TimelineClipViewModel(newClipInstance);
                                PopulateImageFilmstrip(newVM);
                            }
                            newVM.StartTime = finalDroppedTime;
                            newVM.TrackIndex = targetTrackIndex;
                            TimelineClips.Add(newVM);
                            ResolveCollisionsForClip(newVM);
                        }
                    }
                }
                finally
                {
                    LoadingOverlay.Visibility = Visibility.Collapsed;
                }
            }
            else if (e.Data.GetDataPresent(typeof(MediaAsset)))
            {
                var asset = e.Data.GetData(typeof(MediaAsset)) as MediaAsset;
                if (asset == null) return;
                System.Windows.Point dropPositionInGrid = e.GetPosition(TracksContainerGrid);
                if (asset.Type == AssetType.Video)
                {
                    var lastVideoClip = TimelineClips
                        .Where(c => c.ClipType == TimelineClipType.Video && c.TrackIndex == 0)
                        .OrderBy(c => c.StartTime)
                        .LastOrDefault();
                    TimeSpan startTime = lastVideoClip != null ? lastVideoClip.EndTime : TimeSpan.Zero;

                    var newClipInstance = asset.Clone();
                    _currentProject.TimelineMediaClips.Add(newClipInstance);
                    var newVM = new TimelineClipViewModel(newClipInstance);
                    newVM.StartTime = startTime;
                    newVM.TrackIndex = 0;
                    QueueWaveformGeneration(newClipInstance);
                    TimelineClips.Add(newVM);
                    droppedVideoAsset = newClipInstance;
                }
                else if (asset.Type == AssetType.Subtitle)
                {
                    double mouseAbsoluteX = dropPositionInGrid.X;
                    TimeSpan finalDroppedTime = TimeSpan.FromSeconds(Math.Max(0, mouseAbsoluteX / this._pixelsPerSecond));
                    int targetTrackIndex = CalculateTrackIndexFromY(dropPositionInGrid.Y);
                    targetTrackIndex = EnforceTrackTypeRules(asset.Type.ToTimelineClipType(), targetTrackIndex);
                    await LoadSrtFromAssetAsync(asset, finalDroppedTime, targetTrackIndex);
                }
                else
                {
                    double mouseAbsoluteX = dropPositionInGrid.X;
                    TimeSpan finalDroppedTime = TimeSpan.FromSeconds(Math.Max(0, mouseAbsoluteX / this._pixelsPerSecond));
                    int targetTrackIndex = CalculateTrackIndexFromY(dropPositionInGrid.Y);
                    targetTrackIndex = EnforceTrackTypeRules(asset.Type.ToTimelineClipType(), targetTrackIndex);

                    TimelineClipViewModel newVM;
                    if (asset.Type == AssetType.Audio)
                    {
                        var newAudioClip = new TimelineAudioClip
                        {
                            FilePath = asset.FilePath,
                            OriginalDuration = asset.Duration,
                            VolumeDb = asset.VolumeDb,
                            Speed = asset.Speed,
                            WavePeaks = asset.WavePeaks
                        };
                        _currentProject.VoicedSubtitles.Add(newAudioClip);
                        TimelineAudioClips.Add(newAudioClip);
                        newVM = new TimelineClipViewModel(newAudioClip);
                        QueueWaveformGeneration(newAudioClip);
                    }
                    else
                    {
                        var newClipInstance = asset.Clone();
                        _currentProject.TimelineMediaClips.Add(newClipInstance);
                        newVM = new TimelineClipViewModel(newClipInstance);
                        PopulateImageFilmstrip(newVM);
                    }
                    newVM.StartTime = finalDroppedTime;
                    newVM.TrackIndex = targetTrackIndex;
                    TimelineClips.Add(newVM);
                    ResolveCollisionsForClip(newVM);
                }
            }
            bool isFirstVideoClip = droppedVideoAsset != null && TimelineClips.Count(c => c.ClipType == TimelineClipType.Video) == 1;

            if (isFirstVideoClip)
            {
                UpdateProjectReferenceDimensions(droppedVideoAsset);
                videoGrid.Width = CurrentProject.ProjectReferenceVideoWidth;
                videoGrid.Height = CurrentProject.ProjectReferenceVideoHeight;
                if (droppedVideoAsset.Duration.TotalSeconds > 0 && TimelineScrollViewer.ViewportWidth > 0)
                {
                    double desiredVisibleDurationSeconds = droppedVideoAsset.Duration.TotalSeconds / 0.5;
                    double newPixelsPerSecond = TimelineScrollViewer.ViewportWidth / desiredVisibleDurationSeconds;
                    this._pixelsPerSecond = Math.Clamp(newPixelsPerSecond, GetDynamicMinPixelsPerSecond(), MAX_PIXELS_PER_SECOND);
                }
            }


            RecalculateTotalDuration();
            UpdateTimelineScaleAndRender();
            _undoRedoService.AddState(CaptureEditorSnapshot());
            SaveProjectCurrent();
            await SeekTimeline(_playhead);
            e.Handled = true;
        }
        private void PopulateImageFilmstrip(TimelineClipViewModel imageClipVM)
        {
            if (imageClipVM == null || imageClipVM.ClipType != TimelineClipType.Image || imageClipVM.Thumbnail == null)
            {
                return;
            }
            imageClipVM.FilmstripThumbnails.Clear();
            const double singleThumbnailWidth = 80.0;
            if (imageClipVM.Width <= 0 || singleThumbnailWidth <= 0)
            {
                return;
            }
            int numberOfThumbnails = (int)Math.Ceiling(imageClipVM.Width / singleThumbnailWidth);
            for (int i = 0; i < numberOfThumbnails; i++)
            {
                imageClipVM.FilmstripThumbnails.Add(imageClipVM.Thumbnail);
            }
        }
        private async Task LoadSrtFromAssetAsync(MediaAsset srtAsset, TimeSpan? dropTime, int ignoredTrackIndex)
        {
            if (srtAsset == null || string.IsNullOrEmpty(srtAsset.FilePath) || !File.Exists(srtAsset.FilePath)) return;

            LoadingOverlay.Visibility = Visibility.Visible;
            try
            {
                await Task.Delay(50);
                var lines = SrtFileUtils.LoadFromFile(srtAsset.FilePath);
                if (lines == null || lines.Count == 0) return;

                TimeSpan baseOffset = TimeSpan.Zero;
                if (dropTime.HasValue)
                {
                    TimeSpan firstStart = lines.Min(l => l.StartTime);
                    baseOffset = dropTime.Value - firstStart;
                }

                var projectTemplate = GetTemplateAsStyleState();
                var newClipsVMs = new List<TimelineClipViewModel>();

                foreach (var line in lines)
                {
                    var newStartTime = line.StartTime + baseOffset;
                    line.StartTime = (newStartTime < TimeSpan.Zero) ? TimeSpan.Zero : newStartTime;
                    line.Style = projectTemplate.Clone();
                    SrtSubtitleLinesView.Add(line);
                    _currentProject.Subtitles.Add(line);
                    var clipVM = new TimelineClipViewModel(line);
                    clipVM.TrackIndex = _trackLayoutManager.AutoAssignTrack(
                        TimelineClipType.Subtitle,
                        clipVM.StartTime,
                        clipVM.Duration,
                        TimelineClips.Concat(newClipsVMs));
                    line.TrackIndex = clipVM.TrackIndex;
                    TimelineClips.Add(clipVM);
                    newClipsVMs.Add(clipVM);
                }
                EnsureInitialTemplateWidthFitsVideo();
                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();
                _undoRedoService.AddState(CaptureEditorSnapshot());
                SaveProjectCurrent();
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Lỗi: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                LoadingOverlay.Visibility = Visibility.Collapsed;
            }
        }
        private TimeSpan _resizeInitialTrimStartOffset;
        private TimeSpan _resizeInitialTrimEndOffset;

        private void TimelineClip_Container_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            var container = sender as ContentPresenter;
            var vm = container?.DataContext as TimelineClipViewModel;
            if (vm == null)
            {
                return;
            }
            if (vm.ClipType == TimelineClipType.Audio)
            {
                if (vm.SourceData is TimelineAudioClip tac)
                { }
            }
            var source = e.OriginalSource as DependencyObject;
            Thumb thumb = FindVisualParent<Thumb>(source);
            bool isResizing = (thumb != null && (thumb.Name == "LeftHandle" || thumb.Name == "RightHandle"));
            if (thumb != null && thumb.Name == "VolumeThumb")
            {
                return;
            }

            if (_isTimelinePlaying)
            {
                PauseTimelinePlayback();
                _wasPlayingBeforeDrag = true;
            }
            else
            {
                _wasPlayingBeforeDrag = false;
            }

            bool isCtrlPressed = Keyboard.Modifiers == ModifierKeys.Control;
            bool isShiftPressed = Keyboard.Modifiers == ModifierKeys.Shift;

            if (isCtrlPressed)
            {
                vm.IsSelected = !vm.IsSelected;
            }
            else if (isShiftPressed && _selectedTimelineClip != null)
            {
                if (!vm.IsSelected)
                {
                    foreach (var clip in TimelineClips.Where(c => c.IsSelected))
                    {
                        clip.IsSelected = false;
                    }
                    vm.IsSelected = true;
                }
            }
            else
            {
                if (!vm.IsSelected)
                {
                    foreach (var clip in TimelineClips.Where(c => c.IsSelected))
                    {
                        clip.IsSelected = false;
                    }
                    vm.IsSelected = true;
                }
            }
            var selectedClips = TimelineClips.Where(c => c.IsSelected).ToList();
            var newPrimarySelectedClip = selectedClips.Contains(vm) ? vm : selectedClips.FirstOrDefault();

            if (_selectedTimelineClip != newPrimarySelectedClip)
            {
                if (_selectedTimelineClip?.SourceData is INotifyPropertyChanged oldSource)
                {
                    oldSource.PropertyChanged -= SelectedClip_PropertyChanged;
                }

                _selectedTimelineClip = newPrimarySelectedClip;

                if (_selectedTimelineClip?.SourceData is INotifyPropertyChanged newSource)
                {
                    newSource.PropertyChanged += SelectedClip_PropertyChanged;
                }
            }
            ClearAllAdorners();
            this.SelectedAudioClip = null;
            this.SelectedSubtitle = null;

            if (selectedClips.Count == 1 && _selectedTimelineClip != null)
            {
                if (_selectedTimelineClip.SourceData is TimelineAudioClip audioClip)
                {
                    this.SelectedAudioClip = audioClip;
                }
                else if (_selectedTimelineClip.SourceData is SrtSubtitleLine srtLine)
                {
                    this.SelectedSubtitle = srtLine;
                    if (SrtLinesDataGrid.SelectedItem != srtLine)
                    {
                        SrtLinesDataGrid.SelectedItem = srtLine;
                    }
                    SrtLinesDataGrid.ScrollIntoView(srtLine);

                    if (_activeVisuals.TryGetValue(srtLine, out var visual))
                    {
                        AddSubtitleAdorner(visual, srtLine.Style);
                    }
                }
                else if (_selectedTimelineClip.SourceData is MediaAsset mediaAsset)
                {
                    if (mediaAsset.Type == AssetType.Video) AddVideoAdorner(mediaAsset);
                    else if (mediaAsset.Type == AssetType.Image) AddImageAdorner(mediaAsset);
                }
            }
            UpdateEditorPanelVisibility();
            _dragStartPointInGrid = e.GetPosition(TracksContainerGrid);
            _dragClipInitialX = vm.X;
            _dragClipInitialY = vm.Y;

            if (thumb != null && vm.IsSelected && isResizing)
            {
                _isPreparingToDragClip = false;
                _suppressAudioDuringResize = true;
                _currentDragMode = DragMode.ResizeClip;
                _draggedResizeHandle = thumb;
                _resizeInitialStartTime = vm.StartTime;
                _resizeInitialEndTime = vm.EndTime;
                _playheadBeforeResize = _playhead; 
                _isModifyingVideoClip = (vm.ClipType == TimelineClipType.Video);
                if (_isModifyingVideoClip)
                {
                    _preModificationEndTime = vm.EndTime;
                }
                if (vm.SourceData is TimelineAudioClip audioClipSource)
                {
                    _resizeInitialTrimStartOffset = audioClipSource.TrimStartOffset;
                    _resizeInitialTrimEndOffset = audioClipSource.TrimEndOffset;
                }
                else if (vm.SourceData is MediaAsset mediaAssetSource)
                {
                    _resizeInitialTrimStartOffset = mediaAssetSource.TrimStartOffset;
                    _resizeInitialTrimEndOffset = mediaAssetSource.TrimEndOffset;
                }
                else
                {
                    _resizeInitialTrimStartOffset = TimeSpan.Zero;
                    _resizeInitialTrimEndOffset = TimeSpan.Zero;
                }
                ResizeGuideline.Visibility = Visibility.Visible;
            }
            else
            {
                _isPreparingToDragClip = true;
                _currentDragMode = DragMode.None;
            }

            container.CaptureMouse();
            e.Handled = true;
        }
        private void TimelineClip_Container_ContextMenuOpening(object sender, ContextMenuEventArgs e)
        {
            var container = sender as ContentPresenter;
            if (container == null || !(container.DataContext is TimelineClipViewModel activeClip))
            {
                e.Handled = true;
                return;
            }
            var selectedClips = TimelineClips.Where(c => c.IsSelected).ToList();
            foreach (var clip in selectedClips)
            {
            }
            var contextMenu = new ContextMenu { Style = (Style)FindResource("TimelineContextMenuStyle") };
            bool canCopy = selectedClips.Count == 1 && (activeClip.ClipType == TimelineClipType.Text || activeClip.ClipType == TimelineClipType.Subtitle);
            if (canCopy)
            {
                var copyAttrItem = new MenuItem { Header = "Sao chép thuộc tính", InputGestureText = "Ctrl+Shift+C", Style = (Style)FindResource("TimelineMenuItemStyle") };
                copyAttrItem.Click += CopyAttributes_Click;
                contextMenu.Items.Add(copyAttrItem);
            }
            bool canPaste = _copiedStyleState != null && selectedClips.Any(c => c.ClipType == TimelineClipType.Text || c.ClipType == TimelineClipType.Subtitle);
            if (canPaste)
            {
                var pasteAttrItem = new MenuItem { Header = "Dán thuộc tính", InputGestureText = "Ctrl+Shift+V", Style = (Style)FindResource("TimelineMenuItemStyle") };
                pasteAttrItem.Click += PasteAttributes_Click;
                contextMenu.Items.Add(pasteAttrItem);
            }
            bool canCreateSubtitlesSingle = selectedClips.Count == 1 && activeClip.ClipType == TimelineClipType.Video;
            bool canCreateSubtitlesBatch = selectedClips.Any(c => c.ClipType == TimelineClipType.Video);

            if (canCreateSubtitlesSingle || canCreateSubtitlesBatch)
            {
                if (contextMenu.Items.Count > 0) contextMenu.Items.Add(new Separator());
            }

            if (canCreateSubtitlesSingle)
            {
                var createSubItem = new MenuItem { Header = "Tạo phụ đề", Style = (Style)FindResource("TimelineMenuItemStyle") };
                createSubItem.Click += CreateSubtitles_Click;
                contextMenu.Items.Add(createSubItem);
            }

            if (canCreateSubtitlesBatch)
            {
                var createSubtitlesBatchItem = new MenuItem { Header = "Tạo phụ đề từ clip đã chọn", Style = (Style)FindResource("TimelineMenuItemStyle") };
                createSubtitlesBatchItem.Click += CreateSubtitlesFromClipsMenuItem_Click;
                contextMenu.Items.Add(createSubtitlesBatchItem);
            }
            bool canCreateVoice = selectedClips.Any(c => c.ClipType == TimelineClipType.Text || c.ClipType == TimelineClipType.Subtitle);
            if (canCreateVoice)
            {
                if (contextMenu.Items.Count > 0 && !(contextMenu.Items[contextMenu.Items.Count - 1] is Separator))
                {
                    contextMenu.Items.Add(new Separator());
                }
                var createVoiceItem = new MenuItem { Header = "Tạo Giọng nói", Style = (Style)FindResource("TimelineMenuItemStyle") };
                createVoiceItem.Click += CreateVoice_Click;
                contextMenu.Items.Add(createVoiceItem);
            }
            bool canGroup = selectedClips.All(c => c.ClipType == TimelineClipType.Video || c.ClipType == TimelineClipType.Image) && selectedClips.Count > 1;
            bool canUngroup = selectedClips.Count == 1 && activeClip.SourceData is CompoundClip;

            if (canGroup || canUngroup)
            {
                if (contextMenu.Items.Count > 0 && !(contextMenu.Items[contextMenu.Items.Count - 1] is Separator))
                {
                    contextMenu.Items.Add(new Separator());
                }
            }

            if (canGroup)
            {
                var groupItem = new MenuItem { Header = "Tạo clip ghép", InputGestureText = "Alt+G", Style = (Style)FindResource("TimelineMenuItemStyle") };
                groupItem.Click += CreateCompoundClip_Click;
                contextMenu.Items.Add(groupItem);
            }
            if (canUngroup)
            {
                var ungroupItem = new MenuItem { Header = "Hoàn tác clip ghép", InputGestureText = "Alt+G", Style = (Style)FindResource("TimelineMenuItemStyle") };
                ungroupItem.Click += UndoCompoundClip_Click;
                contextMenu.Items.Add(ungroupItem);
            }


            if (contextMenu.Items.Count > 0)
            {
                container.ContextMenu = contextMenu;
            }
            else
            {
                e.Handled = true;
            }
        }
        private int CalculateTrackIndexFromY(double yPos)
        {
            return _trackLayoutManager.CalculateTrackIndexFromY(yPos);
        }

        private int EnforceTrackTypeRules(TimelineClipType clipType, int targetTrackIndex)
        {
            return _trackLayoutManager.EnforceTrackTypeRules(clipType, targetTrackIndex);
        }
        private void ResolveCollisionsForClip(TimelineClipViewModel newClip)
        {
            ResolveCollisionsForClip(newClip, null);
        }
        private void ResolveCollisionsForClip(TimelineClipViewModel newClip, ISet<TimelineClipViewModel> ignoreSet)
        {
            var relevantClips = TimelineClips.Where(c => c != newClip && (ignoreSet == null || !ignoreSet.Contains(c))).ToList();
            int resolvedTrack = _trackLayoutManager.ResolveCollision(newClip, relevantClips);
            newClip.TrackIndex = resolvedTrack;
        }
        private T FindVisualChild<T>(DependencyObject parent, string name) where T : FrameworkElement
        {
            if (parent == null) return null;
            for (int i = 0; i < VisualTreeHelper.GetChildrenCount(parent); i++)
            {
                var child = VisualTreeHelper.GetChild(parent, i);
                if (child is T element && element.Name == name)
                {
                    return element;
                }
                var result = FindVisualChild<T>(child, name);
                if (result != null) return result;
            }
            return null;
        }
        private static DependencyObject GetParentObject(DependencyObject child)
        {
            if (child == null) return null;


            if (child is ContentElement ce)
            {
                var parent = ContentOperations.GetParent(ce);
                if (parent != null) return parent;

                if (ce is FrameworkContentElement fce)
                    return fce.Parent;

                return null;
            }
            if (child is Visual || child is Visual3D)
                return VisualTreeHelper.GetParent(child);
            return LogicalTreeHelper.GetParent(child);
        }
        private T FindVisualParent<T>(DependencyObject child) where T : DependencyObject
        {
            var current = child;
            while (current != null)
            {
                if (current is T match)
                    return match;

                current = GetParentObject(current);
            }
            return null;
        }
        private Border _dropHighlightBorder = null;
        private Rectangle _snapGuideline = null;
        private void Timeline_DragEnter(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(typeof(MediaAsset)))
            {
                e.Effects = DragDropEffects.Copy;
                PositionMarkerThumb.IsHitTestVisible = false;
                if (_dropHighlightBorder == null)
                {
                    _dropHighlightBorder = new Border { IsHitTestVisible = false, CornerRadius = new CornerRadius(3) };
                    DropOverlayCanvas.Children.Add(_dropHighlightBorder);
                }
                if (_snapGuideline == null)
                {
                    _snapGuideline = new Rectangle
                    {
                        Width = 0.8,
                        Fill = new SolidColorBrush(Colors.Cyan) { Opacity = 0.9 },
                        Effect = new DropShadowEffect { Color = Colors.Cyan, ShadowDepth = 0, BlurRadius = 8 },
                        IsHitTestVisible = false
                    };
                    DropOverlayCanvas.Children.Add(_snapGuideline);
                }
                _dropHighlightBorder.Visibility = Visibility.Visible;
            }
            else
            {
                e.Effects = DragDropEffects.None;
            }
            e.Handled = true;
        }

        private async void MainWindow_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            if (IsAuxUiActive)
            {
                if (e.Key == Key.Escape && _currentSnapshotMode != SnapshotMode.None)
                {
                    e.Handled = true;
                    CancelSnapshotMode();
                }
                return; 
            }
            if (e.Key == Key.F1 && _currentSnapshotMode == SnapshotMode.None)
            {
                e.Handled = true;
                StartSnapshotMode(SnapshotMode.OcrOnly);
                return;
            }
            if (e.Key == Key.F2 && _currentSnapshotMode == SnapshotMode.None)
            {
                e.Handled = true;
                StartSnapshotMode(SnapshotMode.OcrAndTranslate);
                return;
            }
            if (e.Key == Key.Escape && _currentSnapshotMode != SnapshotMode.None)
            {
                e.Handled = true;
                CancelSnapshotMode();
                return;
            }
            if (IsAuxUiActive)
            {
                return;
            }
            if (Keyboard.Modifiers == (ModifierKeys.Control | ModifierKeys.Shift))
            {
                switch (e.Key)
                {
                    case Key.C:
                        // [FIX] Allow TextBox to handle Ctrl+Shift+C (for text selection)
                        if (e.OriginalSource is System.Windows.Controls.TextBox ||
                            e.OriginalSource is Xceed.Wpf.Toolkit.WatermarkTextBox ||
                            e.OriginalSource is System.Windows.Controls.RichTextBox)
                        {
                            return;
                        }
                        CopyAttributes_Click(null, null);
                        e.Handled = true;
                        return;
                    case Key.V:
                        // [FIX] Allow TextBox to handle Ctrl+Shift+V (for text paste)
                        if (e.OriginalSource is System.Windows.Controls.TextBox ||
                            e.OriginalSource is Xceed.Wpf.Toolkit.WatermarkTextBox ||
                            e.OriginalSource is System.Windows.Controls.RichTextBox)
                        {
                            return;
                        }
                        PasteAttributes_Click(null, null);
                        e.Handled = true;
                        return;
                }
            }
            else if (Keyboard.Modifiers == ModifierKeys.Control)
            {
                switch (e.Key)
                {
                    case Key.N:
                        NewProjectMenuItem_Click(null, null);
                        e.Handled = true;
                        return;
                    case Key.L:
                        LoadProjectMenuItem_Click(null, null);
                        e.Handled = true;
                        return;
                    case Key.P:
                        SaveCurrentPreset_Click(null, null);
                        e.Handled = true;
                        return;
                    case Key.Delete:
                        DeleteCurrentProject_Click();
                        e.Handled = true;
                        return;
                    case Key.Z:
                        // [FIX] Cho phép TextBox xử lý native Ctrl+Z
                        if (e.OriginalSource is System.Windows.Controls.TextBox ||
                            e.OriginalSource is Xceed.Wpf.Toolkit.WatermarkTextBox ||
                            e.OriginalSource is System.Windows.Controls.RichTextBox)
                        {
                            // Không handle, để TextBox tự xử lý undo
                            return;
                        }
                        UndoState();
                        e.Handled = true;
                        return;
                    case Key.Y:
                        // [FIX] Cho phép TextBox xử lý native Ctrl+Y
                        if (e.OriginalSource is System.Windows.Controls.TextBox ||
                            e.OriginalSource is Xceed.Wpf.Toolkit.WatermarkTextBox ||
                            e.OriginalSource is System.Windows.Controls.RichTextBox)
                        {
                            // Không handle, để TextBox tự xử lý redo
                            return;
                        }
                        RedoState();
                        e.Handled = true;
                        return;
                    case Key.F:
                        OpenFindReplaceWindow();
                        e.Handled = true;
                        return;
                }
            }
            else if (e.Key == Key.Delete)
            {
                if (e.OriginalSource is System.Windows.Controls.TextBox || e.OriginalSource is Xceed.Wpf.Toolkit.WatermarkTextBox)
                {
                    return;
                }
                if (await DeleteSelectedTimelineClips())
                {
                    e.Handled = true;
                    return;
                }
                if (DeleteSelectedSrtLine())
                {
                    e.Handled = true;
                    return;
                }
            }
            else if (Keyboard.Modifiers == ModifierKeys.None)
            {
                switch (e.Key)
                {
                    case Key.Right:
                    case Key.Left:
                        {
                            if (e.OriginalSource is System.Windows.Controls.TextBox ||
                                e.OriginalSource is Xceed.Wpf.Toolkit.WatermarkTextBox)
                            {
                                return;
                            }

                            e.Handled = true;

                            if (_isTimelinePlaying)
                            {
                                await PauseTimelinePlayback();
                            }
                            var activeClip = FindActiveVideoClipAt(_playhead) ?? _activeVideoClip;
                            double fps = (_currentVideoFps > 0) ? _currentVideoFps : 30.0;
                            double speed = (activeClip != null && activeClip.Speed > 0) ? activeClip.Speed : 1.0;
                            var frameOnTimeline = TimeSpan.FromSeconds(1.0 / fps / speed);

                            var target = (e.Key == Key.Right)
                                ? _playhead + frameOnTimeline
                                : _playhead - frameOnTimeline;

                            var maxT = _actualContentDuration > TimeSpan.Zero ? _actualContentDuration : _totalTimelineDuration;

                            if (target < TimeSpan.Zero) target = TimeSpan.Zero;
                            if (maxT > TimeSpan.Zero && target > maxT) target = maxT;
                            _playhead = TimeSpan.FromMilliseconds(Math.Round(target.TotalMilliseconds));
                            ShowFramePreviewAt(_playhead);
                            if (_pixelsPerSecond > 0)
                            {
                                double absoluteX = _playhead.TotalSeconds * _pixelsPerSecond;
                                double left = TimelineScrollViewer.HorizontalOffset;
                                double right = left + TimelineScrollViewer.ViewportWidth;
                                const double padding = 40.0;

                                if (absoluteX > right - padding)
                                    TimelineScrollViewer.ScrollToHorizontalOffset(Math.Max(0, absoluteX - padding));
                                else if (absoluteX < left + padding)
                                    TimelineScrollViewer.ScrollToHorizontalOffset(Math.Max(0, absoluteX - padding));
                            }

                            return;
                        }

                }
            }
        }
        #region Snapshot OCR/Translate Functions

        private async void StartSnapshotMode(SnapshotMode mode)
        {
            try
            {
                if (mode == SnapshotMode.None)
                    return;
                if (_currentOcrMode == OcrMode.GoogleCloud)
                {
                    if (!await CheckGoogleAccountsAndShowGuideAsync())
                    {
                        return;
                    }
                }
                if (IsSnapshotModeActive)
                {
                    CancelSnapshotMode();
                }
                if (FFMEMediaPlayer == null || _activeVideoClip == null)
                {
                    CustomMessageBox.Show("Không có video đang mở để chụp khung hình.");
                    return;
                }
                ClearAllAdorners();
                _currentSnapshotMode = mode;
                _isSnapshotSelecting = false;
                _isWasPlayingBeforeSnapshot = _isTimelinePlaying;
                EnterAuxUi();

                await PauseTimelinePlayback();

                CreateSnapshotOverlay();
            }
            catch (Exception ex)
            {
                CancelSnapshotMode();
            }
        }


        private void CreateSnapshotOverlay()
        {
            try
            {
                var playerContainer = FindName("MediaPlayerContainer") as Grid;
                if (playerContainer == null)
                {
                    CancelSnapshotMode();
                    return;
                }

                _snapshotOverlayBorder = new Border
                {
                    Background = new SolidColorBrush(Color.FromArgb(80, 0, 0, 0)),
                    Cursor = Cursors.Cross,
                    HorizontalAlignment = HorizontalAlignment.Stretch,
                    VerticalAlignment = VerticalAlignment.Stretch
                };

                var overlayCanvas = new Canvas();
                _snapshotSelectionRect = new Rectangle
                {
                    Stroke = Brushes.Cyan,
                    StrokeThickness = 2,
                    StrokeDashArray = new DoubleCollection { 4, 2 },
                    Fill = new SolidColorBrush(Color.FromArgb(40, 0, 255, 255)),
                    Visibility = Visibility.Collapsed
                };
                overlayCanvas.Children.Add(_snapshotSelectionRect);
                _snapshotOverlayBorder.Child = overlayCanvas;

                var instructionText = new TextBlock
                {
                    Text = _currentSnapshotMode == SnapshotMode.OcrOnly
                        ? "Chế độ OCR: Kéo chuột để chọn vùng cần nhận dạng (nhấn ESC để hủy)"
                        : "Chế độ OCR + Dịch: Kéo chuột để chọn vùng cần dịch (nhấn ESC để hủy)",
                    Foreground = Brushes.White,
                    FontSize = 50,
                    FontWeight = FontWeights.Bold,
                    HorizontalAlignment = HorizontalAlignment.Center,
                    VerticalAlignment = VerticalAlignment.Top,
                    Margin = new Thickness(0, 20, 0, 0),
                    Effect = new DropShadowEffect { Color = Colors.Black, BlurRadius = 10, ShadowDepth = 2 }
                };
                overlayCanvas.Children.Add(instructionText);

                _snapshotOverlayBorder.PreviewMouseLeftButtonDown += SnapshotOverlay_MouseDown;
                _snapshotOverlayBorder.PreviewMouseMove += SnapshotOverlay_MouseMove;
                _snapshotOverlayBorder.PreviewMouseLeftButtonUp += SnapshotOverlay_MouseUp;

                playerContainer.Children.Add(_snapshotOverlayBorder);
                Panel.SetZIndex(_snapshotOverlayBorder, 9999);
            }
            catch (Exception ex)
            {
                LogMessage($"[SNAPSHOT][ERROR] Không thể tạo overlay: {ex.Message}", true);
                CancelSnapshotMode();
            }
        }

        private void CancelSnapshotMode()
        {
            try
            {
                if (!IsSnapshotModeActive)
                    return;
                if (_snapshotOverlayBorder != null)
                {
                    if (_snapshotOverlayBorder.Parent is Panel parent)
                    {
                        parent.Children.Remove(_snapshotOverlayBorder);
                    }
                    _snapshotOverlayBorder = null;
                }

                _snapshotSelectionRect = null;
                _isSnapshotSelecting = false;

                var shouldResume = _isWasPlayingBeforeSnapshot;
                _isWasPlayingBeforeSnapshot = false;
                _currentSnapshotMode = SnapshotMode.None;
                ExitAuxUi();

                if (shouldResume)
                {
                    StartTimelinePlayback();
                }
                RestoreActiveAdornersAfterSnapshot();
            }
            catch (Exception ex)
            {
            }
        }
        private void RestoreActiveAdornersAfterSnapshot()
        {
            try
            {
                if (_selectedSubtitle != null &&
                    _activeVisuals.TryGetValue(_selectedSubtitle, out var visual))
                {
                    AddSubtitleAdorner(visual, _selectedSubtitle.Style);
                    return;
                }
                if (_selectedTimelineClip?.SourceData is MediaAsset asset)
                {
                    if (asset.Type == AssetType.Video)
                    {
                        ActivateVideoAdornerIfNeeded();
                    }
                    else if (asset.Type == AssetType.Image)
                    {
                        ActivateImageAdornerIfNeeded();
                    }
                }
            }
            catch { }
        }

        private void SnapshotOverlay_MouseDown(object sender, MouseButtonEventArgs e)
        {
            if (_snapshotOverlayBorder == null) return;
            _isSnapshotSelecting = true;
            _snapshotStartPoint = e.GetPosition(_snapshotOverlayBorder);
            if (_snapshotSelectionRect != null)
            {
                Canvas.SetLeft(_snapshotSelectionRect, _snapshotStartPoint.X);
                Canvas.SetTop(_snapshotSelectionRect, _snapshotStartPoint.Y);
                _snapshotSelectionRect.Width = 0;
                _snapshotSelectionRect.Height = 0;
                _snapshotSelectionRect.Visibility = Visibility.Visible;
            }
            _snapshotOverlayBorder.CaptureMouse();
        }
        private void SnapshotOverlay_MouseMove(object sender, MouseEventArgs e)
        {
            if (!_isSnapshotSelecting || _snapshotSelectionRect == null) return;
            System.Windows.Point currentPoint = e.GetPosition(_snapshotOverlayBorder);
            double x = Math.Min(_snapshotStartPoint.X, currentPoint.X);
            double y = Math.Min(_snapshotStartPoint.Y, currentPoint.Y);
            double width = Math.Abs(currentPoint.X - _snapshotStartPoint.X);
            double height = Math.Abs(currentPoint.Y - _snapshotStartPoint.Y);
            Canvas.SetLeft(_snapshotSelectionRect, x);
            Canvas.SetTop(_snapshotSelectionRect, y);
            _snapshotSelectionRect.Width = width;
            _snapshotSelectionRect.Height = height;
        }

        private async void SnapshotOverlay_MouseUp(object sender, MouseButtonEventArgs e)
        {
            if (!_isSnapshotSelecting) return;
            _isSnapshotSelecting = false;
            _snapshotOverlayBorder?.ReleaseMouseCapture();

            if (_snapshotSelectionRect == null || _snapshotSelectionRect.Width < 10 || _snapshotSelectionRect.Height < 10)
            {
                LogMessage("[SNAPSHOT] Vùng chọn quá nhỏ. Vui lòng chọn lại.", true);
                CancelSnapshotMode();
                return;
            }
            double selectionX = Canvas.GetLeft(_snapshotSelectionRect);
            double selectionY = Canvas.GetTop(_snapshotSelectionRect);
            double selectionWidth = _snapshotSelectionRect.Width;
            double selectionHeight = _snapshotSelectionRect.Height;
            SnapshotMode currentMode = _currentSnapshotMode;
            if (currentMode == SnapshotMode.OcrOnly)
            {
                ShowSnapshotResult("Đang OCR...");
            }
            else
            {
                ShowSnapshotResult("Đang OCR...", "..."); 
            }
            CancelSnapshotMode();
            await ProcessSnapshotAsync(currentMode, selectionX, selectionY, selectionWidth, selectionHeight);
        }
        private async Task ProcessSnapshotAsync(SnapshotMode mode, double x, double y, double width, double height)
        {
            try
            {
                byte[] imageBytes = await CaptureVideoRegionAsync(x, y, width, height);
                if (imageBytes == null || imageBytes.Length == 0)
                {
                    throw new Exception("Không thể chụp ảnh từ video player.");
                }

                string ocrText = await PerformOcrOnImageAsync(imageBytes);
                if (!string.IsNullOrWhiteSpace(ocrText))
                {
                    ocrText = OcrLineFilterRegex.Replace(ocrText, "").Trim();
                }
                await Dispatcher.InvokeAsync(() =>
                {
                    if (string.IsNullOrWhiteSpace(ocrText) || ocrText == GeminiOcrService.NO_TEXT_INDICATOR)
                    {
                        OcrResultText.Text = "Không tìm thấy văn bản.";
                        TranslatedResultRow.Visibility = Visibility.Collapsed;
                    }
                    else
                    {
                        OcrResultText.Text = ocrText; 
                        Clipboard.SetText(ocrText);
                    }
                });
                if (mode == SnapshotMode.OcrOnly || string.IsNullOrWhiteSpace(ocrText) || ocrText == GeminiOcrService.NO_TEXT_INDICATOR)
                {
                    return;
                }
                if (mode == SnapshotMode.OcrAndTranslate)
                {
                    await Dispatcher.InvokeAsync(() =>
                    {
                        TranslatedResultText.Text = "Đang dịch...";
                        TranslatedResultRow.Visibility = Visibility.Visible;
                    });
                    string translatedText = await TranslateSnapshotTextAsync(ocrText); 
                    await Dispatcher.InvokeAsync(() =>
                    {
                        if (string.IsNullOrWhiteSpace(translatedText))
                        {
                            TranslatedResultText.Text = "[Lỗi dịch hoặc không có kết quả]";
                        }
                        else
                        {
                            TranslatedResultText.Text = translatedText;
                            Clipboard.SetText(translatedText);
                        }
                    });
                }
            }
            catch (Exception ex)
            {
                await Dispatcher.InvokeAsync(() =>
                {
                    OcrResultText.Text = $"Lỗi: {ex.Message}";
                    TranslatedResultRow.Visibility = Visibility.Collapsed;
                });
            }
        }
        private void SnapshotResultPanel_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            var originalSource = e.OriginalSource as DependencyObject;
            if (FindVisualParent<Button>(originalSource) != null)
            {
                return;
            }
            e.Handled = true;
        }
        private void ShowSnapshotResult(string ocrText, string translatedText = null)
        {
            _snapshotResultTimer?.Stop();

            OcrResultText.Text = ocrText;

            if (!string.IsNullOrWhiteSpace(translatedText))
            {
                TranslatedResultText.Text = translatedText;
                TranslatedResultRow.Visibility = Visibility.Visible;
            }
            else
            {
                TranslatedResultRow.Visibility = Visibility.Collapsed;
            }

            SnapshotResultPanel.Visibility = Visibility.Visible;
            _snapshotResultTimer.Start();
        }
        private void _snapshotResultTimer_Tick(object sender, EventArgs e)
        {
            _snapshotResultTimer.Stop();
            SnapshotResultPanel.Visibility = Visibility.Collapsed;
        }
        private void CloseSnapshotResultButton_Click(object sender, RoutedEventArgs e)
        {
            _snapshotResultTimer.Stop();
            SnapshotResultPanel.Visibility = Visibility.Collapsed;
        }
        private void OcrCopyButton_Click(object sender, RoutedEventArgs e)
        {
            Clipboard.SetText(OcrResultText.Text);
        }
        private void TranslatedCopyButton_Click(object sender, RoutedEventArgs e)
        {
            Clipboard.SetText(TranslatedResultText.Text);
        }

        private async Task<byte[]> CaptureVideoRegionAsync(double x, double y, double width, double height)
        {
            return await Task.Run(() =>
            {
                try
                {
                    byte[] result = null;
                    Dispatcher.Invoke(() =>
                    {
                        if (FFMEMediaPlayer == null || _activeVideoClip == null)
                        {
                            throw new Exception("Video player không sẵn sàng.");
                        }

                        double playerWidth = FFMEMediaPlayer.ActualWidth;
                        double playerHeight = FFMEMediaPlayer.ActualHeight;

                        if (playerWidth <= 0 || playerHeight <= 0)
                        {
                            throw new Exception("Không thể xác định kích thước video player.");
                        }

                        RenderTargetBitmap renderBitmap = new RenderTargetBitmap((int)playerWidth, (int)playerHeight, 96, 96, PixelFormats.Pbgra32);
                        renderBitmap.Render(FFMEMediaPlayer);

                        int cropX = Math.Max(0, (int)x);
                        int cropY = Math.Max(0, (int)y);
                        int cropWidth = (int)Math.Min(width, playerWidth - cropX);
                        int cropHeight = (int)Math.Min(height, playerHeight - cropY);

                        if (cropWidth <= 0 || cropHeight <= 0)
                        {
                            throw new Exception("Vùng chọn không hợp lệ.");
                        }

                        CroppedBitmap croppedBitmap = new CroppedBitmap(renderBitmap, new Int32Rect(cropX, cropY, cropWidth, cropHeight));

                        PngBitmapEncoder encoder = new PngBitmapEncoder();
                        encoder.Frames.Add(BitmapFrame.Create(croppedBitmap));

                        using (var memoryStream = new MemoryStream())
                        {
                            encoder.Save(memoryStream);
                            result = memoryStream.ToArray();
                        }
                    });
                    return result;
                }
                catch (Exception ex)
                {
                    return null;
                }
            });
        }

        private async Task<string> PerformOcrOnImageAsync(byte[] imageBytes)
        {
            try
            {
                if (_currentOcrMode == OcrMode.GeminiApi)
                {
                    if (_geminiServiceOcr == null || _geminiApiKeysOcr == null || !_geminiApiKeysOcr.Any())
                    {
                        throw new Exception("Gemini OCR chưa được cấu hình. Vui lòng kiểm tra Settings.");
                    }
                    string tempImagePath = Path.Combine(Path.GetTempPath(), $"snapshot_{Guid.NewGuid()}.png");
                    await File.WriteAllBytesAsync(tempImagePath, imageBytes);
                    try
                    {
                        var results = await _geminiServiceOcr.ProcessImagesAsync(new List<string> { tempImagePath }, CancellationToken.None);
                        if (results != null && results.Count > 0)
                        {
                            var firstResult = results[0];
                            if (!string.IsNullOrEmpty(firstResult.error))
                            {
                                throw new Exception($"Gemini OCR error: {firstResult.error}");
                            }
                            return firstResult.ocrText ?? "";
                        }
                        return "";
                    }
                    finally
                    {
                        if (File.Exists(tempImagePath)) { try { File.Delete(tempImagePath); } catch { } }
                    }
                }
                else if (_currentOcrMode == OcrMode.GoogleCloud)
                {
                    LoadGoogleAccounts();
                    if (_googleAccounts == null || !_googleAccounts.Any())
                    {
                        throw new Exception(
                            "Google Cloud OCR (AIO OCR) chưa được cấu hình.\n" +
                            "Vui lòng tạo thư mục 'Oauth2.0' và các thư mục con cho từng tài khoản " +
                            "chứa 'credentials.json' và file chứa ID thư mục Google Drive như hướng dẫn.");
                    }

                    string tempImagePath = Path.Combine(Path.GetTempPath(), $"snapshot_{Guid.NewGuid()}.png");
                    await File.WriteAllBytesAsync(tempImagePath, imageBytes);

                    try
                    {
                        var firstAccount = _googleAccounts[0];
                        var processor = firstAccount.OcrProcessor;
                        string tempRawTextsDir = Path.Combine(Path.GetTempPath(), $"snapshot_raw_{Guid.NewGuid()}");
                        Directory.CreateDirectory(tempRawTextsDir);

                        try
                        {
                            var results = await processor.ProcessBatchAsync(
                                new List<string> { tempImagePath },
                                tempRawTextsDir,
                                firstAccount.DriveFolderId,
                                CancellationToken.None);

                            if (results != null && results.Count > 0)
                            {
                                var firstResult = results[0];
                                if (!string.IsNullOrEmpty(firstResult.error))
                                {
                                    throw new Exception($"Google Cloud OCR error: {firstResult.error}");
                                }

                                return firstResult.ocrText ?? string.Empty;
                            }

                            return string.Empty;
                        }
                        finally
                        {
                            try
                            {
                                if (Directory.Exists(tempRawTextsDir))
                                    Directory.Delete(tempRawTextsDir, true);
                            }
                            catch { /* bỏ qua lỗi dọn dẹp */ }
                        }
                    }
                    finally
                    {
                        try
                        {
                            if (File.Exists(tempImagePath))
                                File.Delete(tempImagePath);
                        }
                        catch { /* bỏ qua lỗi dọn dẹp */ }
                    }
                }

                else
                {
                    throw new Exception("OCR mode không được hỗ trợ.");
                }
            }
            catch (Exception ex)
            {
                LogMessage($"[SNAPSHOT][ERROR] Lỗi OCR: {ex.Message}", true);
                throw;
            }
        }

        private async Task<string> TranslateSnapshotTextAsync(string sourceText)
        {
            try
            {
                string targetLanguage = _selectedSrtTargetLanguage ?? "Tiếng Việt";
                string genre = _selectedSrtGenreValue ?? "Đô Thị Hiện Đại";
                SrtApiProvider provider = _currentSrtApiProvider;

                LogMessage($"[SNAPSHOT][TRANSLATE] Provider: {provider}, Genre: {genre}, Language: {targetLanguage}");

                string translatedText;

                if (provider == SrtApiProvider.AIOLauncher || provider == SrtApiProvider.AIOLauncherVIP)
                {
                    translatedText = await TranslateWithAIOLauncherForSnapshotAsync(sourceText, targetLanguage, genre, provider == SrtApiProvider.AIOLauncherVIP);
                }
                else
                {
                    if (_srtTranslationService == null)
                    {
                        RebuildSrtTranslationService();
                    }

                    translatedText = await TranslateWithStandardProviderAsync(sourceText, provider, targetLanguage, genre);
                }

                if (string.IsNullOrWhiteSpace(translatedText))
                {
                    throw new Exception("Không nhận được kết quả dịch từ API.");
                }

                return ParseTranslationResult(translatedText);
            }
            catch (Exception ex)
            {
                LogMessage($"[SNAPSHOT][ERROR] Lỗi dịch: {ex.Message}", true);
                throw;
            }
        }
        private async Task<string> TranslateWithStandardProviderAsync(string sourceText, SrtApiProvider provider, string targetLanguage, string genre)
        {
            string payload = $"1: {sourceText.Replace("\r\n", " ").Replace("\n", " ")}";

            Func<string, CancellationToken, string, string, Task<string>> translateFunc = provider switch
            {
                SrtApiProvider.Gemini => _srtTranslationService.TranslateWithGeminiAsync,
                SrtApiProvider.ChatGPT => _srtTranslationService.TranslateWithChatGPTAsync,
                SrtApiProvider.ChutesAI => _srtTranslationService.TranslateWithChutesAIAsync,
                _ => throw new NotSupportedException($"Provider {provider} không được hỗ trợ.")
            };

            string result = await translateFunc(payload, CancellationToken.None, genre, targetLanguage);

            if (string.IsNullOrWhiteSpace(result) || result.StartsWith("Lỗi", StringComparison.OrdinalIgnoreCase))
            {
                throw new Exception($"API {provider} trả về lỗi: {result}");
            }

            return result;
        }
        private async Task<string> TranslateWithAIOLauncherForSnapshotAsync(string sourceText, string targetLanguage, string genre, bool useVipApi = false)
        {
            var lines = new List<SrtLine>
    {
        new SrtLine(1, sourceText.Replace("\r\n", " ").Replace("\n", " "))
    };

            string systemInstruction;
            if (IsCustomPromptEnabled && !string.IsNullOrWhiteSpace(CurrentCustomPromptText))
            {
                systemInstruction = (CurrentCustomPromptText.Trim() + CUSTOM_PROMPT_SUFFIX).Trim();
            }
            else
            {
                if (_srtTranslationService == null) RebuildSrtTranslationService();
                systemInstruction = _srtTranslationService.GetSystemInstructionForGeminiSrtTranslation(genre, targetLanguage);
            }

            LogMessage($"[SNAPSHOT][{(useVipApi ? "VIP" : "AIOL")}] Gửi yêu cầu start-translation (1 dòng snapshot)...");

            string sessionId;
            if (useVipApi)
            {
                var start = await ApiService.StartVipTranslationAsync(targetLanguage, lines, systemInstruction);

                if (!string.Equals(start.Status, "Accepted", StringComparison.OrdinalIgnoreCase) ||
                    string.IsNullOrWhiteSpace(start.SessionId))
                {
                    throw new Exception(start.Message ?? "Yêu cầu dịch VIP không được chấp nhận bởi server.");
                }
                sessionId = start.SessionId;
            }
            else
            {
                var start = await ApiService.StartTranslationJobAsync(
                    genre,
                    targetLanguage,
                    lines,
                    systemInstruction,
                    acceptPartial: false);

                if (!string.Equals(start.Status, "Accepted", StringComparison.OrdinalIgnoreCase) ||
                    string.IsNullOrWhiteSpace(start.SessionId))
                {
                    throw new Exception(start.Message ?? "Yêu cầu dịch không được chấp nhận bởi server.");
                }
                sessionId = start.SessionId;
            }

            int attempts = 0;
            while (attempts < 90)
            {
                await Task.Delay(useVipApi ? 2000 : 1000);

                // --- FIX LỖI CS0173 BẮT ĐẦU TỪ ĐÂY ---
                // Khai báo biến chung
                List<TranslatedSrtLine> newLines = null;
                bool isCompleted = false;
                string errorMessage = null;

                // Tách logic gọi API
                if (useVipApi)
                {
                    var result = await ApiService.GetVipResultsAsync(sessionId);
                    newLines = result.NewLines;
                    isCompleted = result.IsCompleted;
                    errorMessage = result.ErrorMessage;
                    Debug.WriteLine($"[SnapshotTranslate] VIP Poll: Completed={isCompleted}");
                }
                else
                {
                    var result = await ApiService.GetTranslationResultsAsync(sessionId);
                    newLines = result.NewLines;
                    isCompleted = result.IsCompleted;
                    errorMessage = result.ErrorMessage;
                    Debug.WriteLine($"[SnapshotTranslate] AIO Poll: Completed={isCompleted}");
                }

                // Kiểm tra lỗi và kết quả dựa trên biến chung
                if (!string.IsNullOrEmpty(errorMessage))
                {
                    throw new Exception($"Lỗi {(useVipApi ? "VIP API" : "AIOLauncher")}: {errorMessage}");
                }

                if (isCompleted)
                {
                    if (newLines != null && newLines.Any())
                    {
                        var line = newLines[0];
                        if (!string.IsNullOrWhiteSpace(line.TranslatedText))
                        {
                            return line.TranslatedText.Trim();
                        }
                    }
                    throw new Exception($"{(useVipApi ? "VIP API" : "AIOLauncher")} hoàn thành nhưng không có kết quả dịch.");
                }
                // --- KẾT THÚC ĐOẠN FIX ---

                attempts++;
            }

            throw new Exception($"Không nhận được kết quả từ {(useVipApi ? "VIP API" : "AIOLauncher")} trong thời gian chờ.");
        }
        private string ParseTranslationResult(string rawResult)
        {
            if (string.IsNullOrWhiteSpace(rawResult)) return "";
            var trimmedResult = rawResult.Trim();
            var match = Regex.Match(trimmedResult, @"^\s*\d+\s*:\s*(.*)$", RegexOptions.Singleline);
            if (match.Success)
            {
                return match.Groups[1].Value.Trim();
            }
            return trimmedResult;
        }

        #endregion
        private void OpenFindReplaceWindow()
        {
            try
            {
                if (SrtSubtitleLinesView == null || SrtSubtitleLinesView.Count == 0)
                {
                    CustomMessageBox.Show(
                        "Không có phụ đề nào để tìm kiếm!\nVui lòng import file SRT trước.",
                        "Thông báo",
                        MessageBoxButton.OK,
                        MessageBoxImage.Information);
                    return;
                }
                var subtitlesList = SrtSubtitleLinesView.ToList();
                Action<List<SrtSubtitleLine>> onApplyChanges = (updatedSubtitles) =>
                {
                    ApplyFindReplaceChanges(updatedSubtitles);
                };
                var findReplaceWindow = new FindReplaceWindow(subtitlesList, onApplyChanges)
                {
                    Owner = this
                };
                bool? result = findReplaceWindow.ShowDialog();
                if (result == true) { }
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show(
                    $"Lỗi khi mở Find and Replace:\n{ex.Message}",
                    "Lỗi",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
        }

        private void ApplyFindReplaceChanges(List<SrtSubtitleLine> updatedSubtitles)
        {
            try
            {
                // Update timeline clips with the edited text
                foreach (var clip in TimelineClips.Where(c => c.SourceData is SrtSubtitleLine).ToList())
                {
                    var subtitle = clip.SourceData as SrtSubtitleLine;
                    if (subtitle != null)
                    {
                        // Update DisplayName based on current display mode
                        if (_currentProject?.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated
                            && !string.IsNullOrWhiteSpace(subtitle.TranslatedText))
                        {
                            clip.DisplayName = subtitle.TranslatedText;
                        }
                        else
                        {
                            clip.DisplayName = subtitle.OriginalText;
                        }
                        clip.RefreshPropertiesFromSource();
                    }
                }

                // Refresh all UI components
                if (SubtitleRenderCanvas != null)
                {
                    SubtitleRenderCanvas.InvalidateVisual();
                }
                SrtLinesDataGrid.Items.Refresh();
                UpdateTimelineScaleAndRender();

                // Save the changes
                _undoRedoService.AddState(CaptureEditorSnapshot());
                SaveProjectCurrent();
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show(
                    $"Lỗi khi áp dụng thay đổi:\n{ex.Message}",
                    "Lỗi",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
        }

        private void DataGridRow_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (sender is DataGridRow row)
            {
                if (Keyboard.Modifiers.HasFlag(ModifierKeys.Control))
                {
                    row.IsSelected = !row.IsSelected;
                    e.Handled = true;
                }
            }
        }
        private void SrtLinesDataGrid_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Delete)
            {
                if (DeleteSelectedSrtLine())
                {
                    e.Handled = true;
                }
            }
        }
        private void SrtLinesDataGrid_CellEditEnding(object sender, DataGridCellEditEndingEventArgs e)
        {
            if (e.EditAction == DataGridEditAction.Commit)
            {
                // Schedule update after the cell edit is committed
                Dispatcher.BeginInvoke(new Action(() =>
                {
                    var editedLine = e.Row.Item as SrtSubtitleLine;
                    if (editedLine != null)
                    {
                        // Update timeline clip DisplayName based on current display mode
                        var clip = TimelineClips.FirstOrDefault(c =>
                            c.SourceData is SrtSubtitleLine srtLine &&
                            srtLine.Index == editedLine.Index);

                        if (clip != null)
                        {
                            // Update DisplayName according to the current subtitle display mode
                            if (_currentProject?.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated
                                && !string.IsNullOrWhiteSpace(editedLine.TranslatedText))
                            {
                                clip.DisplayName = editedLine.TranslatedText;
                            }
                            else
                            {
                                clip.DisplayName = editedLine.OriginalText;
                            }
                            clip.RefreshPropertiesFromSource();
                        }

                        // Refresh subtitle rendering on timeline
                        if (SubtitleRenderCanvas != null)
                        {
                            SubtitleRenderCanvas.InvalidateVisual();
                        }

                        // Refresh DataGrid to ensure changes are visible
                        SrtLinesDataGrid.Items.Refresh();

                        // Update timeline rendering
                        UpdateTimelineScaleAndRender();

                        // Mark project as modified and save
                        SaveConfiguration();
                    }
                }), System.Windows.Threading.DispatcherPriority.Background);
            }
        }
        private bool DeleteSelectedSrtLine()
        {
            if (SrtLinesDataGrid.SelectedItems.Count == 0)
            {
                return false;
            }
            var linesToDelete = SrtLinesDataGrid.SelectedItems.Cast<SrtSubtitleLine>().ToList();
            _selectedTimelineClip = null;
            SelectedSubtitle = null;
            UpdateEditorPanelVisibility();
            RemoveVideoAdorner();
            RemoveSubtitleAdorner();

            foreach (var line in linesToDelete)
            {
                SrtSubtitleLinesView.Remove(line);

                if (line.IsTextClip)
                {
                    _currentProject.TextClips.Remove(line);
                }
                else
                {
                    _currentProject.Subtitles.Remove(line);
                }

                var clipToDeleteOnTimeline = TimelineClips.FirstOrDefault(c => c.SourceData == line);
                if (clipToDeleteOnTimeline != null)
                {
                    TimelineClips.Remove(clipToDeleteOnTimeline);
                }

                if (_activeVisuals.TryGetValue(line, out var visual))
                {
                    SubtitleRenderCanvas.Children.Remove(visual);
                    _activeVisuals.Remove(line);
                }
            }
            var subtitlesToReindex = SrtSubtitleLinesView.Where(l => !l.IsTextClip).OrderBy(l => l.StartTime).ToList();
            for (int i = 0; i < subtitlesToReindex.Count; i++)
            {
                subtitlesToReindex[i].Index = i + 1;
            }

            RecalculateTrackAssignments();
            RecalculateTotalDuration();
            UpdateTimelineScaleAndRender();
            _undoRedoService.AddState(CaptureEditorSnapshot());
            SaveProjectCurrent();
            SrtLinesDataGrid.UnselectAll();
            return true;
        }
        private async Task<bool> DeleteSelectedTimelineClips()
        {
            var clipsToDelete = TimelineClips.Where(c => c.IsSelected).ToList();
            if (!clipsToDelete.Any())
            {
                return false;
            }
            bool wasPlaying = _isTimelinePlaying;
            if (wasPlaying)
            {
                await PauseTimelinePlayback();
            }
            _selectedTimelineClip = null;
            SelectedSubtitle = null;
            SelectedAudioClip = null;
            ActiveMediaAsset = null;
            UpdateEditorPanelVisibility();
            RemoveVideoAdorner();
            RemoveSubtitleAdorner();
            foreach (var vm in clipsToDelete)
            {
                if (vm == null || vm.SourceData == null)
                {
                    continue;
                }
                if (vm.SourceData is SrtSubtitleLine line)
                {
                    SrtSubtitleLinesView.Remove(line);
                    if (line.IsTextClip)
                    {
                        _currentProject.TextClips.Remove(line);
                    }
                    else
                    {
                        _currentProject.Subtitles.Remove(line);
                    }
                    if (_activeVisuals != null && _activeVisuals.TryGetValue(line, out var visual))
                    {
                        SubtitleRenderCanvas.Children.Remove(visual);
                        _activeVisuals.Remove(line);
                    }
                }
                else if (vm.SourceData is TimelineAudioClip audioClip)
                {
                    if (TimelineAudioClips != null)
                    {
                        TimelineAudioClips.Remove(audioClip);
                    }
                    if (_currentProject?.VoicedSubtitles != null)
                    {
                        _currentProject.VoicedSubtitles.Remove(audioClip);
                    }
                    SrtSubtitleLine matchedSubtitleLine = null;
                    if (audioClip.SourceSubtitleIndexSnapshot.HasValue)
                    {
                        int idxSnapshot = audioClip.SourceSubtitleIndexSnapshot.Value;

                        matchedSubtitleLine = SrtSubtitleLinesView
                            .FirstOrDefault(l =>
                                l != null &&
                                !l.IsTextClip &&
                                l.Index == idxSnapshot);
                    }
                    if (matchedSubtitleLine == null)
                    {
                        string clipFullPath = SafeGetFullPath(audioClip.FilePath);

                        matchedSubtitleLine = SrtSubtitleLinesView.FirstOrDefault(l =>
                            l != null &&
                            !l.IsTextClip &&
                            !string.IsNullOrWhiteSpace(l.VoicedAudioPath) &&
                            string.Equals(
                                SafeGetFullPath(l.VoicedAudioPath),
                                clipFullPath,
                                StringComparison.OrdinalIgnoreCase));
                    }
                    if (matchedSubtitleLine != null)
                    {
                        bool sameFile =
                            string.Equals(
                                SafeGetFullPath(matchedSubtitleLine.VoicedAudioPath),
                                SafeGetFullPath(audioClip.FilePath),
                                StringComparison.OrdinalIgnoreCase);

                        if (sameFile)
                        {
                            matchedSubtitleLine.IsVoiced = false;
                            matchedSubtitleLine.VoicedAudioPath = null;
                        }
                    }
                }
                else if (vm.SourceData is MediaAsset mediaInstance)
                {
                    _currentProject?.TimelineMediaClips?.Remove(mediaInstance);
                    if (_activeVideoClip == vm)
                    {
                        await SwitchActiveVideoClip(null, resume: false);
                    }
                }
            }
            foreach (var vm in clipsToDelete)
            {
                TimelineClips.Remove(vm);
            }
            var subtitlesToReindex = SrtSubtitleLinesView
                .Where(l => !l.IsTextClip)
                .OrderBy(l => l.StartTime)
                .ToList();

            for (int i = 0; i < subtitlesToReindex.Count; i++)
            {
                subtitlesToReindex[i].Index = i + 1;
            }
            RecalculateTrackAssignments();
            RecalculateTotalDuration();
            UpdateTimelineScaleAndRender();
            _undoRedoService.AddState(CaptureEditorSnapshot());
            SaveProjectCurrent();
            if (wasPlaying)
            {
                await StartTimelinePlayback();
            }

            return true;
        }
        private static string SafeGetFullPath(string path)
        {
            if (string.IsNullOrWhiteSpace(path))
            {
                return string.Empty;
            }

            try
            {
                return System.IO.Path.GetFullPath(path);
            }
            catch
            {
                return path ?? string.Empty;
            }
        }

        private void TimelineScrollViewer_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            if (e.WidthChanged)
            {
                UpdateTimelineScaleAndRender();
            }
        }
        private void SaveProjectCurrent()
        {
            try
            {
                UpdateProjectStateBeforeSave();
                var snapshot = CaptureEditorSnapshot(includeViewState: true);
                subphimv1.Services.ProjectManager.SaveSnapshot(snapshot);
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Không thể lưu project.\nLỗi: {ex.Message}", "Lỗi Lưu", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private async Task SaveProjectCurrentAsync()
        {
            try
            {
                UpdateProjectStateBeforeSave();
                var snapshot = CaptureEditorSnapshot(includeViewState: true);
                await subphimv1.Services.ProjectManager.SaveSnapshotAsync(snapshot);
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Không thể lưu project.\nLỗi: {ex.Message}", "Lỗi Lưu", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private EditorSnapshot CaptureEditorSnapshot(bool includeViewState = true)
        {
            UpdateProjectStateBeforeSave();
            var snap = new subphimv1.Models.EditorSnapshot();
            snap.Project = _currentProject ?? new ProjectState();

            // CRITICAL FIX: Must capture ALL Media Bin assets to prevent losing them on undo/redo
            snap.MediaBin_VideoImageAssets = VideoImageAssets?.ToList() ?? new List<MediaAsset>();
            snap.MediaBin_SubtitleAssets = SubtitleAssets?.ToList() ?? new List<MediaAsset>();
            snap.MediaBin_AudioAssets = AudioAssets?.ToList() ?? new List<MediaAsset>();

            // [FIX TTS UNDO] Merge audio clips từ CẢ HAI sources để không mất TTS
            // Vì TTS được thêm vào VoicedSubtitles nhưng không phải lúc nào cũng sync với TimelineAudioClips
            var allAudioClips = new List<TimelineAudioClip>();

            // Thêm từ TimelineAudioClips (MainWindow)
            if (TimelineAudioClips != null)
            {
                allAudioClips.AddRange(TimelineAudioClips);
            }

            // Thêm từ VoicedSubtitles (ProjectState) - những cái chưa có trong list
            if (_currentProject?.VoicedSubtitles != null)
            {
                foreach (var clip in _currentProject.VoicedSubtitles)
                {
                    // Kiểm tra xem clip đã tồn tại chưa (theo FilePath + StartTime)
                    bool exists = allAudioClips.Any(c =>
                        c.FilePath == clip.FilePath &&
                        Math.Abs(c.StartTime.TotalMilliseconds - clip.StartTime.TotalMilliseconds) < 1);

                    if (!exists)
                    {
                        allAudioClips.Add(clip);
                    }
                }
            }

            snap.TimelineAudioClips = allAudioClips;
            snap.PlayheadSeconds = Math.Max(0.0, _playhead.TotalSeconds);
            snap.ReferenceWidth = (CurrentProject?.ProjectReferenceVideoWidth > 0) ? CurrentProject.ProjectReferenceVideoWidth : 1280.0;
            snap.ReferenceHeight = (CurrentProject?.ProjectReferenceVideoHeight > 0) ? CurrentProject.ProjectReferenceVideoHeight : 720.0;

            // [FIX UNDO/REDO] Luôn lưu view state để restore chính xác như CapCut
            if (includeViewState)
            {
                snap.PixelsPerSecond = _pixelsPerSecond > 0 ? _pixelsPerSecond : 50.0;
                snap.TimelineScrollOffsetX = TimelineScrollViewer?.HorizontalOffset;
                snap.TimelineScrollOffsetY = TimelineScrollViewer?.VerticalOffset;
            }
            return snap;
        }
        private void ApplySnapshot(EditorSnapshot snap)
        {
            if (snap == null)
            {
                return;
            }

            // [FIX FLICKERING] Suppress UI updates during snapshot application
            _isSuppressingTimelineUpdate = true;

            try
            {
                // [FIX UNDO/REDO] Build dictionary với composite key để match ViewModels
                var existingClipVMsByKey = new Dictionary<string, TimelineClipViewModel>();
                foreach (var clipVM in TimelineClips)
                {
                    string key = GetClipViewModelKey(clipVM);
                    if (!string.IsNullOrEmpty(key))
                    {
                        existingClipVMsByKey[key] = clipVM;
                    }
                }

                // [FIX WAVEFORM] Cache WavePeaks từ SourceData hiện tại trước khi clear
                var wavePeaksCache = new Dictionary<string, subphimv1.Waveform.WavePeakPyramid>();
                var waveformDataCache = new Dictionary<string, List<float>>();

                foreach (var clipVM in TimelineClips)
                {
                    if (clipVM.SourceData is MediaAsset ma && ma.WavePeaks != null)
                    {
                        string cacheKey = $"MA|{ma.FilePath}";
                        if (!wavePeaksCache.ContainsKey(cacheKey))
                        {
                            wavePeaksCache[cacheKey] = ma.WavePeaks;
                        }
                        if (ma.WaveformData != null && !waveformDataCache.ContainsKey(cacheKey))
                        {
                            waveformDataCache[cacheKey] = ma.WaveformData;
                        }
                    }
                    else if (clipVM.SourceData is TimelineAudioClip tac && tac.WavePeaks != null)
                    {
                        string cacheKey = $"TAC|{tac.FilePath}";
                        if (!wavePeaksCache.ContainsKey(cacheKey))
                        {
                            wavePeaksCache[cacheKey] = tac.WavePeaks;
                        }
                        if (tac.WaveformData != null && !waveformDataCache.ContainsKey(cacheKey))
                        {
                            waveformDataCache[cacheKey] = tac.WaveformData;
                        }
                    }
                }

                CurrentProject = snap.Project ?? new ProjectState();
                _currentProjectFilePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Projects", $"{CurrentProject.ProjectName}.json");

                // Update MediaBin
                VideoImageAssets.Clear();
                AudioAssets.Clear();
                SubtitleAssets.Clear();
                foreach (var a in snap.MediaBin_VideoImageAssets) VideoImageAssets.Add(a);
                foreach (var a in snap.MediaBin_AudioAssets) AudioAssets.Add(a);
                foreach (var a in snap.MediaBin_SubtitleAssets) SubtitleAssets.Add(a);

                // Update SrtSubtitleLinesView
                SrtSubtitleLinesView.Clear();
                foreach (var s in CurrentProject.Subtitles.OrderBy(x => x.StartTime)) SrtSubtitleLinesView.Add(s);
                foreach (var t in CurrentProject.TextClips.OrderBy(x => x.StartTime)) SrtSubtitleLinesView.Add(t);

                // [FIX TTS UNDO] Update BOTH TimelineAudioClips VÀ VoicedSubtitles để đảm bảo sync
                TimelineAudioClips.Clear();
                foreach (var c in snap.TimelineAudioClips) TimelineAudioClips.Add(c);

                // Sync lại VoicedSubtitles trong ProjectState
                if (CurrentProject != null)
                {
                    CurrentProject.VoicedSubtitles = snap.TimelineAudioClips?.ToList() ?? new List<TimelineAudioClip>();
                }

                // [FIX UNDO/REDO] Rebuild TimelineClips nhưng preserve cached data
                TimelineClips.Clear();

                // Add MediaAsset clips (Video/Audio/Image)
                foreach (var clipAsset in CurrentProject.TimelineMediaClips)
                {
                    string key = GetMediaAssetKey(clipAsset);
                    if (existingClipVMsByKey.TryGetValue(key, out var existingVM))
                    {
                        CopyViewModelCachedData(existingVM, clipAsset);
                    }

                    // [FIX WAVEFORM] Restore WavePeaks từ cache nếu chưa có
                    string waveCacheKey = $"MA|{clipAsset.FilePath}";
                    if (clipAsset.WavePeaks == null && wavePeaksCache.TryGetValue(waveCacheKey, out var cachedPeaks))
                    {
                        clipAsset.WavePeaks = cachedPeaks;
                    }
                    if (clipAsset.WaveformData == null && waveformDataCache.TryGetValue(waveCacheKey, out var cachedWaveform))
                    {
                        clipAsset.WaveformData = cachedWaveform;
                    }

                    var vm = new TimelineClipViewModel(clipAsset);
                    TimelineClips.Add(vm);
                }

                // Add Subtitle clips
                foreach (var s in CurrentProject.Subtitles)
                {
                    string key = GetSubtitleKey(s);
                    if (existingClipVMsByKey.TryGetValue(key, out var existingVM))
                    {
                        CopyViewModelCachedData(existingVM, s);
                    }
                    TimelineClips.Add(new TimelineClipViewModel(s));
                }

                // Add Text clips
                foreach (var t in CurrentProject.TextClips)
                {
                    string key = GetSubtitleKey(t, isText: true);
                    if (existingClipVMsByKey.TryGetValue(key, out var existingVM))
                    {
                        CopyViewModelCachedData(existingVM, t);
                    }
                    TimelineClips.Add(new TimelineClipViewModel(t));
                }

                // Add Audio clips (TTS/Voice)
                foreach (var tac in snap.TimelineAudioClips)
                {
                    string key = GetAudioClipKey(tac);
                    if (existingClipVMsByKey.TryGetValue(key, out var existingVM))
                    {
                        CopyViewModelCachedData(existingVM, tac);
                    }

                    // [FIX WAVEFORM] Restore WavePeaks từ cache nếu chưa có
                    string waveCacheKey = $"TAC|{tac.FilePath}";
                    if (tac.WavePeaks == null && wavePeaksCache.TryGetValue(waveCacheKey, out var cachedPeaks))
                    {
                        tac.WavePeaks = cachedPeaks;
                    }
                    if (tac.WaveformData == null && waveformDataCache.TryGetValue(waveCacheKey, out var cachedWaveform))
                    {
                        tac.WaveformData = cachedWaveform;
                    }

                    var vm = new TimelineClipViewModel(tac);
                    TimelineClips.Add(vm);
                }

                // [FIX UNDO/REDO] Restore view state từ snapshot
                if (snap.PixelsPerSecond > 0)
                {
                    _pixelsPerSecond = snap.PixelsPerSecond;
                }
                _playhead = TimeSpan.FromSeconds(Math.Max(0.0, snap.PlayheadSeconds));
                CurrentProject.ProjectReferenceVideoWidth = snap.ReferenceWidth > 0 ? snap.ReferenceWidth : 1280.0;
                CurrentProject.ProjectReferenceVideoHeight = snap.ReferenceHeight > 0 ? snap.ReferenceHeight : 720.0;
            }
            finally
            {
                _isSuppressingTimelineUpdate = false;
            }

            // Update UI sau khi hoàn tất - chỉ gọi một lần
            UpdatePlayerLayout();
            RecalculateTotalDuration();
            UpdateTimelineScaleAndRender();
            UpdateEditorPanelFromState();
            UpdateAllSubtitleDisplays();
            UpdatePlaybackUI(_playhead);

            // [FIX UNDO/REDO] Restore scroll position từ snapshot
            if (snap.TimelineScrollOffsetX.HasValue)
            {
                TimelineScrollViewer.ScrollToHorizontalOffset(snap.TimelineScrollOffsetX.Value);
            }
            if (snap.TimelineScrollOffsetY.HasValue)
            {
                TimelineScrollViewer.ScrollToVerticalOffset(snap.TimelineScrollOffsetY.Value);
            }
        }

        private string GetClipViewModelKey(TimelineClipViewModel vm)
        {
            if (vm.SourceData is MediaAsset ma)
                return GetMediaAssetKey(ma);
            else if (vm.SourceData is SrtSubtitleLine sub)
                return GetSubtitleKey(sub, sub.IsTextClip);
            else if (vm.SourceData is TimelineAudioClip tac)
                return GetAudioClipKey(tac);
            return null;
        }

        private string GetMediaAssetKey(MediaAsset ma)
        {
            return $"MA|{ma.FilePath}|{ma.StartTime.Ticks}|{ma.Type}";
        }

        private string GetSubtitleKey(SrtSubtitleLine sub, bool isText = false)
        {
            string type = isText ? "TEXT" : "SUB";
            return $"{type}|{sub.Index}|{sub.StartTime.Ticks}|{sub.OriginalText}";
        }

        private string GetAudioClipKey(TimelineAudioClip tac)
        {
            return $"TAC|{tac.FilePath}|{tac.StartTime.Ticks}";
        }

        private void CopyViewModelCachedData(TimelineClipViewModel existingVM, object newSourceData)
        {
            // Copy thumbnail và WavePeaks nếu có
            if (newSourceData is MediaAsset newMA && existingVM.SourceData is MediaAsset oldMA)
            {
                // Copy thumbnail
                if (!string.IsNullOrEmpty(oldMA.ThumbnailBase64))
                {
                    newMA.ThumbnailBase64 = oldMA.ThumbnailBase64;
                }

                // [FIX WAVEFORM] WavePeaks không serialize, cần preserve cho CẢ Audio VÀ Video
                // Video clips cũng có audio track và hiển thị waveform
                if (oldMA.WavePeaks != null && (newMA.Type == AssetType.Audio || newMA.Type == AssetType.Video))
                {
                    newMA.WavePeaks = oldMA.WavePeaks;
                }

                // Copy WaveformData nếu có (legacy support)
                if (oldMA.WaveformData != null && oldMA.WaveformData.Count > 0)
                {
                    newMA.WaveformData = oldMA.WaveformData;
                }
            }
            else if (newSourceData is TimelineAudioClip newTAC && existingVM.SourceData is TimelineAudioClip oldTAC)
            {
                // Preserve WavePeaks cho audio clips (TTS)
                if (oldTAC.WavePeaks != null)
                {
                    newTAC.WavePeaks = oldTAC.WavePeaks;
                }

                // Copy WaveformData nếu có
                if (oldTAC.WaveformData != null && oldTAC.WaveformData.Count > 0)
                {
                    newTAC.WaveformData = oldTAC.WaveformData;
                }
            }
        }

        private void UndoState()
        {
            // CRITICAL FIX: Preserve visual state during undo
            // Save current zoom, scroll, playhead position, and prepared visual caches
            double oldZoom = _pixelsPerSecond;
            double oldOffset = TimelineScrollViewer?.HorizontalOffset ?? 0;
            double oldVerticalOffset = TimelineScrollViewer?.VerticalOffset ?? 0;
            TimeSpan oldPlayhead = _playhead; // Preserve current playhead position

            // Store which clips had filmstrip/waveform prepared
            var preparedFilmstripClips = new HashSet<TimelineClipViewModel>(_preparedFilmstrip);
            var preparedWaveformClips = new HashSet<TimelineClipViewModel>(_preparedWaveform);

            var snap = _undoRedoService?.Undo();
            if (snap != null)
            {
                ApplySnapshot(snap);

                // Restore zoom, scroll, and playhead - keep user's view state
                _pixelsPerSecond = oldZoom;
                _playhead = oldPlayhead; // Keep playhead at current position instead of resetting
                UpdateTimelineScaleAndRender();
                TimelineScrollViewer?.ScrollToHorizontalOffset(oldOffset);
                TimelineScrollViewer?.ScrollToVerticalOffset(oldVerticalOffset);
                UpdatePlaybackUI(_playhead); // Update UI to reflect preserved playhead

                // Preserve filmstrip/waveform preparation state
                // This prevents expensive regeneration of thumbnails and waveforms
                foreach (var clip in TimelineClips)
                {
                    // Check if this clip (by content, not reference) was prepared before
                    var matchingPreparedFilmstrip = preparedFilmstripClips.FirstOrDefault(c =>
                        AreSameClip(c, clip));
                    if (matchingPreparedFilmstrip != null)
                    {
                        _preparedFilmstrip.Add(clip);
                    }

                    var matchingPreparedWaveform = preparedWaveformClips.FirstOrDefault(c =>
                        AreSameClip(c, clip));
                    if (matchingPreparedWaveform != null)
                    {
                        _preparedWaveform.Add(clip);
                    }
                }

                SaveProjectCurrent();
            }
        }

        /// <summary>
        /// Check if two clips represent the same content (by source, not by reference)
        /// </summary>
        private bool AreSameClip(TimelineClipViewModel clip1, TimelineClipViewModel clip2)
        {
            if (clip1 == null || clip2 == null) return false;
            if (clip1.ClipType != clip2.ClipType) return false;

            // Compare by source data
            if (clip1.SourceData is MediaAsset asset1 && clip2.SourceData is MediaAsset asset2)
            {
                return asset1.FilePath == asset2.FilePath &&
                       Math.Abs(asset1.StartTime.TotalSeconds - asset2.StartTime.TotalSeconds) < 0.01;
            }
            else if (clip1.SourceData is SrtSubtitleLine sub1 && clip2.SourceData is SrtSubtitleLine sub2)
            {
                return sub1.Index == sub2.Index &&
                       Math.Abs(sub1.StartTime.TotalSeconds - sub2.StartTime.TotalSeconds) < 0.01;
            }
            else if (clip1.SourceData is TimelineAudioClip audio1 && clip2.SourceData is TimelineAudioClip audio2)
            {
                return audio1.FilePath == audio2.FilePath &&
                       Math.Abs(audio1.StartTime.TotalSeconds - audio2.StartTime.TotalSeconds) < 0.01;
            }

            return false;
        }
        private void RedoState()
        {
            // CRITICAL FIX: Preserve visual state during redo
            // Save current zoom, scroll, playhead position, and prepared visual caches
            double oldZoom = _pixelsPerSecond;
            double oldOffset = TimelineScrollViewer?.HorizontalOffset ?? 0;
            double oldVerticalOffset = TimelineScrollViewer?.VerticalOffset ?? 0;
            TimeSpan oldPlayhead = _playhead; // Preserve current playhead position

            // Store which clips had filmstrip/waveform prepared
            var preparedFilmstripClips = new HashSet<TimelineClipViewModel>(_preparedFilmstrip);
            var preparedWaveformClips = new HashSet<TimelineClipViewModel>(_preparedWaveform);

            var snap = _undoRedoService?.Redo();
            if (snap != null)
            {
                ApplySnapshot(snap);

                // Restore zoom, scroll, and playhead - keep user's view state
                _pixelsPerSecond = oldZoom;
                _playhead = oldPlayhead; // Keep playhead at current position instead of resetting
                UpdateTimelineScaleAndRender();
                TimelineScrollViewer?.ScrollToHorizontalOffset(oldOffset);
                TimelineScrollViewer?.ScrollToVerticalOffset(oldVerticalOffset);
                UpdatePlaybackUI(_playhead); // Update UI to reflect preserved playhead

                // Preserve filmstrip/waveform preparation state
                // This prevents expensive regeneration of thumbnails and waveforms
                foreach (var clip in TimelineClips)
                {
                    // Check if this clip (by content, not reference) was prepared before
                    var matchingPreparedFilmstrip = preparedFilmstripClips.FirstOrDefault(c =>
                        AreSameClip(c, clip));
                    if (matchingPreparedFilmstrip != null)
                    {
                        _preparedFilmstrip.Add(clip);
                    }

                    var matchingPreparedWaveform = preparedWaveformClips.FirstOrDefault(c =>
                        AreSameClip(c, clip));
                    if (matchingPreparedWaveform != null)
                    {
                        _preparedWaveform.Add(clip);
                    }
                }

                SaveProjectCurrent();
            }
        }
        private void SubtitleDisplayModeComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (CurrentProject == null || _isUpdatingUiFromCode || !(SubtitleDisplayModeComboBox.SelectedItem is ComboBoxItem selectedItem))
            {
                return;
            }

            if (Enum.TryParse<SubtitleDisplayMode>(selectedItem.Tag.ToString(), out var selectedMode))
            {
                if (CurrentProject.SelectedSubtitleDisplayMode != selectedMode)
                {
                    CurrentProject.SelectedSubtitleDisplayMode = selectedMode;
                    UpdateAllSubtitleDisplays();
                    ProjectManager.SaveProject(CurrentProject);
                }
            }
        }

        private void SubtitleDisplayModeComboBox_DropDownOpened(object sender, EventArgs e)
        {
            bool hasAnyTranslatedText = SrtSubtitleLinesView.Any(l => !string.IsNullOrWhiteSpace(l.TranslatedText));
            TranslatedSubtitleOption.IsEnabled = hasAnyTranslatedText;
            if (!hasAnyTranslatedText && SubtitleDisplayModeComboBox.SelectedIndex == 1)
            {
                SubtitleDisplayModeComboBox.SelectedIndex = 0;
            }
        }

        private void UpdateAllSubtitleDisplays()
        {
            var subtitleClips = TimelineClips.Where(c => c.ClipType == TimelineClipType.Subtitle).ToList();
            foreach (var clipVM in subtitleClips)
            {
                if (clipVM.SourceData is SrtSubtitleLine srtLine)
                {
                    bool useTranslated = CurrentProject.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated && !string.IsNullOrWhiteSpace(srtLine.TranslatedText);
                    string newDisplayName = useTranslated ? srtLine.TranslatedText : srtLine.OriginalText;
                    clipVM.DisplayName = newDisplayName.Replace("\r\n", " ").Replace("\n", " ");
                }
            }
            UpdateSubtitleForCurrentTime(_playhead);
        }
        private void Timeline_DragOver(object sender, DragEventArgs e)
        {
            if (!e.Data.GetDataPresent(typeof(MediaAsset)))
            {
                e.Effects = DragDropEffects.None;
                e.Handled = true;
                return;
            }
            e.Effects = DragDropEffects.Copy;

            if (_dropHighlightBorder == null || _snapGuideline == null || this._pixelsPerSecond <= 0) return;

            var asset = e.Data.GetData(typeof(MediaAsset)) as MediaAsset;
            if (asset == null) return;

            System.Windows.Point positionInViewport = e.GetPosition(TimelineScrollViewer);
            double mouseAbsoluteX = TimelineScrollViewer.HorizontalOffset + positionInViewport.X;

            double clipWidth = asset.Duration.TotalSeconds * this._pixelsPerSecond;
            double clipHeight;
            switch (asset.Type)
            {
                case AssetType.Video:
                    clipHeight = TIMELINE_TRACK_HEIGHT;
                    _dropHighlightBorder.Background = new SolidColorBrush(((SolidColorBrush)FindResource("CapCut.AccentColorBlue")).Color) { Opacity = 0.6 };
                    break;

                case AssetType.Image:
                    clipHeight = 50;
                    _dropHighlightBorder.Background = new SolidColorBrush(Color.FromArgb(0x80, 0x8A, 0x2B, 0xE2));
                    break;

                case AssetType.Audio:
                    clipHeight = TIMELINE_AUDIO_TRACK_HEIGHT;
                    _dropHighlightBorder.Background = new SolidColorBrush(Color.FromArgb(0x80, 0x00, 0x80, 0x60));
                    break;

                case AssetType.Subtitle:
                    clipHeight = 20;
                    _dropHighlightBorder.Background = new SolidColorBrush(Color.FromArgb(0x80, 0xFF, 0xA5, 0x00));
                    break;

                default:
                    clipHeight = TIMELINE_TRACK_HEIGHT;
                    _dropHighlightBorder.Background = new SolidColorBrush(((SolidColorBrush)FindResource("CapCut.AccentColorBlue")).Color) { Opacity = 0.6 };
                    break;
            }

            _dropHighlightBorder.Width = Math.Max(10, clipWidth);
            _dropHighlightBorder.Height = clipHeight;

            double finalAbsoluteX = mouseAbsoluteX;
            bool snapped = false;
            double snapLineAbsoluteX = 0;
            const double snapToleranceInPixels = 8.0;

            double potentialStartX = mouseAbsoluteX;
            double potentialEndX = mouseAbsoluteX + clipWidth;

            _snapGuideline.Visibility = Visibility.Collapsed;

            foreach (var existingClip in TimelineClips)
            {
                double existingClipStartX = existingClip.X;
                double existingClipEndX = existingClip.X + existingClip.Width;
                if (Math.Abs(potentialStartX - existingClipStartX) < snapToleranceInPixels)
                {
                    finalAbsoluteX = existingClipStartX;
                    snapLineAbsoluteX = existingClipStartX;
                    snapped = true;
                    break;
                }
                if (Math.Abs(potentialStartX - existingClipEndX) < snapToleranceInPixels)
                {
                    finalAbsoluteX = existingClipEndX;
                    snapLineAbsoluteX = existingClipEndX;
                    snapped = true;
                    break;
                }
                if (Math.Abs(potentialEndX - existingClipStartX) < snapToleranceInPixels)
                {
                    finalAbsoluteX = existingClipStartX - clipWidth;
                    snapLineAbsoluteX = existingClipStartX;
                    snapped = true;
                    break;
                }
                if (Math.Abs(potentialEndX - existingClipEndX) < snapToleranceInPixels)
                {
                    finalAbsoluteX = existingClipEndX - clipWidth;
                    snapLineAbsoluteX = existingClipEndX;
                    snapped = true;
                    break;
                }
            }

            double finalVisualX = finalAbsoluteX - TimelineScrollViewer.HorizontalOffset;
            double finalVisualY = positionInViewport.Y - (clipHeight / 2.0);

            Canvas.SetLeft(_dropHighlightBorder, finalVisualX);
            Canvas.SetTop(_dropHighlightBorder, finalVisualY);

            if (snapped)
            {
                double snapLineVisualX = snapLineAbsoluteX - TimelineScrollViewer.HorizontalOffset;
                Canvas.SetLeft(_snapGuideline, snapLineVisualX - (_snapGuideline.Width / 2));
                Canvas.SetTop(_snapGuideline, 0);
                _snapGuideline.Height = TracksContainerGrid.ActualHeight;
                _snapGuideline.Visibility = Visibility.Visible;
            }

            e.Handled = true;
        }

        private void Timeline_DragLeave(object sender, DragEventArgs e)
        {
            PositionMarkerThumb.IsHitTestVisible = true;
            if (_dropHighlightBorder != null) _dropHighlightBorder.Visibility = Visibility.Collapsed;
            if (_snapGuideline != null) _snapGuideline.Visibility = Visibility.Collapsed;
            e.Handled = true;
        }
        private void MediaBinScrollViewer_PreviewMouseWheel(object sender, MouseWheelEventArgs e)
        {
            if (sender is ScrollViewer scrollViewer)
            {
                double newOffset = scrollViewer.VerticalOffset - e.Delta;
                scrollViewer.ScrollToVerticalOffset(newOffset);


                e.Handled = true;
            }
        }
        private void RecalculateTotalDuration()
        {
            if (TimelineClips.Any())
            {
                _actualContentDuration = TimelineClips.Max(c => c.EndTime);
            }
            else
            {
                _actualContentDuration = TimeSpan.Zero;
            }
            if (_actualContentDuration > TimeSpan.Zero)
            {
                double paddingSeconds = 30.0;
                _totalTimelineDuration = _actualContentDuration + TimeSpan.FromSeconds(paddingSeconds);
            }
            else
            {
                _totalTimelineDuration = TimeSpan.FromMinutes(5);
            }
            totalDurationTextBlock.Text = _actualContentDuration > TimeSpan.Zero ? _actualContentDuration.ToString(@"hh\:mm\:ss\.fff") : "00:00:00.000";
            RenderTimeline(this._pixelsPerSecond);
            DrawRuler(this._pixelsPerSecond);
            UpdatePositionMarkerVisuals();
        }
        private TimelineClipViewModel FindActiveVideoClipAt(TimeSpan t)
        {
            var mainMediaClip = TimelineClips
                .Where(c => c.TrackIndex == 0 &&
                            (c.ClipType == TimelineClipType.Video) &&
                            c.StartTime <= t && c.EndTime > t)
                .FirstOrDefault();

            if (mainMediaClip != null)
            {
                return mainMediaClip;
            }

            var foundClip = TimelineClips
                .Where(c => (c.ClipType == TimelineClipType.Video) && c.StartTime <= t && c.EndTime > t)
                .OrderByDescending(c => c.TrackIndex)
                .FirstOrDefault();

            return foundClip;
        }
        #region New Playback Engine & Timeline Interaction
        private void CompositionTarget_Rendering(object sender, EventArgs e)
        {
            if (!_isTimelinePlaying || _isUserDraggingPlayhead || _isSwitchingVideoSource || _isExplicitSeekInProgress)
            {
                if (_renderStopwatch.IsRunning)
                {
                    _renderStopwatch.Stop();
                }
                return;
            }
            _videoOptimizer?.RecordFrameRender();
            bool playheadAdvanced = false;
            if (_activeVideoClip != null && _newPlaybackController != null && _isTimelinePlaying)
            {
                var mediaAsset = _activeVideoClip.SourceData as MediaAsset;
                var trimStart = mediaAsset?.TrimStartOffset ?? TimeSpan.Zero;
                var positionInTimeline = _activeVideoClip.StartTime + _newPlaybackController.Position - trimStart;

                if (positionInTimeline < TimeSpan.Zero)
                    positionInTimeline = TimeSpan.Zero;

                _playhead = positionInTimeline;
                playheadAdvanced = true;
                _renderStopwatch.Restart();
            }
            if (!playheadAdvanced)
            {
                if (!_renderStopwatch.IsRunning)
                {
                    _renderStopwatch.Start();
                }

                _playhead += _renderStopwatch.Elapsed;
                _renderStopwatch.Restart();
            }
            if (_actualContentDuration > TimeSpan.Zero && _playhead >= _actualContentDuration)
            {
                _playhead = _actualContentDuration;
                _ = PauseTimelinePlayback();

                UpdatePlaybackUI(_playhead);
                UpdateSubtitleForCurrentTime(_playhead);
                UpdateOverlaysForCurrentTime(_playhead);
                _audioEngine?.Update(_playhead, TimelineClips);
                return;
            }
            UpdatePlaybackUI(_playhead);
            UpdateSubtitleForCurrentTime(_playhead);
            UpdateOverlaysForCurrentTime(_playhead);
            _audioEngine?.Update(_playhead, TimelineClips);
            var expectedClip = FindActiveVideoClipAt(_playhead);
            if (expectedClip != _activeVideoClip && _videoOptimizer?.IsSeekPending() != true)
            {
                _ = SwitchActiveVideoClip(expectedClip, resume: true);
            }
            double absoluteX = _playhead.TotalSeconds * _pixelsPerSecond;
            double left = TimelineScrollViewer.HorizontalOffset;
            double right = left + TimelineScrollViewer.ViewportWidth;
            const double padding = 40.0;

            if (absoluteX > right - padding)
            {
                TimelineScrollViewer.ScrollToHorizontalOffset(Math.Max(0, absoluteX - padding));
            }
            else if (absoluteX < left + padding)
            {
                TimelineScrollViewer.ScrollToHorizontalOffset(Math.Max(0, absoluteX - padding));
            }
        }
        private void EnterFramePreviewMode()
        {
            if (_isFramePreviewMode)
                return;

            _isFramePreviewMode = true;
            _wasPlayingBeforeFramePreview = _isTimelinePlaying;

            if (_isTimelinePlaying)
            {
                _ = PauseTimelinePlayback();
            }
        }
        private async Task ExitFramePreviewMode(bool restorePlayback)
        {
            if (!_isFramePreviewMode) return;

            _isFramePreviewMode = false;
            _wasPlayingBeforeFramePreview = false;

            await Task.CompletedTask;
        }
        
        private TimelineClipViewModel FindActiveVisualClipAt(TimeSpan timelineTime)
        {
            if (TimelineClips == null || TimelineClips.Count == 0)
                return null;

            TimelineClipViewModel candidate = null;

            foreach (var clip in TimelineClips)
            {
                if (clip == null || (clip.ClipType != TimelineClipType.Video && clip.ClipType != TimelineClipType.Image))
                    continue;

                var start = clip.StartTime;
                var end = clip.EndTime;
                if (timelineTime < start || timelineTime >= end)
                    continue;
                if (candidate == null ||
                    clip.TrackIndex < candidate.TrackIndex ||
                    (clip.TrackIndex == candidate.TrackIndex && clip.StartTime >= candidate.StartTime))
                {
                    candidate = clip;
                }
            }
            if (candidate == null)
            {
                candidate = TimelineClips.FirstOrDefault(c =>
                    c.ClipType == TimelineClipType.Video &&
                    c.TrackIndex == 0 &&
                    timelineTime >= c.StartTime && timelineTime < c.EndTime);
            }

            return candidate;
        }
        private TimeSpan GetLocalTimeInClip(TimeSpan timelineTime, TimelineClipViewModel clip)
        {
            return ComputePositionInClip(timelineTime, clip);
        }
        private async void UpdateScrubbingPreview(TimeSpan timelineTime)
        {
            if (!_useNewPlaybackSystem || _newPlaybackController == null)
                return;

            var visualClip = FindActiveVisualClipAt(timelineTime);

            if (visualClip != null && visualClip.ClipType == TimelineClipType.Video)
            {
                if (visualClip.SourceData is not MediaAsset ma ||
                    string.IsNullOrEmpty(ma.FilePath) ||
                    !File.Exists(ma.FilePath))
                {
                    return;
                }

                try
                {
                    if (!string.Equals(_framePreviewSourcePath, ma.FilePath, StringComparison.OrdinalIgnoreCase))
                    {
                        var success = await _newPlaybackController.OpenAsync(ma.FilePath);
                        if (!success)
                        {
                            return;
                        }
                        _framePreviewSourcePath = ma.FilePath;
                        _framePreviewActiveVideoClip = visualClip;
                        _newPlaybackController.StartScrubbing();
                    }
                    var local = GetLocalTimeInClip(timelineTime, visualClip);
                    if (local < TimeSpan.Zero)
                        local = TimeSpan.Zero;
                    await _newPlaybackController.UpdateScrubPositionAsync(local);
                    UpdateOverlaysForCurrentTime(timelineTime);
                }
                catch (Exception ex)
                {
                }
            }
        }
        private async void ShowFramePreviewAt(TimeSpan timelineTime, bool updateMainPlayhead = true)
        {
            EnterFramePreviewMode();

            if (updateMainPlayhead)
            {
                _playhead = timelineTime;
            }

            var visualClip = FindActiveVisualClipAt(timelineTime);

            if (visualClip != null && visualClip.ClipType == TimelineClipType.Video)
            {
                await ShowVideoFramePreview_NewPlayback(visualClip, timelineTime);
            }
            UpdatePlaybackUI(updateMainPlayhead ? _playhead : timelineTime);
            UpdateSubtitleForCurrentTime(timelineTime);
            UpdateOverlaysForCurrentTime(timelineTime);
        }
        private async Task ShowVideoFramePreview_NewPlayback(TimelineClipViewModel videoClip, TimeSpan timelineTime)
        {
            if (videoClip?.SourceData is not MediaAsset ma ||
                string.IsNullOrEmpty(ma.FilePath) ||
                !File.Exists(ma.FilePath))
            {
                return;
            }

            if (!_useNewPlaybackSystem || _newPlaybackController == null)
                return;

            try
            {
                if (!string.Equals(_framePreviewSourcePath, ma.FilePath, StringComparison.OrdinalIgnoreCase))
                {
                    var success = await _newPlaybackController.OpenAsync(ma.FilePath);
                    if (!success)
                    {
                        return;
                    }

                    _framePreviewSourcePath = ma.FilePath;
                    _framePreviewActiveVideoClip = videoClip;
                }
                var local = GetLocalTimeInClip(timelineTime, videoClip);
                if (local < TimeSpan.Zero)
                    local = TimeSpan.Zero;
                await _newPlaybackController.SeekAsync(local);

            }
            catch (Exception ex)
            {
            }
        }
        public async Task StartTimelinePlayback()
        {

            if (_isFramePreviewMode)
            {
                await ExitFramePreviewMode(restorePlayback: false);
            }

            if (_actualContentDuration > TimeSpan.Zero && _playhead >= _actualContentDuration)
            {
                await SeekTimeline(TimeSpan.Zero);
            }

            if (_isTimelinePlaying)
            {
                return;
            }

            var token = NewTransportVersion();

            try
            {
                _audioEngine?.SeekTo(_playhead, TimelineClips);

                var clipToPlay = FindActiveVideoClipAt(_playhead);

                if (_activeVideoClip != clipToPlay)
                {
                    await SwitchActiveVideoClip_NewPlayback(clipToPlay, skipInitialSeek: true);
                }

                if (clipToPlay != null && clipToPlay.ClipType == TimelineClipType.Video)
                {
                    var positionInClip = ComputePositionInClip(_playhead, clipToPlay);
                    await NewPlayback_SeekAsync(positionInClip);
                    await NewPlayback_PlayAsync();
                }
                _audioEngine?.Play();

                _isTimelinePlaying = true;
                playPauseButton.Content = "\uE769";

                _renderStopwatch.Reset();
                _renderStopwatch.Start();

            }
            catch (Exception ex) { }
        }
        public async Task PauseTimelinePlayback()
        {
            if (!_isTimelinePlaying) return;
            _isTimelinePlaying = false;
            await NewPlayback_PauseAsync();
            _audioEngine?.Pause();
            if (_activeVideoClip != null && _newPlaybackController != null)
            {
                var ma = _activeVideoClip.SourceData as MediaAsset;
                var trimStart = ma?.TrimStartOffset ?? TimeSpan.Zero;
                var positionInClip = _newPlaybackController.Position;
                _playhead = _activeVideoClip.StartTime + positionInClip - trimStart;
                UpdatePlaybackUI(_playhead);
                UpdateSubtitleForCurrentTime(_playhead);
            }
            _pendingWasPlaying = false;
            playPauseButton.Content = "\uE768";
            _renderStopwatch.Reset();
        }
        private async Task SeekTimeline(TimeSpan targetTime, string seekId = null)
        {
            if (string.IsNullOrEmpty(seekId)) seekId = Guid.NewGuid().ToString("N").Substring(0, 8);
            if (_isExplicitSeekInProgress)
            {
                return;
            }

            _isExplicitSeekInProgress = true;
            var token = NewTransportVersion();

            try
            {
                bool wasPlaying = _isTimelinePlaying;
                if (wasPlaying)
                {
                    await PauseTimelinePlayback();
                }
                await ExitFramePreviewMode(restorePlayback: false);

                if (_actualContentDuration <= TimeSpan.Zero)
                {
                    return;
                }
                var clamped = TimeSpan.FromTicks(Math.Clamp(targetTime.Ticks, 0, _totalTimelineDuration.Ticks));
                _playhead = clamped;
                UpdatePlaybackUI(_playhead);
                UpdateSubtitleForCurrentTime(_playhead);
                UpdateOverlaysForCurrentTime(_playhead);
                _audioEngine?.SeekTo(_playhead, TimelineClips);
                var clip = FindActiveVideoClipAt(_playhead);
                if (clip != null && clip.ClipType == TimelineClipType.Video)
                {
                    await SwitchActiveVideoClip_NewPlayback(clip, skipInitialSeek: true);
                    var posInClip = ComputePositionInClip(_playhead, clip);
                    await NewPlayback_SeekAsync(posInClip);
                }
                if (wasPlaying)
                {
                    await StartTimelinePlayback();
                }
            }
            catch (Exception ex) { }
            finally
            {
                _isExplicitSeekInProgress = false;
            }
        }
        private async Task SwitchActiveVideoClip_NewPlayback(TimelineClipViewModel targetClip, bool skipInitialSeek = false)
        {
            if (_activeVideoClip == targetClip) return;

            _activeVideoClip = targetClip;

            if (targetClip == null)
            {
                if (NewPlaybackImage != null)
                    NewPlaybackImage.Visibility = Visibility.Collapsed;
                StaticImagePlayer.Visibility = Visibility.Collapsed;
                return;
            }
            var ma = targetClip.SourceData as MediaAsset;
            if (ma == null || string.IsNullOrEmpty(ma.FilePath) || !File.Exists(ma.FilePath))
            {
                return;
            }

            if (ma.Type == AssetType.Video)
            {
                if (!_useNewPlaybackSystem || _newPlaybackController == null)
                {
                    MessageBox.Show(
                        "Lỗi: Hệ thống playback chưa được khởi tạo.\n\n" +
                        "Vui lòng khởi động lại ứng dụng.",
                        "Lỗi Playback",
                        MessageBoxButton.OK,
                        MessageBoxImage.Error);
                    return;
                }
                var success = await NewPlayback_OpenVideoAsync(ma.FilePath, skipInitialSeek);

                if (!success)
                {
                    return;
                }
                if (NewPlaybackImage != null)
                {
                    NewPlaybackImage.Visibility = Visibility.Visible;
                    StaticImagePlayer.Visibility = Visibility.Collapsed;
                }
                if (NewPlaybackImage != null && NewPlaybackImage.RenderTransform != null)
                {
                    UpdateVideoTransform(ma);
                }
                else{ }
                if (_useNewPlaybackSystem)
                {
                    SetupVideoVolumeMonitoring();
                }
            }
            else if (ma.Type == AssetType.Image)
            {
                try
                {
                    var bitmap = new BitmapImage();
                    bitmap.BeginInit();
                    bitmap.UriSource = new Uri(ma.FilePath);
                    bitmap.CacheOption = BitmapCacheOption.OnLoad;
                    bitmap.EndInit();
                    bitmap.Freeze();
                    StaticImagePlayer.Source = bitmap;
                    StaticImagePlayer.Visibility = Visibility.Visible;

                    if (NewPlaybackImage != null)
                        NewPlaybackImage.Visibility = Visibility.Collapsed;
                }
                catch (Exception ex)
                {
                    StaticImagePlayer.Visibility = Visibility.Collapsed;
                }
            }
        }
        private async Task SwitchActiveVideoClip(TimelineClipViewModel targetClip, bool? resume = null)
        {
            await SwitchActiveVideoClip_NewPlayback(targetClip);
            if (resume == true || _pendingWasPlaying)
            {
                _isTimelinePlaying = true;
                _audioEngine?.Play();
                playPauseButton.Content = "\uE769";
            }
        }
        private void MediaPlayer_MediaFailed_Log(object sender, ExceptionRoutedEventArgs e)
        {
            if (_isSwitchingVideoSource)
            {
                _isSwitchingVideoSource = false;
            }
        }
        private void TimelineParentGrid_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            var originalSource = e.OriginalSource as DependencyObject;
            if (FindVisualParent<System.Windows.Controls.Primitives.ScrollBar>(originalSource) != null ||
                (FindVisualParent<ContentPresenter>(originalSource)?.DataContext is TimelineClipViewModel) ||
                originalSource == PositionMarkerThumb || FindVisualParent<Thumb>(originalSource) == PositionMarkerThumb)
            {
                return;
            }
            if (Keyboard.Modifiers == ModifierKeys.None)
            {
                _isMarqueeSelecting = true;
                _marqueeStartPoint = e.GetPosition(TracksContainerGrid);
                foreach (var clip in TimelineClips.Where(c => c.IsSelected))
                {
                    clip.IsSelected = false;
                }
                UpdateEditorPanelVisibility();
                RemoveVideoAdorner();
                RemoveSubtitleAdorner();
                Canvas.SetLeft(SelectionRectangle, _marqueeStartPoint.X);
                Canvas.SetTop(SelectionRectangle, _marqueeStartPoint.Y);
                SelectionRectangle.Width = 0;
                SelectionRectangle.Height = 0;

                TimelineParentGrid.CaptureMouse();
                e.Handled = true;
            }
        }

        private List<TimelineClipViewModel> _draggedClipGroup = new List<TimelineClipViewModel>();
        private Dictionary<TimelineClipViewModel, System.Windows.Point> _dragGroupInitialPositions = new Dictionary<TimelineClipViewModel, System.Windows.Point>();

        private async void MainWindow_PreviewMouseMove(object sender, MouseEventArgs e)
        {
            if (_isMarqueeSelecting && e.LeftButton == MouseButtonState.Pressed)
            {
                SelectionRectangle.Visibility = Visibility.Visible;
                System.Windows.Point currentPoint = e.GetPosition(TracksContainerGrid);
                double left = Math.Min(_marqueeStartPoint.X, currentPoint.X);
                double top = Math.Min(_marqueeStartPoint.Y, currentPoint.Y);
                double width = Math.Abs(_marqueeStartPoint.X - currentPoint.X);
                double height = Math.Abs(_marqueeStartPoint.Y - currentPoint.Y);
                Canvas.SetLeft(SelectionRectangle, left);
                Canvas.SetTop(SelectionRectangle, top);
                SelectionRectangle.Width = width;
                SelectionRectangle.Height = height;

                System.Windows.Rect selectionRect = new System.Windows.Rect(left, top, width, height);
                double pps = this._pixelsPerSecond;
                foreach (var clipVM in TimelineClips)
                {
                    // [FIX] Calculate clip position on-the-fly to avoid stale values for non-visible clips
                    // This fixes multi-clip selection accuracy when timeline is zoomed
                    double clipX = clipVM.StartTime.TotalSeconds * pps;
                    double clipWidth = Math.Max(1.0, clipVM.Duration.TotalSeconds * pps);
                    System.Windows.Rect clipRect = new System.Windows.Rect(clipX, clipVM.Y, clipWidth, clipVM.Height);
                    clipVM.IsSelected = selectionRect.IntersectsWith(clipRect);
                }

                e.Handled = true;
                return;
            }

            if (_isAdornerDragging) return;

            var original = e.OriginalSource as DependencyObject;
            if (original != null)
            {
                if (original is SubtitleAdorner || FindVisualParent<SubtitleAdorner>(original) != null) return;
            }
            if (_isPreparingToDragClip && e.LeftButton == MouseButtonState.Pressed && _selectedTimelineClip != null)
            {
                if (IsMouseOverElement(TracksContainerGrid, e))
                {
                    System.Windows.Point cur = e.GetPosition(TracksContainerGrid);
                    if (Math.Abs(cur.X - _dragStartPointInGrid.X) > SystemParameters.MinimumHorizontalDragDistance ||
                        Math.Abs(cur.Y - _dragStartPointInGrid.Y) > SystemParameters.MinimumVerticalDragDistance)
                    {
                        _currentDragMode = DragMode.MoveClip;
                        _isPreparingToDragClip = false;

                        _draggedClipGroup = TimelineClips.Where(c => c.IsSelected).ToList();
                        _dragGroupInitialPositions.Clear();
                        foreach (var clip in _draggedClipGroup)
                        {
                            _dragGroupInitialPositions[clip] = new System.Windows.Point(clip.X, clip.Y);
                        }
                    }
                }
                else
                {
                    _isPreparingToDragClip = false;
                }
            }

            if (_currentDragMode == DragMode.None || e.LeftButton != MouseButtonState.Pressed || _selectedTimelineClip == null) return;

            switch (_currentDragMode)
            {
                case DragMode.MoveClip:
                    if (!_draggedClipGroup.Any()) break;
                    System.Windows.Point currentMousePos = e.GetPosition(TracksContainerGrid);
                    double deltaX = currentMousePos.X - _dragStartPointInGrid.X;
                    double deltaY = currentMousePos.Y - _dragStartPointInGrid.Y;

                    foreach (var clip in _draggedClipGroup)
                    {
                        var initialPos = _dragGroupInitialPositions[clip];
                        clip.X = initialPos.X + deltaX;
                        clip.Y = initialPos.Y + deltaY;
                    }
                    const double snapToleranceInPixels = 8.0;
                    double? snapLineX = null;
                    var otherClips = TimelineClips.Where(c => !_draggedClipGroup.Contains(c)).ToList();

                    if (otherClips.Any() && this._pixelsPerSecond > 0)
                    {
                        foreach (var draggedClip in _draggedClipGroup)
                        {
                            double draggedStartX = draggedClip.X;
                            double draggedEndX = draggedClip.X + draggedClip.Width;
                            foreach (var otherClip in otherClips)
                            {
                                double otherStartX = otherClip.X;
                                double otherEndX = otherClip.X + otherClip.Width;
                                if (Math.Abs(draggedStartX - otherStartX) < snapToleranceInPixels)
                                {
                                    snapLineX = otherStartX;
                                    break;
                                }
                                else if (Math.Abs(draggedStartX - otherEndX) < snapToleranceInPixels)
                                {
                                    snapLineX = otherEndX;
                                    break;
                                }
                                else if (Math.Abs(draggedEndX - otherStartX) < snapToleranceInPixels)
                                {
                                    snapLineX = otherStartX;
                                    break;
                                }
                                else if (Math.Abs(draggedEndX - otherEndX) < snapToleranceInPixels)
                                {
                                    snapLineX = otherEndX;
                                    break;
                                }
                            }

                            if (snapLineX.HasValue) break;
                        }
                        if (snapLineX.HasValue)
                        {
                            MoveSnapGuideline.Visibility = Visibility.Visible;
                            MoveSnapGuideline.Margin = new Thickness(snapLineX.Value - TimelineScrollViewer.HorizontalOffset, 0, 0, 0);
                        }
                        else
                        {
                            MoveSnapGuideline.Visibility = Visibility.Collapsed;
                        }
                    }

                    break;

                case DragMode.AdjustVolume:
                    var container = MainTimelineControl.ItemContainerGenerator.ContainerFromItem(_selectedTimelineClip) as ContentPresenter;
                    var canvas = FindVisualChild<Canvas>(container, "AudioCanvas");
                    if (canvas == null || canvas.ActualHeight <= 0) return;
                    var mousePosInCanvas = e.GetPosition(canvas);
                    var newTop = Math.Clamp(mousePosInCanvas.Y, 0, canvas.ActualHeight);
                    var ratio = (canvas.ActualHeight - newTop) / canvas.ActualHeight;
                    var newDb = MIN_DB + (ratio * (MAX_DB - MIN_DB));
                    _selectedTimelineClip.VolumeDb = newDb;
                    _selectedTimelineClip.VolumeDb = newDb;
                    if (_selectedTimelineClip.ClipType == TimelineClipType.Video
                        && ReferenceEquals(_selectedTimelineClip, _activeVideoClip)
                        && _activeVideoClip?.SourceData is MediaAsset) { }
                    break;
                case DragMode.ResizeClip:
                    if (_draggedResizeHandle == null) return;
                    Mouse.SetCursor(Cursors.SizeWE);
                    if (this._pixelsPerSecond <= 0) return;
                    System.Windows.Point currentMousePosInGrid = e.GetPosition(TracksContainerGrid);
                    double deltaXResize = currentMousePosInGrid.X - _dragStartPointInGrid.X;
                    TimeSpan timeDeltaOnTimeline = TimeSpan.FromSeconds(deltaXResize / this._pixelsPerSecond);
                    var currentVM = _selectedTimelineClip;
                    TimeSpan guidelineTimeOnTimeline = TimeSpan.Zero;
                    var minDurationOnTimeline = TimeSpan.FromMilliseconds(100);
                    if (currentVM.SourceData is SrtSubtitleLine srtLine)
                    {
                        if (_draggedResizeHandle.Name == "LeftHandle")
                        {
                            TimeSpan newStartTime = _resizeInitialStartTime + timeDeltaOnTimeline;
                            if (newStartTime >= _resizeInitialEndTime - minDurationOnTimeline) newStartTime = _resizeInitialEndTime - minDurationOnTimeline;
                            if (newStartTime < TimeSpan.Zero) newStartTime = TimeSpan.Zero;
                            srtLine.StartTime = newStartTime;
                            srtLine.Duration = _resizeInitialEndTime - newStartTime;
                            guidelineTimeOnTimeline = srtLine.StartTime;
                        }
                        else
                        {
                            TimeSpan newEndTime = _resizeInitialEndTime + timeDeltaOnTimeline;
                            if (newEndTime <= srtLine.StartTime + minDurationOnTimeline) newEndTime = srtLine.StartTime + minDurationOnTimeline;
                            srtLine.EndTime = newEndTime;
                            guidelineTimeOnTimeline = srtLine.EndTime;
                        }
                    }
                    else if (currentVM.SourceData is MediaAsset imageAsset && imageAsset.Type == AssetType.Image)
                    {
                        if (_draggedResizeHandle.Name == "LeftHandle")
                        {
                            TimeSpan newStartTime = _resizeInitialStartTime + timeDeltaOnTimeline;
                            if (newStartTime >= _resizeInitialEndTime - minDurationOnTimeline) newStartTime = _resizeInitialEndTime - minDurationOnTimeline;
                            if (newStartTime < TimeSpan.Zero) newStartTime = TimeSpan.Zero;

                            currentVM.StartTime = newStartTime;
                            imageAsset.Duration = _resizeInitialEndTime - newStartTime;
                            guidelineTimeOnTimeline = currentVM.StartTime;
                        }
                        else
                        {
                            TimeSpan newEndTime = _resizeInitialEndTime + timeDeltaOnTimeline;
                            if (newEndTime <= currentVM.StartTime + minDurationOnTimeline) newEndTime = currentVM.StartTime + minDurationOnTimeline;

                            imageAsset.Duration = newEndTime - currentVM.StartTime;
                            guidelineTimeOnTimeline = currentVM.EndTime;
                        }
                        PopulateImageFilmstrip(currentVM);
                    }
                    else if (currentVM.SourceData is MediaAsset || currentVM.SourceData is TimelineAudioClip)
                    {
                        double speed = currentVM.Speed;
                        TimeSpan originalDuration = (currentVM.SourceData is MediaAsset ma_dur) ? ma_dur.Duration : ((TimelineAudioClip)currentVM.SourceData).OriginalDuration;
                        TimeSpan timeDeltaInSourceFile = TimeSpan.FromSeconds(timeDeltaOnTimeline.TotalSeconds * speed);

                        if (_draggedResizeHandle.Name == "LeftHandle")
                        {
                            var newTrimStartOffset = _resizeInitialTrimStartOffset + timeDeltaInSourceFile;
                            var minEffectiveDurationInSource = TimeSpan.FromSeconds(minDurationOnTimeline.TotalSeconds * speed);
                            var maxTrimStart = originalDuration - _resizeInitialTrimEndOffset - minEffectiveDurationInSource;
                            if (newTrimStartOffset > maxTrimStart) newTrimStartOffset = maxTrimStart;
                            if (newTrimStartOffset < TimeSpan.Zero) newTrimStartOffset = TimeSpan.Zero;
                            var actualTrimDeltaInSource = newTrimStartOffset - _resizeInitialTrimStartOffset;
                            var actualTimelineDelta = TimeSpan.FromSeconds(actualTrimDeltaInSource.TotalSeconds / speed);
                            currentVM.StartTime = _resizeInitialStartTime + actualTimelineDelta;
                            if (currentVM.SourceData is MediaAsset mas) mas.TrimStartOffset = newTrimStartOffset;
                            else if (currentVM.SourceData is TimelineAudioClip tac) tac.TrimStartOffset = newTrimStartOffset;

                            guidelineTimeOnTimeline = currentVM.StartTime;

                        }
                        else
                        {
                            var newTrimEndOffset = _resizeInitialTrimEndOffset - timeDeltaInSourceFile;
                            var minEffectiveDurationInSource = TimeSpan.FromSeconds(minDurationOnTimeline.TotalSeconds * speed);
                            var maxTrimEnd = originalDuration - _resizeInitialTrimStartOffset - minEffectiveDurationInSource;
                            if (newTrimEndOffset > maxTrimEnd) newTrimEndOffset = maxTrimEnd;
                            if (newTrimEndOffset < TimeSpan.Zero) newTrimEndOffset = TimeSpan.Zero;
                            if (currentVM.SourceData is MediaAsset mas) mas.TrimEndOffset = newTrimEndOffset;
                            else if (currentVM.SourceData is TimelineAudioClip tac) tac.TrimEndOffset = newTrimEndOffset;
                            guidelineTimeOnTimeline = currentVM.StartTime + currentVM.Duration - TimeSpan.FromMilliseconds(1);

                        }
                    }

                    currentVM.RefreshPropertiesFromSource();

                    bool staticSmartCutOn = _currentSmartCutMode == SmartCutMode.StaticReview &&
                                            _smartCutSegmentMaps != null &&
                                            _smartCutSegmentMaps.Count > 0;

                    TimeSpan drawStart, drawDuration;

                    if (staticSmartCutOn)
                    {
                        TimeSpan mappedStart = MapSourceTimeToSmartCut(currentVM.StartTime);
                        TimeSpan mappedEnd = MapSourceTimeToSmartCut(currentVM.EndTime);
                        if (mappedEnd < mappedStart) mappedEnd = mappedStart;
                        drawStart = mappedStart;
                        drawDuration = mappedEnd - mappedStart;
                    }
                    else
                    {
                        drawStart = currentVM.StartTime;
                        drawDuration = currentVM.Duration;
                    }

                    currentVM.X = drawStart.TotalSeconds * this._pixelsPerSecond;
                    currentVM.Width = Math.Max(1.0, drawDuration.TotalSeconds * this._pixelsPerSecond);
                    if (_currentSmartCutMode == SmartCutMode.StaticReview)
                    {
                        guidelineTimeOnTimeline = MapSourceTimeToSmartCut(guidelineTimeOnTimeline);
                    }
                    double guidelineAbsolutePosition = guidelineTimeOnTimeline.TotalSeconds * this._pixelsPerSecond;
                    ResizeGuideline.Margin = new Thickness(guidelineAbsolutePosition - TimelineScrollViewer.HorizontalOffset, 0, 0, 0);

                    if (guidelineTimeOnTimeline < TimeSpan.Zero)
                        guidelineTimeOnTimeline = TimeSpan.Zero;
                    ShowFramePreviewAt(guidelineTimeOnTimeline, updateMainPlayhead: false);

                    break;
            }
            e.Handled = true;
        }
        private bool IsMouseOverElement(FrameworkElement element, MouseEventArgs e)
        {
            if (element == null) return false;
            var p = e.GetPosition(element);
            return p.X >= 0 && p.Y >= 0 && p.X <= element.ActualWidth && p.Y <= element.ActualHeight;
        }
        private async void MainWindow_PreviewMouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            if (_isMarqueeSelecting)
            {
                _isMarqueeSelecting = false;
                SelectionRectangle.Visibility = Visibility.Collapsed;
                if (TimelineParentGrid.IsMouseCaptured)
                {
                    TimelineParentGrid.ReleaseMouseCapture();
                }
                System.Windows.Point endPoint = e.GetPosition(TracksContainerGrid);
                Vector dragVector = _marqueeStartPoint - endPoint;
                if (dragVector.Length < SystemParameters.MinimumHorizontalDragDistance)
                {
                    if (_totalTimelineDuration.TotalSeconds > 0 && this._pixelsPerSecond > 0)
                    {
                        if (_isTimelinePlaying)
                        {
                            await PauseTimelinePlayback();
                        }
                        double absoluteClickX = _marqueeStartPoint.X;
                        TimeSpan clickedTime = TimeSpan.FromSeconds(absoluteClickX / this._pixelsPerSecond);
                        await SeekTimeline(clickedTime);
                    }
                }
                UpdateEditorPanelVisibility();
                e.Handled = true;
                return;
            }
        }
        private async void TimelineClip_Container_PreviewMouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            var container = sender as ContentPresenter;
            if (container == null) return;

            MoveSnapGuideline.Visibility = Visibility.Collapsed;

            if (_currentDragMode == DragMode.AdjustVolume)
            {
                if (container.IsMouseCaptured)
                {
                    container.ReleaseMouseCapture();
                }
                return;
            }

            bool wasActionTaken = false;

            if (_currentDragMode != DragMode.None && _selectedTimelineClip != null)
            {
                wasActionTaken = true;

                if (_currentDragMode == DragMode.MoveClip)
                {
                    if (this._pixelsPerSecond > 0)
                    {
                        foreach (var clip in _draggedClipGroup)
                        {
                            TimeSpan newStartTime = TimeSpan.FromSeconds(clip.X / this._pixelsPerSecond);
                            clip.StartTime = (newStartTime < TimeSpan.Zero) ? TimeSpan.Zero : newStartTime;

                            int targetTrackIndex = CalculateTrackIndexFromY(clip.Y);
                            clip.TrackIndex = EnforceTrackTypeRules(clip.ClipType, targetTrackIndex);
                        }
                        var ignoreSet = new HashSet<TimelineClipViewModel>(_draggedClipGroup);
                        foreach (var clip in _draggedClipGroup)
                        {
                            ResolveCollisionsForClip(clip, ignoreSet);
                        }

                        RecalculateTotalDuration();
                        UpdateTimelineScaleAndRender();
                    }
                }
                else if (_currentDragMode == DragMode.ResizeClip)
                {
                    if (_draggedResizeHandle?.Name == "LeftHandle")
                    {
                        if (_selectedTimelineClip.SourceData is MediaAsset mediaAssetSource)
                        {
                            var trimDelta = mediaAssetSource.TrimStartOffset - _resizeInitialTrimStartOffset;
                            var trimDeltaInTimeline = TimeSpan.FromSeconds(trimDelta.TotalSeconds / mediaAssetSource.Speed);
                            _selectedTimelineClip.StartTime = _resizeInitialStartTime + trimDeltaInTimeline;
                        }
                        else if (_selectedTimelineClip.SourceData is TimelineAudioClip audioClipSource)
                        {
                            var trimDelta = audioClipSource.TrimStartOffset - _resizeInitialTrimStartOffset;
                            _selectedTimelineClip.StartTime = _resizeInitialStartTime + TimeSpan.FromSeconds(trimDelta.TotalSeconds / audioClipSource.Speed);
                        }
                    }

                    if (_isModifyingVideoClip)
                    {
                        HandleVideoClipModification(_selectedTimelineClip, _preModificationEndTime);
                        _isModifyingVideoClip = false;
                    }

                    if (_selectedTimelineClip.IsVideo)
                    {
                        var eps = _clipEpsilon;
                        var startThreshold = _selectedTimelineClip.StartTime + eps;
                        var endThreshold = _selectedTimelineClip.EndTime - eps;
                        if (endThreshold < startThreshold)
                        {
                            startThreshold = _selectedTimelineClip.StartTime;
                            endThreshold = _selectedTimelineClip.EndTime;
                        }

                        bool inside = _playhead >= startThreshold && _playhead <= endThreshold;
                        if (!inside)
                        {
                            _playhead = (_playhead < startThreshold) ? startThreshold : endThreshold;
                            UpdatePlaybackUI(_playhead);
                            UpdateSubtitleForCurrentTime(_playhead);
                            await SeekTimeline(_playhead);
                        }
                    }
                }

                if (_currentDragMode != DragMode.AdjustVolume)
                {
                }

                if (_selectedTimelineClip.ClipType != TimelineClipType.Video && _selectedTimelineClip.ClipType != TimelineClipType.Image)
                {
                    RecalculateTotalDuration();
                    UpdateTimelineScaleAndRender();
                }

                _undoRedoService.AddState(CaptureEditorSnapshot());
                await SaveProjectCurrentAsync();
            }

            if (_currentDragMode == DragMode.ResizeClip)
                ResizeGuideline.Visibility = Visibility.Collapsed;

            _currentDragMode = DragMode.None;
            _draggedResizeHandle = null;
            _isPreparingToDragClip = false;

            if (wasActionTaken)
            {
                if (_wasPlayingBeforeDrag)
                {
                    await StartTimelinePlayback();
                }
            }
            else
            {
                _wasPlayingBeforeDrag = false;
            }

            if (container.IsMouseCaptured)
            {
                container.ReleaseMouseCapture();
            }
            Mouse.SetCursor(Cursors.Arrow);
            e.Handled = true;
            if (_isFramePreviewMode)
            {
                if (_currentDragMode == DragMode.ResizeClip && _selectedTimelineClip != null)
                {
                    _playhead = _playheadBeforeResize;
                    ShowFramePreviewAt(_playhead);
                }

                await ExitFramePreviewMode(restorePlayback: false);
            }
        }

        private void UpdateTimelineScaleAndRender()
        {
            if (TimelineScrollViewer.ViewportWidth <= 0 || _totalTimelineDuration.TotalSeconds <= 0)
                return;

            double finalTotalWidth = _totalTimelineDuration.TotalSeconds * this._pixelsPerSecond;
            TracksContainerGrid.Width = Math.Max(finalTotalWidth, TimelineScrollViewer.ViewportWidth);
            double maxOffset = Math.Max(0, TracksContainerGrid.Width - TimelineScrollViewer.ViewportWidth);
            if (TimelineScrollViewer.HorizontalOffset > maxOffset)
                TimelineScrollViewer.ScrollToHorizontalOffset(maxOffset);
            UpdateVisibleClips();  
            RenderVisibleClipsOnly();
            DrawRuler(this._pixelsPerSecond);
            UpdatePositionMarkerVisuals();
            TracksContainerGrid.InvalidateMeasure();
            TracksContainerGrid.UpdateLayout();
            _zoomRenderDebounce.Stop();
            _zoomRenderDebounce.Start();
        }
        #endregion
        private void Aux_DropDownOpened(object sender, EventArgs e) => EnterAuxUi();
        private void ColorPicker_Loaded(object sender, RoutedEventArgs e)
        {
            if (sender is not Control ctrl) return;
            ctrl.ApplyTemplate();
            Popup? popup = null;
            if (ctrl.Template != null)
            {
                popup = ctrl.Template.FindName("PART_Popup", ctrl) as Popup
                     ?? ctrl.Template.FindName("PART_DropDownPopup", ctrl) as Popup
                     ?? ctrl.Template.FindName("Popup", ctrl) as Popup;
            }

            if (popup != null)
            {
                popup.Opened -= ColorPicker_Popup_Opened;
                popup.Closed -= ColorPicker_Popup_Closed;
                popup.Opened += ColorPicker_Popup_Opened;
                popup.Closed += ColorPicker_Popup_Closed;
            }
            else
            {
            }
        }
        private bool IsInsidePopup(DependencyObject? d)
        {
            if (d == null) return false;
            var cur = d;
            while (cur != null)
            {
                if (cur is Popup) return true;
                cur = VisualTreeHelper.GetParent(cur);
            }
            if (d is Visual v)
            {
                var src = PresentationSource.FromVisual(v);
                var root = src?.RootVisual;
                if (root != null && root.GetType().Name.Contains("PopupRoot"))
                    return true;
            }
            return false;
        }
        private void ColorPicker_Popup_Opened(object? sender, EventArgs e) => EnterAuxUi();
        private void ColorPicker_Popup_Closed(object? sender, EventArgs e) => ExitAuxUi();
        private async Task<List<SmartCutMapItem>> BuildSmartCutMapItemsAsync()
        {
            var items = new List<SmartCutMapItem>();
            var allSubtitles = new List<SrtSubtitleLine>();
            if (_currentSmartCutMode == SmartCutMode.StaticReview)
            {
                var timelineSubtitleIndices = TimelineClips
                    .Where(c => (c.ClipType == TimelineClipType.Subtitle || c.ClipType == TimelineClipType.Text) && c.SourceData is SrtSubtitleLine)
                    .Select(c => ((SrtSubtitleLine)c.SourceData).Index)
                    .ToHashSet();

                if (_currentProject?.Subtitles != null)
                    allSubtitles.AddRange(_currentProject.Subtitles.Where(l => !l.IsTextClip && timelineSubtitleIndices.Contains(l.Index)));
                if (_currentProject?.TextClips != null)
                    allSubtitles.AddRange(_currentProject.TextClips.Where(l => timelineSubtitleIndices.Contains(l.Index)));
            }
            else
            {
                if (_currentProject?.Subtitles != null)
                    allSubtitles.AddRange(_currentProject.Subtitles.Where(l => !l.IsTextClip));
                if (_currentProject?.TextClips != null)
                    allSubtitles.AddRange(_currentProject.TextClips);
            }
            var voiceClips = new List<TimelineAudioClip>();
            if (_currentProject?.VoicedSubtitles != null)
                voiceClips.AddRange(_currentProject.VoicedSubtitles);
            if (!voiceClips.Any())
            {
                var jsonFallbackClips = await LoadVoicedLinesFromTtsManifestJsonAsync();
                if (jsonFallbackClips != null && jsonFallbackClips.Any())
                    voiceClips.AddRange(jsonFallbackClips);
            }
            var voicedSubtitles = allSubtitles.Where(l => l.IsVoiced).ToList();
            if (voicedSubtitles.Any())
            {
                foreach (var line in voicedSubtitles.OrderBy(l => l.Index))
                {
                    items.Add(new SmartCutMapItem
                    {
                        Line = line,
                        FinalStart = line.StartTime,
                        FinalEnd = line.EndTime
                    });
                }
                return items;
            }
            var matchedClips = new HashSet<TimelineAudioClip>();
            var matchedSubtitles = new Dictionary<int, SmartCutMapItem>();
            foreach (var clip in voiceClips)
            {
                if (clip.SourceSubtitleIndexSnapshot.HasValue)
                {
                    var idx = clip.SourceSubtitleIndexSnapshot.Value;
                    var subtitle = allSubtitles.FirstOrDefault(s => s.Index == idx);
                    if (subtitle != null && !matchedSubtitles.ContainsKey(idx))
                    {
                        var line = new SrtSubtitleLine
                        {
                            Index = subtitle.Index,
                            StartTime = subtitle.StartTime,
                            EndTime = subtitle.EndTime,
                            IsVoiced = true,
                            IsTextClip = subtitle.IsTextClip,
                            VoicedAudioPath = clip.FilePath,
                            OriginalText = subtitle.OriginalText ?? clip.CaptionTextSnapshot,
                            TranslatedText = subtitle.TranslatedText,
                            Style = subtitle.Style
                        };

                        matchedSubtitles[idx] = new SmartCutMapItem
                        {
                            Line = line,
                            FinalStart = clip.StartTime,
                            FinalEnd = clip.EndTime
                        };
                        matchedClips.Add(clip);
                    }
                }
            }
            static string Norm(string s) => string.IsNullOrWhiteSpace(s) ? "" :
                System.Text.RegularExpressions.Regex.Replace(s, @"\s+", " ").Trim();

            foreach (var clip in voiceClips)
            {
                if (matchedClips.Contains(clip)) continue;
                if (!string.IsNullOrWhiteSpace(clip.CaptionTextSnapshot))
                {
                    var normalizedSnapshot = Norm(clip.CaptionTextSnapshot);
                    var subtitle = allSubtitles.FirstOrDefault(s =>
                        !matchedSubtitles.ContainsKey(s.Index) &&
                        (string.Equals(Norm(s.OriginalText), normalizedSnapshot, StringComparison.OrdinalIgnoreCase) ||
                         Norm(s.OriginalText).Contains(normalizedSnapshot)));

                    if (subtitle != null)
                    {
                        var line = new SrtSubtitleLine
                        {
                            Index = subtitle.Index,
                            StartTime = subtitle.StartTime,
                            EndTime = subtitle.EndTime,
                            IsVoiced = true,
                            IsTextClip = subtitle.IsTextClip,
                            VoicedAudioPath = clip.FilePath,
                            OriginalText = subtitle.OriginalText,
                            TranslatedText = subtitle.TranslatedText,
                            Style = subtitle.Style
                        };

                        matchedSubtitles[subtitle.Index] = new SmartCutMapItem
                        {
                            Line = line,
                            FinalStart = clip.StartTime,
                            FinalEnd = clip.EndTime
                        };
                        matchedClips.Add(clip);
                        continue;
                    }
                }
                var clipStart = clip.StartTime;
                var clipEnd = clip.EndTime;
                var clipDuration = (clipEnd - clipStart).TotalSeconds;

                foreach (var subtitle in allSubtitles)
                {
                    if (matchedSubtitles.ContainsKey(subtitle.Index)) continue;
                    var subStart = subtitle.StartTime;
                    var subEnd = subtitle.EndTime;
                    var subDuration = (subEnd - subStart).TotalSeconds;
                    var overlapStart = clipStart > subStart ? clipStart : subStart;
                    var overlapEnd = clipEnd < subEnd ? clipEnd : subEnd;
                    var overlapDuration = (overlapEnd - overlapStart).TotalSeconds;
                    if (overlapDuration > 0 &&
                        (overlapDuration / clipDuration > 0.5 || overlapDuration / subDuration > 0.5))
                    {
                        var line = new SrtSubtitleLine
                        {
                            Index = subtitle.Index,
                            StartTime = subtitle.StartTime,
                            EndTime = subtitle.EndTime,
                            IsVoiced = true,
                            IsTextClip = subtitle.IsTextClip,
                            VoicedAudioPath = clip.FilePath,
                            OriginalText = subtitle.OriginalText ?? clip.CaptionTextSnapshot,
                            TranslatedText = subtitle.TranslatedText,
                            Style = subtitle.Style
                        };

                        matchedSubtitles[subtitle.Index] = new SmartCutMapItem
                        {
                            Line = line,
                            FinalStart = clip.StartTime,
                            FinalEnd = clip.EndTime
                        };
                        matchedClips.Add(clip);
                        break; 
                    }
                }
            }

            // Xử lý voice clips không match với subtitle:
            // - Non-StaticReview mode: luôn xử lý voice clips không match
            // - StaticReview mode: chỉ xử lý khi không có subtitle trên timeline nhưng có voice clips
            //   (cho phép xuất video không có phụ đề nhưng vẫn giữ logic giãn voice, overlay, nhạc nền)
            bool shouldProcessUnmatchedVoiceClips = _currentSmartCutMode != SmartCutMode.StaticReview 
                || (allSubtitles.Count == 0 && voiceClips.Any());
            
            if (shouldProcessUnmatchedVoiceClips)
            {
                foreach (var clip in voiceClips)
                {
                    if (matchedClips.Contains(clip)) continue;

                    if (clip.SourceSubtitleIndexSnapshot.HasValue || !string.IsNullOrWhiteSpace(clip.CaptionTextSnapshot))
                    {
                        int idx = clip.SourceSubtitleIndexSnapshot ?? (items.Count + matchedSubtitles.Count + 1);
                        var line = new SrtSubtitleLine
                        {
                            Index = idx,
                            StartTime = clip.StartTime,
                            EndTime = clip.EndTime,
                            IsVoiced = true,
                            VoicedAudioPath = clip.FilePath,
                            OriginalText = clip.CaptionTextSnapshot ?? $"[Voice {idx}]"
                        };

                        items.Add(new SmartCutMapItem
                        {
                            Line = line,
                            FinalStart = clip.StartTime,
                            FinalEnd = clip.EndTime
                        });
                    }
                }
            }
            items.AddRange(matchedSubtitles.OrderBy(kv => kv.Key).Select(kv => kv.Value));
            return items.OrderBy(i => i.Line.Index).ToList();
        }
        private async Task<(List<subphimv1.Subphim.SrtSubtitleLine> voicedLines, List<TimelineAudioClip> timingSegments)>
            ResolveSmartCutSourcesAsync()
        {
            var mapItems = await BuildSmartCutMapItemsAsync();


            var voicedLines = mapItems.Select(m => m.Line).OrderBy(l => l.StartTime).ToList();
            var timingSegments = new List<TimelineAudioClip>();
            foreach (var l in voicedLines)
            {
                if (string.IsNullOrWhiteSpace(l.VoicedAudioPath) || !File.Exists(l.VoicedAudioPath))
                    continue;

                var info = await FFProbe.AnalyseAsync(l.VoicedAudioPath);
                var dur = info?.Duration ?? TimeSpan.Zero;
                if (dur <= TimeSpan.Zero) continue;

                var clip = new TimelineAudioClip
                {
                    FilePath = l.VoicedAudioPath,
                    StartTime = l.StartTime,
                    OriginalDuration = dur,
                    TrimStartOffset = TimeSpan.Zero,
                    TrimEndOffset = TimeSpan.Zero,
                    SourceSubtitleIndexSnapshot = l.Index,
                    CaptionTextSnapshot = l.OriginalText,
                    IsTts = true
                };
                timingSegments.Add(clip);
            }

            return (voicedLines, timingSegments);
        }

        private async Task<List<TimelineAudioClip>> LoadVoicedLinesFromTtsManifestJsonAsync(string specificFolder = null)
        {
            var result = new List<TimelineAudioClip>();
            try
            {
                string manifestPath = null;

                if (!string.IsNullOrWhiteSpace(specificFolder) && Directory.Exists(specificFolder))
                {
                    manifestPath = Path.Combine(specificFolder, "smartcut_manifest.json");
                }
                else
                {
                    string ttsFolder = GetLatestTtsBatchFolderForProject(_currentProject?.ProjectName);
                    if (!string.IsNullOrWhiteSpace(ttsFolder))
                    {
                        manifestPath = Path.Combine(ttsFolder, "smartcut_manifest.json");
                        if (!File.Exists(manifestPath))
                        {
                            var allBatchDirs = Directory.GetDirectories(
                                Path.GetDirectoryName(ttsFolder),
                                "*",
                                SearchOption.TopDirectoryOnly);

                            foreach (var dir in allBatchDirs.OrderByDescending(d => Directory.GetLastWriteTimeUtc(d)))
                            {
                                var candidate = Path.Combine(dir, "smartcut_manifest.json");
                                if (File.Exists(candidate))
                                {
                                    manifestPath = candidate;
                                    break;
                                }
                            }
                        }
                    }
                }

                if (string.IsNullOrEmpty(manifestPath) || !File.Exists(manifestPath))
                {
                    return null;
                }

                var json = await File.ReadAllTextAsync(manifestPath, Encoding.UTF8);
                var manifest = JsonConvert.DeserializeObject<subphimv1.Subphim.TtsSmartCutManifest>(json);
                if (manifest?.Entries == null || manifest.Entries.Count == 0)
                {
                    return result;
                }

                var ordered = manifest.Entries.OrderBy(e => e.Index).ThenBy(e => e.StartMs).ToList();

                foreach (var entry in ordered)
                {
                    if (string.IsNullOrWhiteSpace(entry.AudioPath) || !File.Exists(entry.AudioPath))
                    {
                        continue;
                    }
                    try
                    {
                        var mediaInfo = await FFProbe.AnalyseAsync(entry.AudioPath);
                        var duration = mediaInfo.Duration;
                        if (duration <= TimeSpan.Zero) continue;

                        var clip = new TimelineAudioClip
                        {
                            FilePath = entry.AudioPath,
                            StartTime = TimeSpan.FromMilliseconds(entry.StartMs),
                            OriginalDuration = duration,
                            SourceSubtitleIndexSnapshot = entry.Index,
                            IsTts = true
                        };
                        result.Add(clip);
                    }
                    catch (Exception ex)
                    {
                    }
                }
            }
            catch (Exception ex)
            {
                return null;
            }
            return result;
        }
        #region CapCut Draft Models
        private class CapCutDraft
        {
            [JsonProperty("materials")]
            public CapCutMaterials Materials { get; set; }
        }

        private class CapCutMaterials
        {
            [JsonProperty("audios")]
            public List<CapCutAudio> Audios { get; set; }

            [JsonProperty("texts")]
            public List<CapCutText> Texts { get; set; }
        }

        private class CapCutAudio
        {
            [JsonProperty("path")]
            public string Path { get; set; }

            [JsonProperty("text_id")]
            public string TextId { get; set; }
        }

        private class CapCutText
        {
            [JsonProperty("id")]
            public string Id { get; set; }
            [JsonProperty("content")]
            public string Content { get; set; }
        }
        private class CapCutTextContent
        {
            [JsonProperty("text")]
            public string Text { get; set; }
        }
        #endregion
        private async void ImportVoicedSubtitleButton_Click(object sender, RoutedEventArgs e)
        {
            if (!_currentProject.Subtitles.Any(l => !l.IsTextClip))
            {
                CustomMessageBox.Show("Vui lòng tải một file phụ đề (.srt) vào timeline hoặc tạo phụ đề tự động trước khi import voice.", "Chưa có phụ đề", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            try
            {
                var dialog = new Ookii.Dialogs.Wpf.VistaFolderBrowserDialog
                {
                    Description = "Chọn thư mục chứa audio giọng đọc (hoặc project CapCut)",
                    UseDescriptionForTitle = true
                };

                if (dialog.ShowDialog(this).GetValueOrDefault())
                {
                    string selectedFolder = dialog.SelectedPath;
                    if (string.IsNullOrWhiteSpace(selectedFolder) || !Directory.Exists(selectedFolder))
                    {
                        CustomMessageBox.Show("Thư mục không hợp lệ.", "Import giọng đọc", MessageBoxButton.OK, MessageBoxImage.Warning);
                        return;
                    }
                    LoadingOverlay.Visibility = Visibility.Visible;
                    List<TimelineAudioClip> manifestClips = null;
                    try
                    {
                        manifestClips = await LoadVoicedLinesFromTtsManifestJsonAsync(selectedFolder);
                    }
                    catch
                    {
                        manifestClips = null;
                    }

                    if (manifestClips != null && manifestClips.Count > 0)
                    {
                        var ttsVmsToRemove = TimelineClips
                            .Where(vm => vm.SourceData is TimelineAudioClip t && t.IsTts)
                            .ToList();
                        foreach (var vm in ttsVmsToRemove)
                        {
                            TimelineClips.Remove(vm);
                        }
                        _currentProject.VoicedSubtitles.RemoveAll(c => c != null && c.IsTts);
                        var newClipViewModels = new List<TimelineClipViewModel>();
                        foreach (var clip in manifestClips)
                        {
                            if (clip == null || string.IsNullOrWhiteSpace(clip.FilePath) || !File.Exists(clip.FilePath)) continue;

                            clip.IsTts = true;
                            _currentProject.VoicedSubtitles.Add(clip);

                            var newVM = new TimelineClipViewModel(clip);
                            TimelineClips.Add(newVM);
                            newClipViewModels.Add(newVM);
                            QueueWaveformGeneration(clip);
                        }
                        if (newClipViewModels.Any())
                        {
                            AssignAudioClipsToIntelligentTracks(newClipViewModels);
                        }
                        RecalculateTotalDuration();
                        UpdateTimelineScaleAndRender();
                        _undoRedoService.AddState(CaptureEditorSnapshot());
                        await SaveProjectCurrentAsync();

                        LoadingOverlay.Visibility = Visibility.Collapsed;
                        return;
                    }
                    string capcutDraftJson = Path.Combine(selectedFolder, "draft_content.json");
                    if (File.Exists(capcutDraftJson))
                    {
                        await HandleCapCutProjectImport(selectedFolder, capcutDraftJson);
                    }
                    else
                    {
                        await HandleGenericAudioFolderImport(selectedFolder);
                    }
                }
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Import giọng đọc thất bại.\nLỗi: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                LoadingOverlay.Visibility = Visibility.Collapsed;
            }
        }

        private async Task HandleCapCutProjectImport(string projectPath, string draftPath)
        {
            LoadingOverlay.Visibility = Visibility.Visible;
            try
            {
                string jsonContent = await File.ReadAllTextAsync(draftPath, Encoding.UTF8);
                var draft = JsonConvert.DeserializeObject<CapCutDraft>(jsonContent);

                if (draft?.Materials?.Audios == null || draft.Materials.Texts == null)
                {
                    throw new Exception("File draft_content.json không hợp lệ hoặc thiếu thông tin 'materials'.");
                }
                var idToTextMap = new Dictionary<string, string>();
                foreach (var textItem in draft.Materials.Texts)
                {
                    if (string.IsNullOrEmpty(textItem.Id) || string.IsNullOrEmpty(textItem.Content)) continue;
                    try
                    {
                        var textContent = JsonConvert.DeserializeObject<CapCutTextContent>(textItem.Content);
                        if (textContent != null && !string.IsNullOrWhiteSpace(textContent.Text))
                        {
                            idToTextMap[textItem.Id] = textContent.Text.Trim();
                        }
                    }
                    catch { /* Bỏ qua nếu content không phải JSON hợp lệ */ }
                }
                var textToAudioPathMap = new Dictionary<string, string>();
                foreach (var audioItem in draft.Materials.Audios)
                {
                    if (string.IsNullOrEmpty(audioItem.TextId) || string.IsNullOrEmpty(audioItem.Path)) continue;

                    if (idToTextMap.TryGetValue(audioItem.TextId, out string text))
                    {
                        string wavName = Path.GetFileName(audioItem.Path);
                        if (!string.IsNullOrEmpty(wavName))
                        {
                            string fullWavPath = Path.Combine(projectPath, "textReading", wavName);
                            textToAudioPathMap[text] = fullWavPath;
                        }
                    }
                }

                if (textToAudioPathMap.Count == 0)
                {
                    CustomMessageBox.Show("Không tìm thấy thông tin voice TTS nào trong dự án CapCut.", "Không có dữ liệu", MessageBoxButton.OK, MessageBoxImage.Information);
                    return;
                }
                var allSrtLines = _currentProject.Subtitles.Where(l => !l.IsTextClip).ToList();
                var audioPathByIndex = new Dictionary<int, string>();
                var newClipViewModels = new List<TimelineClipViewModel>();
                int importedCount = 0;

                foreach (var line in allSrtLines)
                {
                    if (line.IsVoiced) continue;

                    string searchText = line.OriginalText.Trim();
                    if (textToAudioPathMap.TryGetValue(searchText, out string audioPath) && File.Exists(audioPath))
                    {
                        try
                        {
                            var mediaInfo = await FFProbe.AnalyseAsync(audioPath);
                            if (mediaInfo.PrimaryAudioStream == null && mediaInfo.Duration == TimeSpan.Zero) continue;

                            line.IsVoiced = true;
                            line.VoicedAudioPath = audioPath;

                            var newAudioClip = new TimelineAudioClip
                            {
                                FilePath = audioPath,
                                StartTime = line.StartTime,
                                OriginalDuration = mediaInfo.Duration,
                                TrimStartOffset = TimeSpan.Zero,
                                TrimEndOffset = TimeSpan.Zero,
                                SourceSubtitleIndexSnapshot = line.Index,
                                CaptionTextSnapshot = line.OriginalText
                            };

                            _currentProject.VoicedSubtitles.Add(newAudioClip);
                            TimelineAudioClips.Add(newAudioClip);
                            QueueWaveformGeneration(newAudioClip);
                            var newClipVM = new TimelineClipViewModel(newAudioClip);
                            TimelineClips.Add(newClipVM);
                            newClipViewModels.Add(newClipVM);
                            audioPathByIndex[line.Index] = audioPath;
                            importedCount++;
                        }
                        catch (Exception ex)
                        {
                            LogMessage($"Lỗi khi xử lý file audio '{audioPath}': {ex.Message}", true);
                        }
                    }
                }
                await WriteTtsSmartCutManifestAsync(Path.Combine(projectPath, "textReading"), allSrtLines, audioPathByIndex, _currentSrtFilePath);
                if (importedCount > 0)
                {
                    AssignAudioClipsToIntelligentTracks(newClipViewModels);
                    RecalculateTotalDuration();
                    UpdateTimelineScaleAndRender();
                    _undoRedoService.AddState(CaptureEditorSnapshot());
                    await SaveProjectCurrentAsync();
                }
                else
                {
                    CustomMessageBox.Show("Không tìm thấy voice nào khớp với nội dung các dòng phụ đề hiện tại.", "Không khớp", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Lỗi khi import từ dự án CapCut: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                LoadingOverlay.Visibility = Visibility.Collapsed;
            }
        }
        private async Task HandleGenericAudioFolderImport(string selectedFolder)
        {
            LoadingOverlay.Visibility = Visibility.Visible;
            try
            {
                var audioFiles = Directory.GetFiles(selectedFolder, "*.*", SearchOption.TopDirectoryOnly)
                    .Where(f => f.EndsWith(".mp3", StringComparison.OrdinalIgnoreCase)
                             || f.EndsWith(".wav", StringComparison.OrdinalIgnoreCase)
                             || f.EndsWith(".m4a", StringComparison.OrdinalIgnoreCase)
                             || f.EndsWith(".ogg", StringComparison.OrdinalIgnoreCase)
                             || f.EndsWith(".flac", StringComparison.OrdinalIgnoreCase))
                    .OrderBy(f => f, new NaturalStringComparer())
                    .ToList();

                if (!audioFiles.Any())
                {
                    CustomMessageBox.Show("Không tìm thấy file âm thanh nào trong thư mục đã chọn.", "Không có file", MessageBoxButton.OK, MessageBoxImage.Information);
                    return;
                }
                var allSrtLines = _currentProject.Subtitles.Where(l => !l.IsTextClip).ToList();
                var srtLinesByIndex = allSrtLines.ToDictionary(line => line.Index, line => line);
                var audioPathByIndex = new Dictionary<int, string>();
                int importedCount = 0;
                var newClipViewModels = new List<TimelineClipViewModel>();
                const double timeToleranceMs = 300.0;

                foreach (var audioPath in audioFiles)
                {
                    string fileName = Path.GetFileNameWithoutExtension(audioPath);
                    var parts = fileName.Split('_');
                    SrtSubtitleLine targetLine = null;
                    if (parts.Length > 0 && int.TryParse(parts[0], System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out int indexFromFile))
                    {
                        srtLinesByIndex.TryGetValue(indexFromFile, out targetLine);
                    }
                    if (targetLine == null && parts.Length >= 3)
                    {
                        if (long.TryParse(parts[parts.Length - 2], System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out long startMs) &&
                            long.TryParse(parts[parts.Length - 1], System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out long endMs))
                        {
                            var startFromFile = TimeSpan.FromMilliseconds(startMs);
                            targetLine = allSrtLines.FirstOrDefault(l =>
                                !l.IsVoiced &&
                                Math.Abs((l.StartTime - startFromFile).TotalMilliseconds) <= timeToleranceMs);
                        }
                    }
                    if (targetLine == null)
                    {
                        targetLine = allSrtLines.Where(l => !l.IsVoiced).OrderBy(l => l.StartTime).FirstOrDefault();
                    }

                    if (targetLine != null && !targetLine.IsVoiced)
                    {
                        try
                        {
                            var mediaInfo = await FFProbe.AnalyseAsync(audioPath);
                            if (mediaInfo.PrimaryAudioStream == null && mediaInfo.Duration == TimeSpan.Zero) continue;

                            targetLine.IsVoiced = true;
                            targetLine.VoicedAudioPath = audioPath;

                            var newAudioClip = new TimelineAudioClip
                            {
                                FilePath = audioPath,
                                StartTime = targetLine.StartTime,
                                OriginalDuration = mediaInfo.Duration,
                                TrimStartOffset = TimeSpan.Zero,
                                TrimEndOffset = TimeSpan.Zero,
                                SourceSubtitleIndexSnapshot = targetLine.Index,
                                CaptionTextSnapshot = targetLine.OriginalText
                            };
                            _currentProject.VoicedSubtitles.Add(newAudioClip);
                            TimelineAudioClips.Add(newAudioClip);
                            QueueWaveformGeneration(newAudioClip);
                            var newClipVM = new TimelineClipViewModel(newAudioClip);
                            TimelineClips.Add(newClipVM);
                            newClipViewModels.Add(newClipVM);
                            audioPathByIndex[targetLine.Index] = audioPath;
                            importedCount++;
                        }
                        catch (Exception ex)
                        {
                            LogMessage($"Lỗi khi xử lý file audio '{audioPath}': {ex.Message}", true);
                        }
                    }
                }

                await WriteTtsSmartCutManifestAsync(selectedFolder, allSrtLines, audioPathByIndex, _currentSrtFilePath);

                if (importedCount > 0)
                {
                    AssignAudioClipsToIntelligentTracks(newClipViewModels);
                    RecalculateTotalDuration();
                    UpdateTimelineScaleAndRender();
                    _undoRedoService.AddState(CaptureEditorSnapshot());
                    await SaveProjectCurrentAsync();
                }
                else
                {
                    CustomMessageBox.Show("Không có file âm thanh nào trong thư mục khớp được với các dòng phụ đề.", "Không khớp", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Lỗi khi import từ thư mục: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                LoadingOverlay.Visibility = Visibility.Collapsed;
            }
        }
        private void AssignAudioClipsToIntelligentTracks(List<TimelineClipViewModel> newAudioClips)
        {
            var existingNonAudioClips = TimelineClips
                .Except(newAudioClips)
                .Where(c => c.ClipType != TimelineClipType.Audio);

            int audioTrackOffset = TrackLayoutManager.AUDIO_TRACK_START;
            if (existingNonAudioClips.Any())
            {
                audioTrackOffset = Math.Max(
                    audioTrackOffset,
                    existingNonAudioClips.Max(c => c.TrackIndex) + 1);
            }
            var trackEndTimes = new Dictionary<int, TimeSpan>();
            var existingAudioClips = TimelineClips.Except(newAudioClips).Where(c => c.ClipType == TimelineClipType.Audio);
            foreach (var clip in existingAudioClips)
            {
                if (!trackEndTimes.ContainsKey(clip.TrackIndex) || clip.EndTime > trackEndTimes[clip.TrackIndex])
                {
                    trackEndTimes[clip.TrackIndex] = clip.EndTime;
                }
            }
            var sortedNewClips = newAudioClips.OrderBy(c => c.StartTime).ToList();
            var tolerance = TimeSpan.FromMilliseconds(10);
            foreach (var newClip in sortedNewClips)
            {
                bool placed = false;
                int potentialTrackIndex = audioTrackOffset;

                while (!placed)
                {
                    if (!trackEndTimes.ContainsKey(potentialTrackIndex))
                    {
                        trackEndTimes[potentialTrackIndex] = TimeSpan.Zero;
                    }

                    if (newClip.StartTime >= trackEndTimes[potentialTrackIndex] - tolerance)
                    {
                        newClip.TrackIndex = potentialTrackIndex;
                        trackEndTimes[potentialTrackIndex] = newClip.EndTime;
                        placed = true;
                    }
                    else
                    {
                        potentialTrackIndex++;
                    }
                }
            }
        }
        private void InitializeStylePresets()
        {
            _stylePresets = new List<StyleState>
    {
        new StyleState { EdgeStyle = TextEdgeStyle.None, IsBackgroundEnabled = false },
        new StyleState { FontColorHex = "#FFFFFFFF", EdgeStyle = TextEdgeStyle.Outline, OutlineColorHex = "#FF000000", OutlineThickness = 2.5 },
         new StyleState { FontColorHex = "#FFFFEB3B", EdgeStyle = TextEdgeStyle.Outline, OutlineColorHex = "#FF000000", OutlineThickness = 2.5 },
        new StyleState { FontColorHex = "#FFFFFFFF", EdgeStyle = TextEdgeStyle.Shadow, ShadowColorHex = "#B3000000", ShadowBlur = 5, ShadowDepth = 3, ShadowDirection = 315 },
        new StyleState { FontColorHex = "#FFFFEB3B", EdgeStyle = TextEdgeStyle.None, IsBackgroundEnabled = true, BackgroundColorHex = "#FF000000", BackgroundPaddingX = 10, BackgroundPaddingY = 5, BackgroundCornerRadius = 4 },
        new StyleState { FontColorHex = "#FFFF5252", EdgeStyle = TextEdgeStyle.Outline, OutlineColorHex = "#FFFFFFFF", OutlineThickness = 2.5 },
        new StyleState { FontColorHex = "#FFFFFFFF", EdgeStyle = TextEdgeStyle.Outline, OutlineColorHex = "#FFFF5252", OutlineThickness = 2.5 },
        new StyleState { FontColorHex = "#FF448AFF", EdgeStyle = TextEdgeStyle.Outline, OutlineColorHex = "#FFFFFFFF", OutlineThickness = 2.5 },
        new StyleState { FontColorHex = "#FF69F0AE", EdgeStyle = TextEdgeStyle.Outline, OutlineColorHex = "#FF000000", OutlineThickness = 2.5 },
        new StyleState { IsBackgroundEnabled = true, BackgroundColorHex = "#FFCCCCCC", FontColorHex = "#FF000000", BackgroundPaddingX = 10, BackgroundPaddingY = 5, BackgroundCornerRadius = 4 },
        new StyleState { IsBackgroundEnabled = true, BackgroundColorHex = "#FFFFEB3B", FontColorHex = "#FF000000", BackgroundPaddingX = 10, BackgroundPaddingY = 5, BackgroundCornerRadius = 4 },
        new StyleState { IsBackgroundEnabled = true, BackgroundColorHex = "#FF7C4DFF", FontColorHex = "#FFFFFFFF", BackgroundPaddingX = 10, BackgroundPaddingY = 5, BackgroundCornerRadius = 4 },
        new StyleState { IsBackgroundEnabled = true, BackgroundColorHex = "#FFFFFFFF", FontColorHex = "#FF000000", BackgroundPaddingX = 10, BackgroundPaddingY = 5, BackgroundCornerRadius = 4 },
        new StyleState { IsBackgroundEnabled = true, BackgroundColorHex = "#FF000000", FontColorHex = "#FFFFFFFF", BackgroundPaddingX = 10, BackgroundPaddingY = 5, BackgroundCornerRadius = 4 },
        new StyleState { FontColorHex = "#FF00E676", IsBackgroundEnabled = true, BackgroundColorHex = "#FF000000", EdgeStyle = TextEdgeStyle.None, BackgroundPaddingX = 10, BackgroundPaddingY = 5, BackgroundCornerRadius = 4},
        new StyleState { FontColorHex = "#FFFFFFFF", EdgeStyle = TextEdgeStyle.Shadow, ShadowColorHex = "#B3FF1744", ShadowBlur = 8, ShadowDepth = 0 },
        new StyleState { FontColorHex = "#FFFFFFFF", EdgeStyle = TextEdgeStyle.Shadow, ShadowColorHex = "#B3FFD600", ShadowBlur = 8, ShadowDepth = 0 },
        new StyleState { FontColorHex = "#FFFFFFFF", EdgeStyle = TextEdgeStyle.Shadow, ShadowColorHex = "#B376FF03", ShadowBlur = 8, ShadowDepth = 0 },
    };

            PresetItemsControl.ItemsSource = _stylePresets;
        }

        private void ApplyStylePreset(StyleState preset)
        {
            if (preset == null) return;

            _isUpdatingUiFromCode = true;

            try
            {
                FontColorPicker.SelectedColor = (Color?)ColorConverter.ConvertFromString(preset.FontColorHex);
                BackgroundEnabledCheckBox.IsChecked = preset.IsBackgroundEnabled;
                OutlineEnabledCheckBox.IsChecked = !preset.IsBackgroundEnabled && preset.EdgeStyle == TextEdgeStyle.Outline;
                ShadowEnabledCheckBox.IsChecked = !preset.IsBackgroundEnabled && preset.EdgeStyle == TextEdgeStyle.Shadow;

                if (preset.IsBackgroundEnabled)
                {
                    var bgColor = (Color)ColorConverter.ConvertFromString(preset.BackgroundColorHex);
                    BackgroundColorPicker.SelectedColor = Color.FromRgb(bgColor.R, bgColor.G, bgColor.B);
                    if (ColorConverter.ConvertFromString(preset.BackgroundColorHex) is Color c)
                    {
                        BackgroundOpacitySlider.Value = c.A * 100.0 / 255.0;
                    }

                    BackgroundCornerRadiusSlider.Value = preset.BackgroundCornerRadius;
                    BackgroundPaddingXSlider.Value = preset.BackgroundPaddingX;
                    BackgroundPaddingYSlider.Value = preset.BackgroundPaddingY;
                }
                if (OutlineEnabledCheckBox.IsChecked == true)
                {
                    OutlineColorPicker.SelectedColor = (Color?)ColorConverter.ConvertFromString(preset.OutlineColorHex);
                    OutlineThicknessSlider.Value = preset.OutlineThickness;
                }
                if (ShadowEnabledCheckBox.IsChecked == true)
                {
                    var shadowColor = (Color)ColorConverter.ConvertFromString(preset.ShadowColorHex);
                    ShadowColorPicker.SelectedColor = Color.FromRgb(shadowColor.R, shadowColor.G, shadowColor.B);
                    ShadowOpacitySlider.Value = shadowColor.A * 100.0 / 255.0;
                    ShadowBlurSlider.Value = preset.ShadowBlur;
                    ShadowDepthSlider.Value = preset.ShadowDepth;
                    ShadowDirectionSlider.Value = preset.ShadowDirection;
                }
            }
            finally
            {
                _isUpdatingUiFromCode = false;
            }
            EditorControl_ValueChanged(null, null);
        }
        private TimelineClipViewModel _draggedVolumeClip = null;

        private void VolumeThumb_DragStarted(object sender, DragStartedEventArgs e)
        {
            if (sender is Thumb thumb && thumb.DataContext is TimelineClipViewModel vm)
            {
                _draggedVolumeClip = vm;
                _currentDragMode = DragMode.AdjustVolume;
                if (!vm.IsSelected)
                {
                    foreach (var clip in TimelineClips.Where(c => c.IsSelected))
                    {
                        clip.IsSelected = false;
                    }
                    vm.IsSelected = true;
                    _selectedTimelineClip = vm;
                    UpdateEditorPanelVisibility();
                }
            }
            e.Handled = true;
        }

        private void VolumeThumb_DragDelta(object sender, DragDeltaEventArgs e)
        {
            if (_draggedVolumeClip == null || !(sender is Thumb thumb)) return;
            var container = MainTimelineControl.ItemContainerGenerator.ContainerFromItem(_draggedVolumeClip) as ContentPresenter;
            var canvas = FindVisualChild<Canvas>(container, "AudioCanvas");
            if (canvas == null || canvas.ActualHeight <= 0) return;
            double currentTop = Canvas.GetTop(thumb);
            double newTop = Math.Clamp(currentTop + e.VerticalChange, 0, canvas.ActualHeight);
            double ratio = (canvas.ActualHeight - newTop) / canvas.ActualHeight;
            var newDb = MIN_DB + (ratio * (MAX_DB - MIN_DB));
            _draggedVolumeClip.VolumeDb = newDb;
            UpdateVolumeForPlayingClip(_draggedVolumeClip, newDb);
        }

        private async void VolumeThumb_DragCompleted(object sender, DragCompletedEventArgs e)
        {
            if (_draggedVolumeClip != null)
            {
                _undoRedoService.AddState(CaptureEditorSnapshot());
                _draggedVolumeClip = null;
            }
            _currentDragMode = DragMode.None;
            e.Handled = true;
        }
        private void PresetButton_Click(object sender, RoutedEventArgs e)
        {
            if (sender is Button button && button.DataContext is StyleState preset)
            {
                ApplyStylePreset(preset);
            }
        }
        private void RewindTimeButton_Click(object sender, RoutedEventArgs e)
        {
            if (!int.TryParse(CustomTimeAdjustTextBox.Text, out int msValue) || msValue <= 0)
            {
                CustomMessageBox.Show("Vui lòng nhập một số dương hợp lệ cho mili giây.", "Giá trị không hợp lệ", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            AdjustSubtitleTimings(TimeSpan.FromMilliseconds(-msValue), TimeSpan.Zero);
        }

        private void AdvanceTimeButton_Click(object sender, RoutedEventArgs e)
        {
            if (!int.TryParse(CustomTimeAdjustTextBox.Text, out int msValue) || msValue <= 0)
            {
                CustomMessageBox.Show("Vui lòng nhập một số dương hợp lệ cho mili giây.", "Giá trị không hợp lệ", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            AdjustSubtitleTimings(TimeSpan.Zero, TimeSpan.FromMilliseconds(msValue));
        }

        private void AdjustSubtitleTimings(TimeSpan startTimeOffset, TimeSpan durationOffset)
        {
            var subtitlesToAdjust = _currentProject.Subtitles
                                      .Where(s => !s.IsTextClip)
                                      .OrderBy(s => s.StartTime)
                                      .ToList();


            if (!subtitlesToAdjust.Any())
            {
                CustomMessageBox.Show("Không có phụ đề nào trong dự án để hiệu chỉnh.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            int adjustedCount = 0;
            for (int i = 0; i < subtitlesToAdjust.Count; i++)
            {
                var currentLine = subtitlesToAdjust[i];
                if (startTimeOffset.TotalMilliseconds < 0)
                {
                    var newStartTime = currentLine.StartTime + startTimeOffset;
                    if (i > 0)
                    {
                        var prevLine = subtitlesToAdjust[i - 1];
                        if (newStartTime <= prevLine.EndTime)
                        {
                            continue;
                        }
                    }
                    currentLine.StartTime = (newStartTime < TimeSpan.Zero) ? TimeSpan.Zero : newStartTime;
                    adjustedCount++;
                }
                if (durationOffset.TotalMilliseconds > 0)
                {
                    var newEndTime = currentLine.EndTime + durationOffset;
                    if (i + 1 < subtitlesToAdjust.Count)
                    {
                        var nextLine = subtitlesToAdjust[i + 1];
                        if (newEndTime >= nextLine.StartTime)
                        {
                            continue;
                        }
                    }
                    var newDuration = currentLine.Duration + durationOffset;
                    currentLine.Duration = (newDuration < TimeSpan.Zero) ? TimeSpan.Zero : newDuration;
                    adjustedCount++;
                }
            }
            RecalculateTotalDuration();
            UpdateTimelineScaleAndRender();
            _undoRedoService.AddState(CaptureEditorSnapshot());
            SaveProjectCurrent();
            string action = startTimeOffset != TimeSpan.Zero ? "lùi thời gian bắt đầu" : "tăng thời gian kết thúc";
            CustomMessageBox.Show($"Đã {action} thành công cho {adjustedCount} / {subtitlesToAdjust.Count} dòng phụ đề.", "Hoàn tất", MessageBoxButton.OK, MessageBoxImage.Information);
        }
        private double DetectMainVideoSlowFactorOrDefault(double defaultValue)
        {
            double? pick()
            {
                if (_activeVideoClip?.SourceData is MediaAsset act) return act.Speed;
                var firstVideo = TimelineClips.FirstOrDefault(c => c.ClipType == TimelineClipType.Video);
                if (firstVideo?.SourceData is MediaAsset mv) return mv.Speed;
                return null;
            }

            var v = pick();
            if (!v.HasValue || v.Value <= 0) return defaultValue;
            return v.Value;
        }
        private void ApplySmartCutScaleToSubtitlesAndVoices(double slowedFactor)
        {
            if (slowedFactor <= 0) slowedFactor = 0.6;
            double scale = 1.0 / slowedFactor;

            foreach (var line in SrtSubtitleLinesView.ToList())
            {
                var newStart = TimeSpan.FromMilliseconds(Math.Round(line.StartTime.TotalMilliseconds * scale));
                var newDur = TimeSpan.FromMilliseconds(Math.Round(line.Duration.TotalMilliseconds * scale));
                line.StartTime = newStart;
                line.Duration = newDur;
            }
            if (_currentProject?.VoicedSubtitles != null)
            {
                foreach (var ac in _currentProject.VoicedSubtitles)
                {
                    var newStart = TimeSpan.FromMilliseconds(Math.Round(ac.StartTime.TotalMilliseconds * scale));
                    ac.StartTime = newStart;
                }
            }
            foreach (var vm in TimelineClips)
            {
                if (vm.SourceData is SrtSubtitleLine s)
                {
                    vm.RefreshPropertiesFromSource();
                    vm.X = s.StartTime.TotalSeconds * _pixelsPerSecond;
                    vm.Width = Math.Max(1.0, s.Duration.TotalSeconds * _pixelsPerSecond);
                }
                else if (vm.SourceData is TimelineAudioClip tac)
                {
                    vm.RefreshPropertiesFromSource();
                    vm.X = tac.StartTime.TotalSeconds * _pixelsPerSecond;
                    vm.Width = Math.Max(1.0, tac.EffectiveDuration.TotalSeconds * _pixelsPerSecond);
                }
            }
        }

        private async void SmartCutButton_Click(object sender, RoutedEventArgs e)
        {
            var (hasAccess, message) = await ApiService.CheckApiAccessAsync("SmartCut");
            if (!hasAccess)
            {
                CustomMessageBox.Show(message, "Không có quyền", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            IsSmartCutPopupOpen = true;
            var selectedMode = await _smartCutService.GetSmartCutModeAsync();
            IsSmartCutPopupOpen = false;

            if (!selectedMode.HasValue)
            {
                return;
            }

            var picked = selectedMode.Value;
            _currentSmartCutMode = picked;
            _smartCutSubtitleTimeline = null;

            if (picked == SmartCutMode.None)
            {
                _smartCutSegmentMaps = null;
                if (TimelineClips != null)
                {
                    foreach (var vm in TimelineClips)
                        vm.SetRenderTimes(TimeSpan.Zero, TimeSpan.Zero);
                }
                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();
                SmartCutButton.Content = "Tự động Khớp Voice";
                SmartCutButton.Background = new SolidColorBrush(Color.FromRgb(200, 200, 200));
                SmartCutButton.Opacity = 0.6;
            }
            else if (picked == SmartCutMode.DynamicVideo)
            {
                double slowed = DetectMainVideoSlowFactorOrDefault(0.6);
                slowed = Math.Clamp(slowed, 0.1, 4.0);
                ApplySmartCutScaleToSubtitlesAndVoices(slowed);
                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();
                SmartCutButton.Content = "ON:Dynamic";
                SmartCutButton.Background = new SolidColorBrush(Color.FromRgb(120, 160, 220));
            }
            else if (picked == SmartCutMode.StaticReview || picked == SmartCutMode.ParallelDynamic)
            {
                double slowed = DetectMainVideoSlowFactorOrDefault(0.6);
                slowed = Math.Clamp(slowed, 0.1, 4.0);
                ApplySmartCutScaleToSubtitlesAndVoices(slowed);
                bool restored = TryRestoreStaticReviewFromCache(slowed);
                if (!restored)
                {
                    await RecomputeStaticReviewVirtualTimelineAsync();
                    SaveStaticReviewCacheJson(slowed, _totalTimelineDuration);
                }
                UpdateTimelineScaleAndRender();
                SmartCutButton.Content = "Tự động Khớp Voice ✓";
                SmartCutButton.Background = new SolidColorBrush(Color.FromRgb(120, 200, 120));
                SmartCutButton.Opacity = 1.0;
            }
        }
        private void SmartCutMode1Button_Click(object sender, RoutedEventArgs e)
        {
            _currentSmartCutMode = SmartCutMode.StaticReview;
            _smartCutService.SetResult(SmartCutMode.StaticReview);
        }
        private void SmartCutMode2Button_Click(object sender, RoutedEventArgs e)
        {
            _currentSmartCutMode = SmartCutMode.ParallelDynamic;
            _smartCutService.SetResult(SmartCutMode.ParallelDynamic);
        }
        private void SmartCutDynamicSpeed_Click(object sender, RoutedEventArgs e)
        {
            if (sender is Button button && button.Content is string content)
            {
                string speedValueString = content.Replace("x", "").Trim();
                if (double.TryParse(speedValueString, NumberStyles.Any, CultureInfo.InvariantCulture, out double speedValue))
                {
                    _smartCutDynamicSpeed = speedValue;
                    _smartCutService.SetResult(SmartCutMode.DynamicVideo);
                }
                else
                {
                    _smartCutDynamicSpeed = 0.6;
                    _smartCutService.SetResult(SmartCutMode.DynamicVideo);
                }
            }
        }

        private void SmartCutPopup_Disable_Click(object sender, RoutedEventArgs e)
        {
            _smartCutService.SetResult(SmartCutMode.None);
        }
        private void SmartCutPopup_Closed(object sender, EventArgs e)
        {
            _smartCutService.Cancel();
        }
        private static string GetLatestTtsBatchFolderForProject(string projectName)
        {
            var root = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Projects", "TTS", projectName ?? "Untitled");
            if (!Directory.Exists(root)) return null;
            var subDirs = Directory.GetDirectories(root, "*", SearchOption.TopDirectoryOnly);
            if (subDirs == null || subDirs.Length == 0) return null;
            var latest = subDirs.OrderByDescending(d => Directory.GetLastWriteTimeUtc(d)).FirstOrDefault();
            return latest;
        }

        private async Task WriteTtsSmartCutManifestAsync(
            string ttsBatchFolder,
            List<subphimv1.Subphim.SrtSubtitleLine> voicedLines,
            Dictionary<int, string> audioPathByIndex,
            string sourceSrtPath)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(ttsBatchFolder)) return;
                Directory.CreateDirectory(ttsBatchFolder);

                var manifest = new subphimv1.Subphim.TtsSmartCutManifest
                {
                    ProjectName = _currentProject?.ProjectName ?? "Untitled Project",
                    TtsBatchFolder = ttsBatchFolder,
                    SourceSrtPath = sourceSrtPath,
                    CreatedAtUtc = DateTime.UtcNow,
                    Entries = new List<subphimv1.Subphim.TtsSmartCutEntry>()
                };

                foreach (var line in voicedLines.OrderBy(l => l.StartTime))
                {
                    if (!audioPathByIndex.TryGetValue(line.Index, out var audioPath)) continue;

                    var entry = new subphimv1.Subphim.TtsSmartCutEntry
                    {
                        Index = line.Index,
                        AudioPath = audioPath,
                        StartMs = (long)Math.Round(line.StartTime.TotalMilliseconds),
                        EndMs = (long)Math.Round(line.EndTime.TotalMilliseconds)
                    };
                    manifest.Entries.Add(entry);
                }

                var json = JsonConvert.SerializeObject(manifest, Formatting.Indented);
                var jsonPath = Path.Combine(ttsBatchFolder, "smartcut_manifest.json");
                await File.WriteAllTextAsync(jsonPath, json, Encoding.UTF8);
            }
            catch (Exception ex) { }
        }

        private void SwitchToClip(TimelineClipViewModel clip)
        {
            ClearAllAdorners();
            SelectedSubtitle = null;
            SelectedAudioClip = null;
            if (_selectedTimelineClip != null && _selectedTimelineClip != clip)
            {
                if (_selectedTimelineClip.SourceData is INotifyPropertyChanged oldSource)
                {
                    oldSource.PropertyChanged -= SelectedClip_PropertyChanged;
                }
                _selectedTimelineClip.IsSelected = false;
            }
            _selectedTimelineClip = clip;
            if (_selectedTimelineClip != null)
            {
                _selectedTimelineClip.IsSelected = true;
                if (_selectedTimelineClip.SourceData is INotifyPropertyChanged newSource)
                {
                    newSource.PropertyChanged += SelectedClip_PropertyChanged;
                }
                switch (_selectedTimelineClip.ClipType)
                {
                    case TimelineClipType.Subtitle:
                    case TimelineClipType.Text:
                        if (_selectedTimelineClip.SourceData is SrtSubtitleLine srt)
                        {
                            SelectedSubtitle = srt;
                            if (_activeVisuals.TryGetValue(srt, out var visual))
                            {
                                AddSubtitleAdorner(visual, srt.Style);
                            }
                        }
                        break;

                    case TimelineClipType.Video:
                        if (_selectedTimelineClip.SourceData is MediaAsset videoAsset)
                        {
                            if (!_suppressAdornerForHardSub)
                            {
                                AddVideoAdorner(videoAsset);
                            }
                        }
                        break;

                    case TimelineClipType.Image:
                        if (_selectedTimelineClip.SourceData is MediaAsset imageAsset)
                        {
                            AddImageAdorner(imageAsset);
                        }
                        break;

                    case TimelineClipType.Audio:
                        if (_selectedTimelineClip.SourceData is TimelineAudioClip audioClip)
                        {
                            SelectedAudioClip = audioClip;
                        }
                        break;
                }
            }
            UpdateEditorPanelVisibility();
        }
        private System.Windows.Rect GetReferenceVideoFrameRect()
        {
            double cw = PlayerAdornerDecorator.ActualWidth;
            double ch = PlayerAdornerDecorator.ActualHeight;
            if (cw <= 0 || ch <= 0 || CurrentProject == null
                || CurrentProject.ProjectReferenceVideoWidth <= 0
                || CurrentProject.ProjectReferenceVideoHeight <= 0) return System.Windows.Rect.Empty;

            double videoAspect = (double)CurrentProject.ProjectReferenceVideoWidth / CurrentProject.ProjectReferenceVideoHeight;
            double containerAspect = cw / ch;

            double w, h, x, y;
            if (containerAspect > videoAspect) { h = ch; w = h * videoAspect; x = (cw - w) / 2; y = 0; }
            else { w = cw; h = w / videoAspect; x = 0; y = (ch - h) / 2; }
            return new System.Windows.Rect(x, y, w, h);
        }

        private bool IsPointInsideAnyImageOverlay(System.Windows.Point pInOverlayCanvas)
        {
            foreach (var kv in _activeImageOverlays)
            {
                if (kv.Value is FrameworkElement fe)
                {
                    var hit = SubtitleRenderCanvas.InputHitTest(pInOverlayCanvas) as DependencyObject;
                    if (hit != null && IsDescendantOf(hit, fe)) return true;
                }
            }
            return false;
        }

        #region Context Menu Logic
        private void CreateSubtitlesFromClipsMenuItem_Click(object sender, RoutedEventArgs e)
        {
            _clipsForBatchSubtitle = TimelineClips
                .Where(c => c.IsSelected && c.ClipType == TimelineClipType.Video)
                .OrderBy(c => c.StartTime)
                .ToList();

            if (!_clipsForBatchSubtitle.Any())
            {
                CustomMessageBox.Show("Vui lòng chọn ít nhất một clip video trên timeline.", "Chưa chọn clip", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }
            SubtitleTab.IsChecked = true;
            ModeOcrRadio.IsChecked = true;
            IsBatchSubtitleMode = true;
        }

        private async void StartBatchSubtitleCreationButton_Click(object sender, RoutedEventArgs e)
        {
            if (!await CheckGoogleAccountsAndShowGuideAsync()) return;
            var clipsToProcess = _clipsForBatchSubtitle;

            if (clipsToProcess == null || !clipsToProcess.Any())
            {
                CustomMessageBox.Show("Lỗi: Không tìm thấy danh sách video cần xử lý.", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
                IsBatchSubtitleMode = false;
                return;
            }
            var (usageSuccess, usageStatus, usageMessage) = await ApiService.GetUsageStatusAsync();
            if (!usageSuccess)
            {
                CustomMessageBox.Show($"Không thể kiểm tra giới hạn sử dụng video của bạn. Lỗi: {usageMessage}", "Lỗi Kết Nối", MessageBoxButton.OK, MessageBoxImage.Error);
                IsBatchSubtitleMode = false;
                return;
            }
            if (clipsToProcess.Count > usageStatus.RemainingVideosToday)
            {
                CustomMessageBox.Show($"Bạn muốn xử lý {clipsToProcess.Count} video, nhưng tài khoản của bạn chỉ còn lại {usageStatus.RemainingVideosToday} lượt trong ngày.", "Không Đủ Lượt Xử Lý", MessageBoxButton.OK, MessageBoxImage.Warning);
                IsBatchSubtitleMode = false;
                return;
            }
            if (!await EnsureVsfIsAvailableAsync()) return;
            TranslateTab.IsChecked = true;
            _masterCts = new CancellationTokenSource();
            var token = _masterCts.Token;
            UpdateUiForProcessing(true);
            var allNewSrtLines = new List<SrtSubtitleLine>();
            int lastSrtIndex = 0;
            var clipsToRemove = TimelineClips.Where(c => c.ClipType == TimelineClipType.Subtitle || c.ClipType == TimelineClipType.Text).ToList();
            foreach (var clip in clipsToRemove) { TimelineClips.Remove(clip); }
            _currentProject.Subtitles.Clear();
            _currentProject.TextClips.Clear();
            SrtSubtitleLinesView.Clear();

            if (string.IsNullOrWhiteSpace(_currentProjectFilePath))
            {
                SaveProjectCurrent();
                _currentProjectFilePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Projects", $"{_currentProject.ProjectName}.json");
            }

            string projectDirectory = Path.GetDirectoryName(_currentProjectFilePath);
            string vsfBaseOutputForProject = Path.Combine(projectDirectory, "Output");
            Directory.CreateDirectory(vsfBaseOutputForProject);

            try
            {
                foreach (var clipVM in clipsToProcess)
                {
                    if (token.IsCancellationRequested) break;
                    var (canProcessThisVideo, processMessage) = await ApiService.TryStartProcessingAsync();
                    if (!canProcessThisVideo)
                    {
                        throw new Exception($"Đã hết lượt xử lý video giữa chừng. Server báo: {processMessage}");
                    }
                    var mediaAsset = clipVM.SourceData as MediaAsset;
                    if (mediaAsset == null) continue;

                    string videoFileName = Path.GetFileNameWithoutExtension(mediaAsset.FilePath);
                    string uniqueVsfOutputDirForVideo = Path.Combine(vsfBaseOutputForProject, videoFileName);
                    if (Directory.Exists(uniqueVsfOutputDirForVideo))
                    {
                        try
                        {
                            DirectoryInfo di = new DirectoryInfo(uniqueVsfOutputDirForVideo);
                            foreach (FileInfo file in di.GetFiles())
                            {
                                file.Delete();
                            }
                            foreach (DirectoryInfo dir in di.GetDirectories())
                            {
                                dir.Delete(true);
                            }
                        }
                        catch (Exception ex) { }
                    }
                    else
                    {
                        Directory.CreateDirectory(uniqueVsfOutputDirForVideo);
                    }
                    var vsfParams = GetVsfParametersFromUi();
                    vsfParams.VideoPath = mediaAsset.FilePath;
                    vsfParams.SpecificOutputDirectory = uniqueVsfOutputDirForVideo;
                    vsfParams.ClearDirectories = true;

                    if (mediaAsset.TrimStartOffset > TimeSpan.Zero || mediaAsset.TrimEndOffset > TimeSpan.Zero)
                    {
                        vsfParams.StartTime = mediaAsset.TrimStartOffset.ToString(@"hh\:mm\:ss\:fff");
                        var effectiveDurationInSource = mediaAsset.Duration - mediaAsset.TrimStartOffset - mediaAsset.TrimEndOffset;
                        vsfParams.EndTime = (mediaAsset.TrimStartOffset + effectiveDurationInSource).ToString(@"hh\:mm\:ss\:fff");
                    }
                    else
                    {
                        vsfParams.StartTime = null;
                        vsfParams.EndTime = null;
                    }
                    var (vsfSuccess, imagesDirPath) = await _vsfService.RunVSFProcessAsync(vsfParams, token);
                    if (!vsfSuccess) throw new Exception($"Tìm Sub cho video '{videoFileName}' thất bại. Dừng quá trình.");
                    if (Directory.Exists(imagesDirPath))
                    {
                        var imageFiles = Directory.GetFiles(imagesDirPath, "*.*", SearchOption.TopDirectoryOnly)
                                                  .Where(f => f.EndsWith(".jpg", StringComparison.OrdinalIgnoreCase) ||
                                                              f.EndsWith(".png", StringComparison.OrdinalIgnoreCase) ||
                                                              f.EndsWith(".jpeg", StringComparison.OrdinalIgnoreCase) ||
                                                              f.EndsWith(".bmp", StringComparison.OrdinalIgnoreCase))
                                          .OrderBy(f => f, new NaturalStringComparer()).ToList();
                        if (imageFiles.Any())
                        {
                            var finalOffset = clipVM.StartTime;
                            var newLines = await PrepareSrtViewFromImages(imageFiles, "", token, -2, finalOffset, lastSrtIndex + 1);
                            allNewSrtLines.AddRange(newLines);
                            lastSrtIndex = allNewSrtLines.Any() ? allNewSrtLines.Max(l => l.Index) : 0;
                        }
                    }
                }

                if (token.IsCancellationRequested) throw new OperationCanceledException();

                if (!allNewSrtLines.Any())
                {
                    UpdateUiForProcessing(false);
                    return;
                }
                foreach (var line in allNewSrtLines)
                {
                    SrtSubtitleLinesView.Add(line);
                }

                Action<int, string> ocrProgressAction = (percent, message) => { };
                bool ocrSuccess = await StartOcrProcessAsync(token, allNewSrtLines, ocrProgressAction);
                if (!ocrSuccess && !token.IsCancellationRequested) throw new Exception("Quá trình OCR gặp lỗi.");
                if (token.IsCancellationRequested) throw new OperationCanceledException();
                var validLinesFromOcr = allNewSrtLines
                    .Where(l => !string.IsNullOrWhiteSpace(l.OriginalText) &&
                                !l.OriginalText.StartsWith("[Lỗi") &&
                                l.OriginalText != "[Đang chờ OCR...]")
                    .ToList();

                var removedAfterMerge = SrtFileUtils.MergeDuplicates(new System.Collections.ObjectModel.ObservableCollection<SrtSubtitleLine>(validLinesFromOcr));
                var finalLines = validLinesFromOcr.Except(removedAfterMerge).ToList();
                SrtFileUtils.ReIndex(new System.Collections.ObjectModel.ObservableCollection<SrtSubtitleLine>(finalLines));
                SrtSubtitleLinesView.Clear();
                _currentProject.Subtitles.Clear();

                foreach (var line in finalLines)
                {
                    SrtSubtitleLinesView.Add(line);
                    _currentProject.Subtitles.Add(line);
                    TimelineClips.Add(new TimelineClipViewModel(line));
                }

                RecalculateTrackAssignments();
                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();
                SaveProjectCurrent();
                IsSrtTranslating = true;
                var linesToTranslate = SrtSubtitleLinesView
                    .Where(l => !string.IsNullOrWhiteSpace(l.OriginalText) && !l.OriginalText.StartsWith("[Lỗi"))
                    .ToList();

                if (linesToTranslate.Any())
                {
                    await TranslateSrtLogic(token, linesToTranslate);
                }
                UpdateUiForProcessing(false);
                CustomMessageBox.Show("Hoàn tất xử lý phụ đề hàng loạt!", "Thành công", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (OperationCanceledException) { }
            catch (Exception ex)
            {
                UpdateUiForProcessing(false);
                CustomMessageBox.Show($"Đã xảy ra lỗi trong quá trình xử lý hàng loạt:\n\n{ex.Message}", "Lỗi nghiêm trọng", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsSrtTranslating = false;
                IsBatchSubtitleMode = false;
                _clipsForBatchSubtitle = null;
                UpdateUiForProcessing(false);
                _masterCts?.Dispose();
                _masterCts = null;
                SaveProjectCurrent();
            }
        }
        private void CopyAttributes_Click(object sender, RoutedEventArgs e)
        {
            // [FIX] Only copy attributes from Text/Subtitle clips
            var selectedClip = TimelineClips.FirstOrDefault(c => c.IsSelected && 
                (c.ClipType == TimelineClipType.Text || c.ClipType == TimelineClipType.Subtitle));
            if (selectedClip?.SourceData is SrtSubtitleLine srtLine)
            {
                _copiedStyleState = srtLine.Style.Clone();
            }
        }

        private void PasteAttributes_Click(object sender, RoutedEventArgs e)
        {
            if (_copiedStyleState == null) return;

            var selectedClips = TimelineClips.Where(c => c.IsSelected && (c.ClipType == TimelineClipType.Text || c.ClipType == TimelineClipType.Subtitle)).ToList();
            foreach (var clip in selectedClips)
            {
                if (clip.SourceData is SrtSubtitleLine srtLine)
                {
                    var originalX = srtLine.Style.X;
                    var originalY = srtLine.Style.Y;
                    var originalScaleX = srtLine.Style.ScaleX;
                    var originalScaleY = srtLine.Style.ScaleY;
                    var originalWidth = srtLine.Style.Width;

                    srtLine.Style = _copiedStyleState.Clone();
                    srtLine.Style.X = _copiedStyleState.X;
                    srtLine.Style.Y = _copiedStyleState.Y;
                    srtLine.Style.ScaleX = _copiedStyleState.ScaleX;
                    srtLine.Style.ScaleY = _copiedStyleState.ScaleY;
                    srtLine.Style.Width = _copiedStyleState.Width;
                    if (_activeVisuals.TryGetValue(srtLine, out var visual))
                    {
                        ApplyStyleToVisual(visual, srtLine.Style);
                    }
                }
            }
            _undoRedoService.AddState(CaptureEditorSnapshot());
            SaveProjectCurrent();
        }
        private void BlurRegionButton_Click(object sender, RoutedEventArgs e)
        {
            IsBlurPopupOpen = true;
            BlurOptionsPopup.IsOpen = true;
        }

        private void BlurOptionsCancelButton_Click(object sender, RoutedEventArgs e)
        {
            DisableBlurFeature();
            IsBlurPopupOpen = false;
            BlurOptionsPopup.IsOpen = false;
        }
        private void EnsureBlurPreviewCreated()
        {
            if (_currentProject == null) return;
            if (_blurPreview != null && _blurPreview.Parent == SubtitleRenderCanvas)
            {
                ApplyZOrderForLayers();
                UpdateBlurVisualBrushViewbox();
                return;
            }
            if (_blurPreview == null)
            {
                FrameworkElement visibleVideoSource = null;

                if (FFMEMediaPlayer != null && FFMEMediaPlayer.Visibility == Visibility.Visible)
                {
                    visibleVideoSource = FFMEMediaPlayer;
                }
                else if (StaticImagePlayer != null && StaticImagePlayer.Visibility == Visibility.Visible && StaticImagePlayer.Source != null)
                {
                    visibleVideoSource = StaticImagePlayer;
                }
                else if (NewPlaybackImage != null && NewPlaybackImage.Visibility == Visibility.Visible && NewPlaybackImage.Source != null)
                {
                    visibleVideoSource = NewPlaybackImage;
                }
                if (visibleVideoSource == null)
                {
                    visibleVideoSource = FFMEMediaPlayer ?? (FrameworkElement)NewPlaybackImage;
                }

                var vb = new VisualBrush(visibleVideoSource)
                {
                    Stretch = Stretch.None,
                    ViewboxUnits = BrushMappingMode.RelativeToBoundingBox,
                    Viewbox = new System.Windows.Rect(0, 0, 1, 1)
                };
                double previewRadius = Math.Max(60.0, Math.Min(100.0, _currentProject.BlurPreviewRadius));
                _blurPreview = new Border
                {
                    Name = "BlurPreview",
                    Uid = "BLUR_PREVIEW",
                    Background = vb,
                    Effect = new System.Windows.Media.Effects.BlurEffect
                    {
                        Radius = previewRadius,
                        KernelType = System.Windows.Media.Effects.KernelType.Gaussian,
                        RenderingBias = System.Windows.Media.Effects.RenderingBias.Quality
                    },
                    Opacity = 1.0,
                    SnapsToDevicePixels = true,
                    BorderBrush = Brushes.Transparent,
                    BorderThickness = new Thickness(0),
                    Width = Math.Max(200, SubtitleRenderCanvas.ActualWidth * 0.6),
                    Height = Math.Max(80, SubtitleRenderCanvas.ActualHeight * 0.18),
                    RenderTransformOrigin = new System.Windows.Point(0.5, 0.5),
                    IsHitTestVisible = true,
                    Focusable = true
                };

                _blurPreview.LayoutUpdated -= BlurPreview_LayoutUpdated;
                _blurPreview.LayoutUpdated += BlurPreview_LayoutUpdated;
                _blurPreview.MouseLeftButtonDown += BlurPreview_MouseLeftButtonDown;
                _blurPreview.DataContext = new MediaAsset
                {
                    Type = AssetType.Blur
                };
                Canvas.SetLeft(_blurPreview, (SubtitleRenderCanvas.ActualWidth - _blurPreview.Width) / 2);
                Canvas.SetTop(_blurPreview, (SubtitleRenderCanvas.ActualHeight - _blurPreview.Height) / 2);
                var layer = AdornerLayer.GetAdornerLayer(PlayerAdornerDecorator);
                _blurAdorner = new SubtitleAdorner(_blurPreview, this, rotationEnabled: false);
                layer.Add(_blurAdorner);

                _blurAdorner.DragDelta += (dx, dy) =>
                {
                    double left = Canvas.GetLeft(_blurPreview);
                    double top = Canvas.GetTop(_blurPreview);
                    double newLeft = left + dx;
                    double newTop = top + dy;
                    newLeft = Math.Clamp(newLeft, 0, Math.Max(0, SubtitleRenderCanvas.ActualWidth - _blurPreview.ActualWidth));
                    newTop = Math.Clamp(newTop, 0, Math.Max(0, SubtitleRenderCanvas.ActualHeight - _blurPreview.ActualHeight));
                    Canvas.SetLeft(_blurPreview, newLeft);
                    Canvas.SetTop(_blurPreview, newTop);
                    UpdateBlurVisualBrushViewbox();
                };

                _blurAdorner.Resized += (s, e) =>
                {
                    double left = Canvas.GetLeft(_blurPreview);
                    double width = _blurPreview.Width;

                    if (e.Direction == ResizeDirection.Left)
                    {
                        double newLeft = left + e.HorizontalChange;
                        double deltaW = left - newLeft;
                        double newW = width + deltaW;
                        if (newLeft < 0)
                        {
                            deltaW += newLeft;
                            newLeft = 0;
                            newW = width + deltaW;
                        }
                        newW = Math.Max(20, Math.Min(newW, SubtitleRenderCanvas.ActualWidth - newLeft));

                        _blurPreview.Width = newW;
                        Canvas.SetLeft(_blurPreview, newLeft);
                    }
                    else
                    {
                        double newW = width + e.HorizontalChange;
                        double maxW = Math.Max(20, SubtitleRenderCanvas.ActualWidth - left);
                        _blurPreview.Width = Math.Max(20, Math.Min(newW, maxW));
                    }

                    UpdateBlurVisualBrushViewbox();
                };

                _blurAdorner.UniformScaleDelta += scaleDelta =>
                {
                    double cx = Canvas.GetLeft(_blurPreview) + _blurPreview.Width / 2.0;
                    double cy = Canvas.GetTop(_blurPreview) + _blurPreview.Height / 2.0;

                    double newW = _blurPreview.Width * (1.0 + scaleDelta);
                    double newH = _blurPreview.Height * (1.0 + scaleDelta);
                    newW = Math.Clamp(newW, 20, SubtitleRenderCanvas.ActualWidth);
                    newH = Math.Clamp(newH, 20, SubtitleRenderCanvas.ActualHeight);
                    double newLeft = cx - newW / 2.0;
                    double newTop = cy - newH / 2.0;
                    newLeft = Math.Clamp(newLeft, 0, Math.Max(0, SubtitleRenderCanvas.ActualWidth - newW));
                    newTop = Math.Clamp(newTop, 0, Math.Max(0, SubtitleRenderCanvas.ActualHeight - newH));
                    _blurPreview.Width = newW;
                    _blurPreview.Height = newH;
                    Canvas.SetLeft(_blurPreview, newLeft);
                    Canvas.SetTop(_blurPreview, newTop);

                    UpdateBlurVisualBrushViewbox();
                };

                _blurAdorner.RotationChanged += angle =>
                {
                    if (_blurPreview.RenderTransform is RotateTransform rt)
                    {
                        rt.Angle = angle;
                        UpdateBlurVisualBrushViewbox();
                    }
                };

                _blurAdorner.DragCompleted += () =>
                {
                    SaveBlurPreviewToProjectState();
                    SaveProjectCurrent();
                };
                _blurPreview.SizeChanged += (_, __) => UpdateBlurVisualBrushViewbox();
                _blurPreview.LayoutUpdated += (_, __) => UpdateBlurVisualBrushViewbox();
                if (FFMEMediaPlayer != null)
                    FFMEMediaPlayer.SizeChanged += (_, __) => UpdateBlurVisualBrushViewbox();
                if (NewPlaybackImage != null)
                    NewPlaybackImage.SizeChanged += (_, __) => UpdateBlurVisualBrushViewbox();
                if (StaticImagePlayer != null)
                    StaticImagePlayer.SizeChanged += (_, __) => UpdateBlurVisualBrushViewbox();

                SubtitleRenderCanvas.SizeChanged += (_, __) =>
                {
                    UpdateBlurVisualBrushViewbox();
                    RestoreBlurPreviewFromProjectState();
                };
            }

            if (_blurPreview.Parent != SubtitleRenderCanvas)
            {
                SubtitleRenderCanvas.Children.Add(_blurPreview);
            }
            Panel.SetZIndex(_blurPreview, Z_ORDER_BLUR);
            ApplyZOrderForLayers();
            UpdateBlurVisualBrushViewbox();
            RestoreBlurPreviewFromProjectState();
        }

        private void BlurPreview_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            try
            {
                EnsureBlurPreviewCreated();

                RemoveVideoAdorner();
                RemoveImageAdorner();
                RemoveSubtitleAdorner();

                if (_adornerLayer == null)
                    _adornerLayer = AdornerLayer.GetAdornerLayer(SubtitleRenderCanvas);

                if (_adornerLayer != null && _blurAdorner != null)
                {
                    var existing = _adornerLayer.GetAdorners(_blurPreview);
                    if (existing == null || !existing.Contains(_blurAdorner))
                        _adornerLayer.Add(_blurAdorner);

                    _blurAdorner.Visibility = Visibility.Visible;
                    _blurAdorner.InvalidateArrange();
                }
                e.Handled = true;
            }
            catch { /*  an toàn để không crash UI */ }
        }


        private void BlurOptionsApplyButton_Click(object sender, RoutedEventArgs e)
        {
            if (_currentProject == null) return;

            _currentProject.BlurMode = BlurBySubtitleRadio.IsChecked == true
                ? ProjectState.BlurApplyMode.PerSubtitle
                : ProjectState.BlurApplyMode.AllTime;

            EnsureBlurPreviewCreated();
            SaveBlurPreviewToProjectState();
            ApplyZOrderForLayers();

            SaveProjectCurrent();
            IsBlurPopupOpen = false;
            BlurOptionsPopup.IsOpen = false;
        }
        private void UpdateBlurVisualBrushViewbox()
        {
            if (_blurPreview == null) return;
            if (!(_blurPreview.Background is VisualBrush vb)) return;
            FrameworkElement videoSource = vb.Visual as FrameworkElement;
            FrameworkElement activeSource = null;

            if (FFMEMediaPlayer != null && FFMEMediaPlayer.Visibility == Visibility.Visible && FFMEMediaPlayer.ActualWidth > 0)
            {
                activeSource = FFMEMediaPlayer;
            }
            else if (StaticImagePlayer != null && StaticImagePlayer.Visibility == Visibility.Visible && StaticImagePlayer.Source != null && StaticImagePlayer.ActualWidth > 0)
            {
                activeSource = StaticImagePlayer;
            }
            else if (NewPlaybackImage != null && NewPlaybackImage.Visibility == Visibility.Visible && NewPlaybackImage.Source != null && NewPlaybackImage.ActualWidth > 0)
            {
                activeSource = NewPlaybackImage;
            }
            if (activeSource != null && activeSource != videoSource)
            {
                vb.Visual = activeSource;
                videoSource = activeSource;
            }

            if (videoSource == null || videoSource.ActualWidth <= 0 || videoSource.ActualHeight <= 0)
            {
                return;
            }
            GeneralTransform t = _blurPreview.TransformToVisual(videoSource);
            System.Windows.Rect r = t.TransformBounds(new System.Windows.Rect(0, 0, _blurPreview.ActualWidth, _blurPreview.ActualHeight));
            double nx = r.X / videoSource.ActualWidth;
            double ny = r.Y / videoSource.ActualHeight;
            double nw = Math.Max(0.0001, r.Width / videoSource.ActualWidth);
            double nh = Math.Max(0.0001, r.Height / videoSource.ActualHeight);
            vb.Viewbox = new System.Windows.Rect(nx, ny, nw, nh);
            double sx = r.Width / Math.Max(0.0001, _blurPreview.ActualWidth);
            double sy = r.Height / Math.Max(0.0001, _blurPreview.ActualHeight);
            double scale = Math.Max(0.001, Math.Min(Math.Abs(sx), Math.Abs(sy)));

            if (_blurPreview.Effect is System.Windows.Media.Effects.BlurEffect blur)
            {
                double baseRadius = Math.Max(60.0, Math.Min(100.0, _currentProject?.BlurPreviewRadius ?? 60.0));
                double compensated = baseRadius / scale;
                compensated = Math.Clamp(compensated, 30.0, 150.0);
                blur.Radius = compensated;
            }
        }
        private void BlurPreview_LayoutUpdated(object sender, EventArgs e)
        {
            try
            {
                UpdateBlurVisualBrushViewbox();
            }
            catch { /* an toàn UI */ }
        }

        private void SaveBlurPreviewToProjectState()
        {
            if (_currentProject == null || _blurPreview == null)
                return;
            FrameworkElement videoSource = null;

            if (FFMEMediaPlayer != null && FFMEMediaPlayer.Visibility == Visibility.Visible && FFMEMediaPlayer.ActualWidth > 0)
            {
                videoSource = FFMEMediaPlayer;
            }
            else if (StaticImagePlayer != null && StaticImagePlayer.Visibility == Visibility.Visible && StaticImagePlayer.Source != null && StaticImagePlayer.ActualWidth > 0)
            {
                videoSource = StaticImagePlayer;
            }
            else if (NewPlaybackImage != null && NewPlaybackImage.Visibility == Visibility.Visible && NewPlaybackImage.Source != null && NewPlaybackImage.ActualWidth > 0)
            {
                videoSource = NewPlaybackImage;
            }
            if (videoSource == null && FFMEMediaPlayer != null && FFMEMediaPlayer.ActualWidth > 0)
            {
                videoSource = FFMEMediaPlayer;
            }

            if (videoSource == null || videoSource.ActualWidth <= 0 || videoSource.ActualHeight <= 0)
            {
                return;
            }

            GeneralTransform t = _blurPreview.TransformToVisual(videoSource);
            System.Windows.Rect r = t.TransformBounds(new System.Windows.Rect(0, 0, _blurPreview.ActualWidth, _blurPreview.ActualHeight));

            _currentProject.BlurRectNormalized = new System.Windows.Rect(
                r.X / videoSource.ActualWidth,
                r.Y / videoSource.ActualHeight,
                Math.Max(0.0001, r.Width / videoSource.ActualWidth),
                Math.Max(0.0001, r.Height / videoSource.ActualHeight)
            );

        }

        private void RemoveBlurAdorner()
        {
            if (_blurAdorner != null && _adornerLayer != null && _blurPreview != null)
            {
                try { _blurAdorner.ReleaseMouseCapture(); } catch { }
                _adornerLayer.Remove(_blurAdorner);
                _blurAdorner.Visibility = Visibility.Collapsed;
                _blurAdorner.InvalidateArrange();
            }
        }
        private const int Z_ORDER_BLUR = -1000;
        private const int Z_ORDER_IMAGE = 100;
        private const int Z_ORDER_SUBTITLE = 200;

        private void ApplyZOrderForLayers()
        {
            if (SubtitleRenderCanvas == null) return;

            foreach (UIElement child in SubtitleRenderCanvas.Children)
            {
                if (child == null) continue;
                if (ReferenceEquals(child, _blurPreview))
                {
                    Panel.SetZIndex(child, Z_ORDER_BLUR);
                    continue;
                }
                if (child is FrameworkElement fe)
                {
                    var dc = fe.DataContext;
                    if (dc is SrtSubtitleLine)
                    {
                        Panel.SetZIndex(fe, Z_ORDER_SUBTITLE);
                        continue;
                    }
                    if (dc is MediaAsset asset && asset.Type == AssetType.Image)
                    {
                        Panel.SetZIndex(fe, Z_ORDER_IMAGE);
                        continue;
                    }
                }
                Panel.SetZIndex(child, 0);
            }
        }
        private void RestoreBlurPreviewFromProjectState()
        {
            if (_currentProject?.BlurRectNormalized is not System.Windows.Rect nr) return;
            if (_blurPreview == null) return;
            double canvasWidth = SubtitleRenderCanvas.ActualWidth;
            double canvasHeight = SubtitleRenderCanvas.ActualHeight;

            if (canvasWidth <= 0 || canvasHeight <= 0) return;

            double px = nr.X * canvasWidth;
            double py = nr.Y * canvasHeight;
            double pw = nr.Width * canvasWidth;
            double ph = nr.Height * canvasHeight;

            _blurPreview.Width = Math.Max(1, pw);
            _blurPreview.Height = Math.Max(1, ph);
            Canvas.SetLeft(_blurPreview, px);
            Canvas.SetTop(_blurPreview, py);

            if (_blurPreview.Tag is double savedAngle && _blurPreview.RenderTransform is RotateTransform rt)
            {
                rt.Angle = savedAngle;
            }

            UpdateBlurVisualBrushViewbox();

        }
        private async void CreateSubtitles_Click(object sender, RoutedEventArgs e)
        {
            var selectedClips = TimelineClips.Where(c => c.IsSelected).ToList();
            var videoClip = selectedClips.FirstOrDefault(c => c.ClipType == TimelineClipType.Video);

            if (videoClip != null && videoClip.SourceData is MediaAsset asset)
            {
                if (_newPlaybackController == null || _activeVideoClip == null)
                {
                    await EnsurePlayerReadyOnFirstVideoClipAsync(videoClip);
                }

                await HandleCreateSubtitlesForVideoAsync(asset);
            }
            else
            {
                CustomMessageBox.Show(
                    "Vui lòng chọn một clip video trên timeline để tạo phụ đề.",
                    "Thông báo",
                    MessageBoxButton.OK,
                    MessageBoxImage.Information);
            }
        }

        private void CreateCompoundClip_Click(object sender, RoutedEventArgs e)
        {
            CustomMessageBox.Show("Chức năng 'Tạo clip ghép' đang được phát triển.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void UndoCompoundClip_Click(object sender, RoutedEventArgs e)
        {
            CustomMessageBox.Show("Chức năng 'Hoàn tác clip ghép' đang được phát triển.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        #endregion

        void PositionMarkerThumb_DragStarted(object sender, DragStartedEventArgs e)
        {
            _isUserDraggingPlayhead = true;
            _playheadDragStartAbsX = Mouse.GetPosition(TracksContainerGrid).X;
            _playheadDragStartTime = _playhead;

            if (_isTimelinePlaying)
            {
                PauseTimelinePlayback();
            }
            EnterFramePreviewMode();
            if (_useNewPlaybackSystem && _newPlaybackController != null)
            {
                _newPlaybackController.StartScrubbing();
            }
        }
        private DateTime _lastDragSeekTime = DateTime.MinValue;
        private const int DRAG_SEEK_THROTTLE_MS = 16; 

        void PositionMarkerThumb_DragDelta(object sender, DragDeltaEventArgs e)
        {
            if (!_isUserDraggingPlayhead || _pixelsPerSecond <= 0) return;

            double currentMouseAbsX = Mouse.GetPosition(TracksContainerGrid).X;
            double deltaX = currentMouseAbsX - _playheadDragStartAbsX;
            double startAbsX = _playheadDragStartTime.TotalSeconds * _pixelsPerSecond;
            double targetAbsX = startAbsX + deltaX;
            double maxAbsX = _totalTimelineDuration.TotalSeconds * _pixelsPerSecond;
            if (targetAbsX < 0) targetAbsX = 0;
            if (targetAbsX > maxAbsX) targetAbsX = maxAbsX;
            TimeSpan newTime = TimeSpan.FromSeconds(targetAbsX / _pixelsPerSecond);
            _playhead = newTime;
            UpdatePlaybackUI(_playhead);
            UpdateSubtitleForCurrentTime(_playhead);
            UpdateScrubbingPreview(_playhead);
        }

        async void PositionMarkerThumb_DragCompleted(object sender, DragCompletedEventArgs e)
        {
            if (!_isUserDraggingPlayhead) return;

            _isUserDraggingPlayhead = false;
            (sender as Thumb)?.ReleaseMouseCapture();

            _playheadDragStartAbsX = 0;
            _playheadDragStartTime = TimeSpan.Zero;
            if (_useNewPlaybackSystem && _newPlaybackController != null)
            {
                await _newPlaybackController.EndScrubbingAsync();
            }

            await ExitFramePreviewMode(restorePlayback: false);

            _ = SeekTimeline(_playhead);
        }
        private void HandleVideoClipModification(TimelineClipViewModel modifiedClip, TimeSpan oldEndTime)
        {
            if (modifiedClip == null) return;
            modifiedClip.RefreshPropertiesFromSource();
            var newEndTime = modifiedClip.EndTime;
            var delta = newEndTime - oldEndTime;
            AdjustSubsequentClipTimings(modifiedClip, delta, oldEndTime);
            RecalculateTotalDuration();
            UpdateTimelineScaleAndRender();
            _undoRedoService.AddState(CaptureEditorSnapshot());
        }
        private void AdjustSubsequentClipTimings(TimelineClipViewModel modifiedClip, TimeSpan timeDelta, TimeSpan modificationPoint)
        {
            if (Math.Abs(timeDelta.TotalMilliseconds) < 1)
            {
                return;
            }
            var subsequentClips = TimelineClips
                .Where(c => c != modifiedClip && c.StartTime >= modificationPoint)
                .ToList();

            if (!subsequentClips.Any())
            {
                return;
            }
            foreach (var clip in subsequentClips)
            {
                var oldStartTime = clip.StartTime;
                var newStartTime = oldStartTime + timeDelta;
                if (newStartTime < TimeSpan.Zero)
                {
                    newStartTime = TimeSpan.Zero;
                }
                clip.StartTime = newStartTime;
            }
        }
        private double ComputePlayerScaleFactor()
        {
            const double REF_H = DEFAULT_REFERENCE_HEIGHT;
            double playerH = SubtitleRenderCanvas?.ActualHeight > 1 ? SubtitleRenderCanvas.ActualHeight : videoGrid?.ActualHeight ?? REF_H;
            if (playerH <= 1) playerH = REF_H;
            return playerH / REF_H;
        }
        private void EnsureInitialTemplateWidthFitsVideo()
        {
        }
        private void UpdateOverlaysForCurrentTime(TimeSpan timelineTime)
        {
            var imageClipsToShow = TimelineClips
                .Where(c => c.ClipType == TimelineClipType.Image && timelineTime >= c.StartTime && timelineTime < c.EndTime)
                .Select(c => c.SourceData as MediaAsset)
                .Where(asset => asset != null)
                .ToList();

            var visualsToRemove = _activeImageOverlays.Keys
                .Where(asset => !imageClipsToShow.Contains(asset))
                .ToList();

            foreach (var asset in visualsToRemove)
            {
                var visual = _activeImageOverlays[asset];
                SubtitleRenderCanvas.Children.Remove(visual);
                _activeImageOverlays.Remove(asset);
            }

            foreach (var asset in imageClipsToShow)
            {
                if (!_activeImageOverlays.ContainsKey(asset))
                {
                    DisplayImageOnPlayer(asset);
                }
            }
        }

        private void DisplayImageOnPlayer(MediaAsset asset)
        {
            if (asset == null || string.IsNullOrEmpty(asset.FilePath) || !File.Exists(asset.FilePath))
            {
                return;
            }

            if (_activeImageOverlays.ContainsKey(asset))
            {
                return;
            }

            try
            {
                var imageControl = new System.Windows.Controls.Image
                {
                    Stretch = Stretch.Fill,
                    DataContext = asset
                };
                imageControl.MouseLeftButtonDown += ImageOverlay_MouseLeftButtonDown;
                var bitmap = new BitmapImage();
                bitmap.BeginInit();
                bitmap.UriSource = new Uri(asset.FilePath);
                bitmap.CacheOption = BitmapCacheOption.OnLoad;
                bitmap.EndInit();
                bitmap.Freeze();
                imageControl.Source = bitmap;

                SubtitleRenderCanvas.Children.Add(imageControl);
                Panel.SetZIndex(imageControl, Z_ORDER_IMAGE);
                ApplyZOrderForLayers();
                _activeImageOverlays[asset] = imageControl;

                ApplyTransformToImageVisual(imageControl, asset);
            }
            catch (Exception ex) { }
        }
        private void ImageOverlay_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (sender is FrameworkElement fe && fe.DataContext is MediaAsset asset)
            {
                e.Handled = true;
                var clip = TimelineClips
                    .FirstOrDefault(c => c.SourceData == asset
                                         && _playhead >= c.StartTime && _playhead < c.EndTime);
                if (clip != null)
                {
                    SwitchToClip(clip);
                }
                else
                {
                    ClearAllAdorners();
                    AddImageAdorner(asset);
                    UpdateEditorPanelVisibility();
                }
            }
        }
        private void ApplyTransformToImageVisual(FrameworkElement overlayVisual, MediaAsset asset)
        {
            if (overlayVisual == null || asset == null) return;
            double refW = Math.Max(1, this.CurrentProject.ProjectReferenceVideoWidth);
            double refH = Math.Max(1, this.CurrentProject.ProjectReferenceVideoHeight);
            double refAspect = refW / refH;
            double canvasW = Math.Max(1, SubtitleRenderCanvas.ActualWidth);
            double canvasH = Math.Max(1, SubtitleRenderCanvas.ActualHeight);
            double toCanvas = Math.Min(canvasW / refW, canvasH / refH);
            double frameW = refW * toCanvas;
            double frameH = refH * toCanvas;
            double frameLeft = (canvasW - frameW) / 2;
            double frameTop = (canvasH - frameH) / 2;
            double imgW = asset.Width > 0 ? asset.Width : refW * 0.5;
            double imgH = asset.Height > 0 ? asset.Height : refH * 0.5;
            double imgAspect = imgW / Math.Max(1, imgH);

            double initW_ref, initH_ref;
            if (imgAspect >= refAspect)
            {
                initW_ref = refW;
                initH_ref = refW / imgAspect;
            }
            else
            {
                initH_ref = refH;
                initW_ref = refH * imgAspect;
            }
            double scaledInitW = initW_ref * toCanvas;
            double scaledInitH = initH_ref * toCanvas;
            double sx = Math.Max(asset.ScaleX, 0.0001);
            double sy = Math.Max(asset.ScaleY, 0.0001);
            double finalW = scaledInitW * sx;
            double finalH = scaledInitH * sy;
            overlayVisual.Width = finalW;
            overlayVisual.Height = finalH;
            double centerX = frameLeft + asset.PositionX * frameW;
            double centerY = frameTop + asset.PositionY * frameH;
            Canvas.SetLeft(overlayVisual, centerX - finalW / 2.0);
            Canvas.SetTop(overlayVisual, centerY - finalH / 2.0);
            overlayVisual.RenderTransformOrigin = new System.Windows.Point(0.5, 0.5);
            overlayVisual.RenderTransform = new System.Windows.Media.RotateTransform(asset.Rotation);
        }

        private void VideoContainer_PreviewMouseWheel(object sender, MouseWheelEventArgs e)
        {
            if (Keyboard.Modifiers != ModifierKeys.Control)
            {
                return;
            }

            e.Handled = true;

            double oldScale = _playerPanelScale;
            double newScale;

            if (e.Delta > 0)
            {
                newScale = oldScale * PLAYER_ZOOM_SPEED;
            }
            else
            {
                newScale = oldScale / PLAYER_ZOOM_SPEED;
            }
            _playerPanelScale = Math.Clamp(newScale, PLAYER_ZOOM_MIN, 1.0);
            videoGridScaleTransform.ScaleX = _playerPanelScale;
            videoGridScaleTransform.ScaleY = _playerPanelScale;
            videoGridTranslateTransform.X = 0;
            videoGridTranslateTransform.Y = 0;
            _videoAdorner?.InvalidateArrange();
        }

        private void AddVideoAdorner(MediaAsset asset)
        {

            if (IsSnapshotModeActive || (SnapshotResultPanel != null && SnapshotResultPanel.Visibility == Visibility.Visible)) return;
            if (_suppressAdornerForHardSub) return;
            RemoveVideoAdorner();
            RemoveImageAdorner();
            RemoveSubtitleAdorner();
            if (asset == null) return;
            var adornerLayer = AdornerLayer.GetAdornerLayer(PlayerAdornerDecorator);
            if (adornerLayer != null)
            {
                _videoAdorner = new VideoAdorner(PlayerAdornerDecorator, videoGrid, this);

                _activeTransformingVideoAsset = asset;
                _videoAdorner.DataContext = asset;
                _videoAdorner.DragDelta += VideoAdorner_DragDelta;
                _videoAdorner.ScaleChanged += VideoAdorner_ScaleChanged;
                _videoAdorner.DragCompleted += VideoAdorner_DragCompleted;

                adornerLayer.Add(_videoAdorner);
                UpdateVideoTransform(asset);
            }
        }
        private void ActivateVideoAdornerIfNeeded()
        {
            if (IsSnapshotModeActive) return;
            if (_suppressAdornerForHardSub) return;

            if (_videoAdorner == null
                && _selectedTimelineClip?.SourceData is MediaAsset asset
                && asset.Type == AssetType.Video)
            {
                AddVideoAdorner(asset);
            }
        }
        private void ActivateImageAdornerIfNeeded()
        {
            if (IsSnapshotModeActive) return;
            if (_imageAdorner == null
                && _selectedTimelineClip?.SourceData is MediaAsset asset
                && asset.Type == AssetType.Image)
            {
                AddImageAdorner(asset);
            }
        }
        private void TextBox_LostFocus_TriggerSmartLogic(object sender, RoutedEventArgs e)
        {
            if (_isModifyingVideoClip && _selectedTimelineClip != null)
            {
                HandleVideoClipModification(_selectedTimelineClip, _preModificationEndTime);
            }
            _isModifyingVideoClip = false;
        }
        private void TransformControl_InteractionStarted(object sender, RoutedEventArgs e)
        {
            if (_selectedTimelineClip?.SourceData is MediaAsset asset)
            {
                if (asset.Type == AssetType.Video)
                {
                    RemoveImageAdorner();
                    ActivateVideoAdornerIfNeeded();
                }
                else if (asset.Type == AssetType.Image)
                {
                    RemoveVideoAdorner();
                    ActivateImageAdornerIfNeeded();
                }

                _isModifyingVideoClip = true;
                _preModificationEndTime = _selectedTimelineClip.EndTime;
            }
        }
        private void TransformControl_InteractionCompleted(object sender, MouseButtonEventArgs e)
        {
            if (_isModifyingVideoClip && _selectedTimelineClip != null)
            {
                HandleVideoClipModification(_selectedTimelineClip, _preModificationEndTime);
            }
            _isModifyingVideoClip = false;
        }
        private void RemoveVideoAdorner()
        {
            if (_videoAdorner != null)
            {
                try { _videoAdorner.ReleaseMouseCapture(); } catch { }
                _videoAdorner.DragDelta -= VideoAdorner_DragDelta;
                _videoAdorner.ScaleChanged -= VideoAdorner_ScaleChanged;
                _videoAdorner.DragCompleted -= VideoAdorner_DragCompleted;

                var layer = AdornerLayer.GetAdornerLayer(PlayerAdornerDecorator);
                layer?.Remove(_videoAdorner);

                _videoAdorner = null;
                _activeTransformingVideoAsset = null;
            }
        }
        private void VideoAdorner_DragDelta(double horizontalChange, double verticalChange)
        {
            if (_activeTransformingVideoAsset == null || videoGrid.ActualWidth == 0 || videoGrid.ActualHeight == 0) return;
            double currentScale = _activeTransformingVideoAsset.Scale;
            if (currentScale <= 0.001) return;
            double dx = horizontalChange / (videoGrid.ActualWidth * currentScale);
            double dy = verticalChange / (videoGrid.ActualHeight * currentScale);
            _activeTransformingVideoAsset.PositionX += dx;
            _activeTransformingVideoAsset.PositionY += dy;
            UpdateVideoTransform();
        }
        private void VideoAdorner_ScaleChanged(double newScale)
        {
            if (_activeTransformingVideoAsset == null) return;
            _activeTransformingVideoAsset.Scale = newScale;
            UpdateVideoTransform(_activeTransformingVideoAsset);
        }
        private void VideoAdorner_DragCompleted()
        {
            if (_activeTransformingVideoAsset == null) return;

            _undoRedoService.AddState(CaptureEditorSnapshot());
            SaveProjectCurrent();
        }
        private void UpdateVideoTransform()
        {
            var asset = _activeTransformingVideoAsset ?? (_selectedTimelineClip?.SourceData as MediaAsset);
            UpdateVideoTransform(asset);
        }
        private void UpdateVideoTransform(MediaAsset assetToUpdate, [CallerMemberName] string caller = null)
        {
            var currentAssetBeingPlayed = _activeVideoClip?.SourceData as MediaAsset;

            if (assetToUpdate == null)
            {
                // Reset transforms on both players
                ResetVideoTransformOnElement(NewPlaybackImage);
                ResetVideoTransformOnElement(FFMEMediaPlayer);
                _videoAdorner?.InvalidateVisual();
                _videoAdorner?.InvalidateArrange();
                return;
            }

            // FIX: When actively transforming via adorner, use the transforming asset's values
            // even if it's different from the currently playing asset (e.g., same logical video)
            // Only skip if we're NOT in active transformation mode and the assets don't match
            bool isActivelyTransforming = _activeTransformingVideoAsset != null && 
                                          ReferenceEquals(assetToUpdate, _activeTransformingVideoAsset);
            
            if (!isActivelyTransforming && assetToUpdate != currentAssetBeingPlayed)
            {
                return;
            }

            double scaleX = assetToUpdate.ScaleX;
            double scaleY = assetToUpdate.ScaleY;
            double posX = assetToUpdate.PositionX;
            double posY = assetToUpdate.PositionY;

            double translateX = 0;
            double translateY = 0;
            if (videoGrid != null && videoGrid.ActualWidth > 0 && videoGrid.ActualHeight > 0)
            {
                translateX = (posX - 0.5) * videoGrid.ActualWidth;
                translateY = (posY - 0.5) * videoGrid.ActualHeight;
            }

            // Apply transforms to both NewPlaybackImage and FFMEMediaPlayer
            ApplyVideoTransformToElement(NewPlaybackImage, scaleX, scaleY, translateX, translateY);
            ApplyVideoTransformToElement(FFMEMediaPlayer, scaleX, scaleY, translateX, translateY);

            _videoAdorner?.InvalidateVisual();
            _videoAdorner?.InvalidateArrange();
        }

        private void ResetVideoTransformOnElement(FrameworkElement element)
        {
            if (element == null) return;
            if (element.RenderTransform is TransformGroup tg_reset)
            {
                if (tg_reset.Children.Count > 0 && tg_reset.Children[0] is ScaleTransform st) { st.ScaleX = 1; st.ScaleY = 1; }
                if (tg_reset.Children.Count > 1 && tg_reset.Children[1] is TranslateTransform tt) { tt.X = 0; tt.Y = 0; }
            }
        }

        private void ApplyVideoTransformToElement(FrameworkElement element, double scaleX, double scaleY, double translateX, double translateY)
        {
            if (element == null) return;
            if (element.RenderTransform is TransformGroup transformGroup)
            {
                if (transformGroup.Children.Count > 0 && transformGroup.Children[0] is ScaleTransform scaleTransform)
                {
                    scaleTransform.ScaleX = scaleX;
                    scaleTransform.ScaleY = scaleY;
                }
                if (transformGroup.Children.Count > 1 && transformGroup.Children[1] is TranslateTransform translateTransform)
                {
                    translateTransform.X = translateX;
                    translateTransform.Y = translateY;
                }
            }
        }
        private void FlipVideoButton_Click(object sender, RoutedEventArgs e)
        {
            _isVideoFlipEnabled = !_isVideoFlipEnabled;
            if (sender is Button button)
            {
                if (_isVideoFlipEnabled)
                {
                    button.Background = new SolidColorBrush(Color.FromRgb(0, 120, 215)); 
                    button.Foreground = Brushes.White;
                }
                else
                {
                    button.ClearValue(Button.BackgroundProperty);
                    button.ClearValue(Button.ForegroundProperty);
                }
            }

            string status = _isVideoFlipEnabled ? "BẬT" : "TẮT";
        }

        private async void SmartMergeButton_Click(object sender, RoutedEventArgs e)
        {
            if (SrtSubtitleLinesView == null || SrtSubtitleLinesView.Count < 2)
            {
                CustomMessageBox.Show("Không có đủ dòng phụ đề để thực hiện gộp.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            bool wasPlaying = _isTimelinePlaying;
            if (wasPlaying)
            {
                PauseTimelinePlayback();
            }
            List<SrtSubtitleLine> removedLines = SrtFileUtils.MergeDuplicates(SrtSubtitleLinesView);

            if (removedLines.Any())
            {
                var clipsToRemoveFromTimeline = new List<TimelineClipViewModel>();
                foreach (var removedLine in removedLines)
                {
                    _currentProject.Subtitles.Remove(removedLine);
                    var clipVM = TimelineClips.FirstOrDefault(c => c.SourceData == removedLine);
                    if (clipVM != null)
                    {
                        clipsToRemoveFromTimeline.Add(clipVM);
                    }
                }

                foreach (var clipVM in clipsToRemoveFromTimeline)
                {
                    TimelineClips.Remove(clipVM);
                }
                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();

                _undoRedoService.AddState(CaptureEditorSnapshot());
                await SaveProjectCurrentAsync();
                CustomMessageBox.Show($"Đã gộp thành công {removedLines.Count} dòng phụ đề.", "Hoàn tất", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            else
            {
                CustomMessageBox.Show("Không tìm thấy dòng phụ đề nào liền kề và trùng lặp để gộp.", "Thông báo", MessageBoxButton.OK, MessageBoxImage.Information);
            }

            if (wasPlaying)
            {
                StartTimelinePlayback();
            }
        }

        private void UpdatePlayerLayout()
        {
            if (CurrentProject != null && CurrentProject.ProjectReferenceVideoWidth > 0 && CurrentProject.ProjectReferenceVideoHeight > 0)
            {
                videoGrid.Width = CurrentProject.ProjectReferenceVideoWidth;
                videoGrid.Height = CurrentProject.ProjectReferenceVideoHeight;
            }
            else
            {
                videoGrid.Width = DEFAULT_REFERENCE_WIDTH;
                videoGrid.Height = DEFAULT_REFERENCE_HEIGHT;
            }
            overlayCanvas.Width = videoGrid.Width;
            overlayCanvas.Height = videoGrid.Height;
        }
        private sealed class SmartCutSegmentMap
        {
            public TimeSpan SourceStart { get; init; }
            public TimeSpan SourceEnd { get; init; }
            public TimeSpan FinalStart { get; init; }
            public TimeSpan FinalEnd { get; init; }
            public bool IsGap { get; init; }
            public double Scale { get; init; }
        }
        private List<SmartCutSegmentMap> _smartCutSegmentMaps;
        private (List<(SrtSubtitleLine Line, TimeSpan FinalStart, TimeSpan FinalEnd)>,
         List<SmartCutSegmentMap>,
         TimeSpan)
BuildSmartCutSegmentMapForStaticReview(
    List<SrtSubtitleLine> orderedVoicedLines,
    List<TimeSpan> targetDurations,
    double slowedFactor,
    TimeSpan sourceTotalDuration)
        {
            var subtitleTimeline = new List<(SrtSubtitleLine Line, TimeSpan FinalStart, TimeSpan FinalEnd)>();
            var maps = new List<SmartCutSegmentMap>();
            if (orderedVoicedLines == null || targetDurations == null || orderedVoicedLines.Count == 0)
                return (subtitleTimeline, maps, TimeSpan.Zero);

            if (orderedVoicedLines.Count != targetDurations.Count)
                return (subtitleTimeline, maps, TimeSpan.Zero);

            TimeSpan prevSrcEnd = TimeSpan.Zero;
            TimeSpan cursorFinal = TimeSpan.Zero;

            for (int i = 0; i < orderedVoicedLines.Count; i++)
            {
                var line = orderedVoicedLines[i];
                var targetVoiceDuration = targetDurations[i];
                var srcStart = TimeSpan.FromSeconds(
                    Math.Max(0.0, line.StartTime.TotalSeconds * slowedFactor));

                var srcEnd = TimeSpan.FromSeconds(
                    Math.Max(srcStart.TotalSeconds + 1e-6, line.EndTime.TotalSeconds * slowedFactor));
                if (srcStart > prevSrcEnd)
                {
                    var gapLen = srcStart - prevSrcEnd;
                    maps.Add(new SmartCutSegmentMap
                    {
                        SourceStart = prevSrcEnd,
                        SourceEnd = srcStart,
                        FinalStart = cursorFinal,
                        FinalEnd = cursorFinal + gapLen,
                        IsGap = true,
                        Scale = 1.0
                    });
                    cursorFinal += gapLen;
                }

                var srcLen = srcEnd - srcStart;
                if (srcLen < TimeSpan.FromMilliseconds(1))
                    srcLen = TimeSpan.FromMilliseconds(1);

                var finalLen = srcLen;
                if (targetVoiceDuration > srcLen)
                {
                    finalLen = targetVoiceDuration;
                }

                double segmentScale = 1.0;
                if (finalLen > srcLen)
                {
                    segmentScale = finalLen.TotalSeconds / srcLen.TotalSeconds;
                    if (segmentScale < 1.0) segmentScale = 1.0;
                }
                maps.Add(new SmartCutSegmentMap
                {
                    SourceStart = srcStart,
                    SourceEnd = srcEnd,
                    FinalStart = cursorFinal,
                    FinalEnd = cursorFinal + finalLen,
                    IsGap = false,
                    Scale = segmentScale
                });

                subtitleTimeline.Add((line, cursorFinal, cursorFinal + finalLen));
                cursorFinal += finalLen;
                prevSrcEnd = srcEnd;
            }

            if (sourceTotalDuration > prevSrcEnd)
            {
                var tailLen = sourceTotalDuration - prevSrcEnd;
                maps.Add(new SmartCutSegmentMap
                {
                    SourceStart = prevSrcEnd,
                    SourceEnd = sourceTotalDuration,
                    FinalStart = cursorFinal,
                    FinalEnd = cursorFinal + tailLen,
                    IsGap = true,
                    Scale = 1.0
                });
                cursorFinal += tailLen;
            }
            return (subtitleTimeline, maps, cursorFinal);
        }

        private TimeSpan MapSourceTimeToSmartCut(TimeSpan sourceTime)
        {
            if (_smartCutSegmentMaps == null || _smartCutSegmentMaps.Count == 0)
                return sourceTime;

            foreach (var seg in _smartCutSegmentMaps)
            {
                if (sourceTime >= seg.SourceStart && sourceTime <= seg.SourceEnd)
                {
                    var rel = sourceTime - seg.SourceStart;
                    var add = seg.IsGap
                        ? rel
                        : TimeSpan.FromSeconds(rel.TotalSeconds * seg.Scale);
                    return seg.FinalStart + add;
                }
            }
            var last = _smartCutSegmentMaps.LastOrDefault();
            if (last != null && sourceTime > last.SourceEnd)
                return last.FinalEnd + (sourceTime - last.SourceEnd);

            return sourceTime;
        }
        private async Task RecomputeStaticReviewVirtualTimelineAsync()
        {
            var (voicedSrtLines, timingSegments) = await ResolveSmartCutSourcesAsync();
            if (voicedSrtLines == null || voicedSrtLines.Count == 0 || timingSegments == null || timingSegments.Count == 0)
                return;

            var targetDurations = timingSegments.Select(seg => seg.EffectiveDuration).ToList();

            var mainVideoClip = TimelineClips.FirstOrDefault(c => c.ClipType == TimelineClipType.Video);
            var slowedFactor = (mainVideoClip?.Speed > 0) ? mainVideoClip.Speed : 1.0;
            var sourceTotalSec = await ProbeDurationSecondsAsync(mainVideoClip?.FilePath);
            double trimStart = (mainVideoClip?.SourceData as MediaAsset)?.TrimStartOffset.TotalSeconds ?? 0.0;
            double trimEnd = (mainVideoClip?.SourceData as MediaAsset)?.TrimEndOffset.TotalSeconds ?? 0.0;
            var sourceTotalDuration = TimeSpan.FromSeconds(Math.Max(0, sourceTotalSec - trimStart - trimEnd));


            var (subtitleTimeline, segmentMaps, finalDuration) = BuildSmartCutSegmentMapForStaticReview(voicedSrtLines, targetDurations, slowedFactor, sourceTotalDuration);
            _smartCutSubtitleTimeline = subtitleTimeline;
            _smartCutSegmentMaps = segmentMaps;
            _actualContentDuration = finalDuration;
            _totalTimelineDuration = finalDuration;
            UpdateTimelineScaleAndRender();
        }
        private async Task<bool> CheckGoogleAccountsAndShowGuideAsync()
        {
            if (_currentOcrMode != OcrMode.GoogleCloud)
            {
                return true;
            }
            LoadGoogleAccounts();

            if (_googleAccounts.Any())
            {
                return true;
            }
            string message = "Chức năng Google Cloud OCR yêu cầu cấu hình tài khoản trong thư mục 'Oauth2.0'.\n\n" +
                             "Cấu trúc yêu cầu:\n" +
                             "1. Tạo thư mục 'Oauth2.0' cùng cấp file .exe.\n" +
                             "2. Bên trong, tạo thư mục cho mỗi tài khoản (ví dụ: 'Acc01', 'Acc02',...).\n" +
                             "3. Trong mỗi thư mục tài khoản, đặt:\n" +
                             "   - File 'credentials.json' của tài khoản đó.\n" +
                             "   - Một file rỗng không có đuôi, với tên là ID của thư mục Google Drive.\n\n" +
                             "Nhấn 'OK', một link ảnh hướng dẫn và trang Google Drive sẽ được mở trong trình duyệt của bạn.";

            var result = CustomMessageBox.Show(message, "Thiếu Cấu Hình Google Cloud OCR", MessageBoxButton.OKCancel, MessageBoxImage.Information);
            if (result != MessageBoxResult.OK)
            {
                return false;
            }

            string imageUrl = "https://drive.google.com/file/d/1zH6PKihbBgO9F0kIMat9k396Spzuirdr/view";
            string driveUrl = "https://drive.google.com/drive/my-drive";

            try
            {
                Process.Start(new ProcessStartInfo(driveUrl) { UseShellExecute = true });
                await Task.Delay(500);
                Process.Start(new ProcessStartInfo(imageUrl) { UseShellExecute = true });
            }
            catch (Exception ex)
            {
                CustomMessageBox.Show($"Không thể mở trình duyệt. Vui lòng truy cập thủ công:\n- Hướng dẫn: {imageUrl}\n- Drive: {driveUrl}\nLỗi: {ex.Message}", "Lỗi", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            return false;
        }
        private void OcrProvider_Changed(object sender, RoutedEventArgs e)
        {
            if (!this.IsLoaded) return;

            if (OcrProviderGoogleCloudRadio.IsChecked == true)
            {
                _currentOcrMode = OcrMode.GoogleCloud;
            }
            else
            {
                _currentOcrMode = OcrMode.GeminiApi;
            }

        }

        private void AddToTimelineButton_Click(object sender, RoutedEventArgs e)
        {
            if ((sender as FrameworkElement)?.DataContext is not MediaAsset asset)
            {
                return;
            }

            if (asset.Type == AssetType.Video)
            {
                var lastVideoClip = TimelineClips
                    .Where(c => c.ClipType == TimelineClipType.Video && c.TrackIndex == 0)
                    .OrderBy(c => c.StartTime)
                    .LastOrDefault();
                TimeSpan startTime = lastVideoClip != null ? lastVideoClip.EndTime : TimeSpan.Zero;
                bool isFirstVideoClip = lastVideoClip == null;
                if (isFirstVideoClip)
                {
                    UpdateProjectReferenceDimensions(asset);
                    UpdatePlayerLayout();
                    if (asset.Duration.TotalSeconds > 0 && TimelineScrollViewer.ViewportWidth > 0)
                    {
                        double desiredVisibleDurationSeconds = asset.Duration.TotalSeconds / 0.5;
                        double newPixelsPerSecond = TimelineScrollViewer.ViewportWidth / desiredVisibleDurationSeconds;
                        this._pixelsPerSecond = Math.Clamp(newPixelsPerSecond, GetDynamicMinPixelsPerSecond(), MAX_PIXELS_PER_SECOND);
                    }
                }
                var newClipInstance = asset.Clone();
                _currentProject.TimelineMediaClips.Add(newClipInstance);
                var newVM = new TimelineClipViewModel(newClipInstance);
                newVM.StartTime = startTime;
                newVM.TrackIndex = 0;
                QueueWaveformGeneration(newClipInstance);
                TimelineClips.Add(newVM);
                if (isFirstVideoClip)
                {
                    UpdateProjectReferenceDimensions(asset);
                    videoGrid.Width = CurrentProject.ProjectReferenceVideoWidth;
                    videoGrid.Height = CurrentProject.ProjectReferenceVideoHeight;
                    if (asset.Duration.TotalSeconds > 0 && TimelineScrollViewer.ViewportWidth > 0)
                    {
                        double desiredVisibleDurationSeconds = asset.Duration.TotalSeconds / 0.5;
                        double newPixelsPerSecond = TimelineScrollViewer.ViewportWidth / desiredVisibleDurationSeconds;
                        this._pixelsPerSecond = Math.Clamp(newPixelsPerSecond, GetDynamicMinPixelsPerSecond(), MAX_PIXELS_PER_SECOND);
                    }
                }
                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();
                _undoRedoService.AddState(CaptureEditorSnapshot());
                SaveProjectCurrent();
            }
            else if (asset.Type == AssetType.Subtitle)
            {
                int track = -2;
                LoadSrtFromAssetAsync(asset, null, track);

            }
            else
            {
                var startTime = _playhead;
                int track = 0;
                if (asset.Type == AssetType.Audio) track = 1;
                else if (asset.Type == AssetType.Image) track = -1;

                TimelineClipViewModel newVM;
                if (asset.Type == AssetType.Audio)
                {
                    var newAudioClip = new TimelineAudioClip
                    {
                        FilePath = asset.FilePath,
                        OriginalDuration = asset.Duration,
                        VolumeDb = asset.VolumeDb,
                        Speed = asset.Speed,
                        WavePeaks = asset.WavePeaks
                    };
                    _currentProject.VoicedSubtitles.Add(newAudioClip);
                    TimelineAudioClips.Add(newAudioClip);
                    newVM = new TimelineClipViewModel(newAudioClip);
                    QueueWaveformGeneration(newAudioClip);
                }
                else
                {
                    var newClipInstance = asset.Clone();
                    _currentProject.TimelineMediaClips.Add(newClipInstance);
                    newVM = new TimelineClipViewModel(newClipInstance);
                    PopulateImageFilmstrip(newVM);
                }
                newVM.StartTime = startTime;
                newVM.TrackIndex = track;
                TimelineClips.Add(newVM);
                ResolveCollisionsForClip(newVM);

                RecalculateTotalDuration();
                UpdateTimelineScaleAndRender();
                _undoRedoService.AddState(CaptureEditorSnapshot());
                SaveProjectCurrent();
            }

            e.Handled = true;
        }
        #region Media Bin Logic

        private async void MediaBin_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Delete)
            {
                if (ActiveMediaAsset != null)
                {
                    await DeleteMediaAsset(ActiveMediaAsset);
                    e.Handled = true;
                }
            }
        }
        private string GenerateAssForSingleSegment(int playResX, int playResY, SrtSubtitleLine line, double durationSeconds)
        {
            const double REFERENCE_HEIGHT = 720.0;
            double scaleFactor = playResY / REFERENCE_HEIGHT;
            var sb = new StringBuilder();
            sb.AppendLine("[Script Info]");
            sb.AppendLine($"Title: Segment Subtitle");
            sb.AppendLine($"PlayResX: {playResX}");
            sb.AppendLine($"PlayResY: {playResY}");
            sb.AppendLine("WrapStyle: 2");
            sb.AppendLine("ScaledBorderAndShadow: yes");
            sb.AppendLine();
            sb.AppendLine("[V4+ Styles]");
            sb.AppendLine("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding");
            var t = _currentProject;
            string primary = HexToAssStyleColor(t.TemplateFontColor, t.TemplateOpacity);
            string secondary = primary;
            string outline = HexToAssStyleColor(t.TemplateOutlineColor, t.TemplateOpacity);
            string back = "&H00000000";
            int boldFlag = (t.TemplateFontWeight >= 600) ? -1 : 0;
            int italicFlag = t.TemplateIsItalic ? -1 : 0;
            int underlineFlag = t.TemplateIsUnderlined ? -1 : 0;
            double assDefaultFontSize = t.TemplateFontSize * scaleFactor / 0.988;
            sb.AppendLine($"Style: Default,{t.TemplateFontFamily},{assDefaultFontSize.ToString("F2", CultureInfo.InvariantCulture)},{primary},{secondary},{outline},{back},{boldFlag},{italicFlag},{underlineFlag},0,100,100,{t.TemplateCharacterSpacing},0,1,{t.TemplateOutlineThickness},{t.TemplateShadowDepth},5,10,10,10,1");
            sb.AppendLine($"Style: ShapeBG,{t.TemplateFontFamily},{assDefaultFontSize.ToString("F2", CultureInfo.InvariantCulture)},&H00FFFFFF,&H00000000,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,0,0,2,10,10,10,1");
            sb.AppendLine();
            sb.AppendLine("[Events]");
            sb.AppendLine("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text");
            if (line != null)
            {
                string start = "0:00:00.00";
                TimeSpan durSpan = TimeSpan.FromSeconds(durationSeconds);
                string end = durSpan.ToString(@"h\:mm\:ss\.ff", CultureInfo.InvariantCulture);
                string rawText = _currentProject.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated && !string.IsNullOrWhiteSpace(line.TranslatedText)
                    ? line.TranslatedText
                    : line.OriginalText;
                StyleState style = (line.Style ?? t.GetTemplateAsStyleState()).Clone();
                double effectiveWrapWidthPx = ComputeEffectiveWrapWidthPx(style, scaleFactor, rawText);
                string manualOverride = _currentProject.SelectedSubtitleDisplayMode == SubtitleDisplayMode.Translated ? line.AssOverrideTranslated : line.AssOverrideOriginal;
                string textForAss;
                if (line.HasManualAssOverride && !string.IsNullOrEmpty(manualOverride))
                    textForAss = manualOverride.Replace("\r\n", @"\N").Replace("\n", @"\N");
                else if (style.AllowAutoWrap && effectiveWrapWidthPx < double.PositiveInfinity)
                    textForAss = WrapTextForAssSmart(rawText ?? "", style, effectiveWrapWidthPx, scaleFactor);
                else
                    textForAss = (rawText ?? "").Replace("\r\n", @"\N").Replace("\n", @"\N");
                var (measuredWLogical, measuredHLogical) = MeasureTextBoxPixels_UsingTextBlock(textForAss.Replace("\\N", "\n"), style, 1.0, double.PositiveInfinity);
                double contentWpx = measuredWLogical * style.ScaleX * scaleFactor;
                double contentHpx = measuredHLogical * style.ScaleY * scaleFactor;
                var (padXpx, padYpx) = ComputeFinalPaddingPx(style, scaleFactor);
                double rectW = contentWpx + (padXpx * 2.0);
                double rectH = contentHpx + (padYpx * 2.0);
                int px = (int)Math.Round(style.X * playResX);
                int py = (int)Math.Round(style.Y * playResY);

                if (style.IsBackgroundEnabled)
                {
                    int left = (int)Math.Floor(px - rectW / 2.0);
                    int top = (int)Math.Floor(py - rectH / 2.0);
                    double rx = style.BackgroundCornerRadius * style.ScaleX * scaleFactor;
                    double ry = style.BackgroundCornerRadius * style.ScaleY * scaleFactor;
                    string path = (style.BackgroundCornerRadius > 0) ? BuildRoundedRectPath(rectW, rectH, rx, ry) : BuildTopLeftRectPath(rectW, rectH);

                    var (assColorNoAlpha, assAlpha) = HexToAssColorAndAlpha(style.BackgroundColorHex, style.Opacity);
                    var bgTags = new StringBuilder();
                    bgTags.Append(@"\an7");
                    bgTags.Append($"\\pos({left},{top})");
                    if (Math.Abs(style.Rotation) > double.Epsilon)
                    {
                        int orgAbsX = left + (int)Math.Round(rectW / 2.0);
                        int orgAbsY = top + (int)Math.Round(rectH / 2.0);
                        bgTags.Append($"\\org({orgAbsX},{orgAbsY})\\frz{(-style.Rotation).ToString("F2", CultureInfo.InvariantCulture)}");
                    }
                    bgTags.Append($"\\1c{assColorNoAlpha}\\1a{assAlpha}\\bord0\\shad0\\p1");

                    sb.AppendLine($"Dialogue: 0,{start},{end},ShapeBG,,0,0,0,,{{{bgTags}}}{path}{{\\p0}}");
                }
                string textTags = GenerateAssOverrideTags_TextOnly(style, playResX, playResY, rectW, padXpx, scaleFactor);
                sb.AppendLine($"Dialogue: 1,{start},{end},Default,,0,0,0,,{{{textTags}}}{textForAss}");
            }

            return sb.ToString();
        }

        private void MenuItem_Click(object sender, RoutedEventArgs e)
        {

        }

        private async void DeleteMediaBinItem_Click(object sender, RoutedEventArgs e)
        {
            if (sender is MenuItem menuItem && menuItem.DataContext is MediaAsset assetToDelete)
            {
                await DeleteMediaAsset(assetToDelete);
            }
        }
        private async void TranslateSubtitleFromMediaBin_Click(object sender, RoutedEventArgs e)
        {
            if (sender is not MenuItem menuItem || menuItem.DataContext is not MediaAsset asset)
            {
                return;
            }
            if (asset.Type != AssetType.Subtitle || string.IsNullOrEmpty(asset.FilePath) || !File.Exists(asset.FilePath))
            {
                return;
            }
            if (SrtSubtitleLinesView.Any(l => !l.IsTextClip))
            {
                var result = CustomMessageBox.Show(
                    "Thao tác này sẽ xoá tất cả các dòng phụ đề hiện có khỏi bảng dịch và timeline. Các Text sẽ được giữ lại. Bạn có muốn tiếp tục?",
                    "Xác nhận",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);
                if (result == MessageBoxResult.No)
                {
                    return;
                }
            }

            if (_isTimelinePlaying)
            {
                await PauseTimelinePlayback();
            }
            var srtClipsOnTimeline = TimelineClips.Where(c => c.ClipType == TimelineClipType.Subtitle).ToList();
            foreach (var clip in srtClipsOnTimeline)
            {
                TimelineClips.Remove(clip);
            }
            _currentProject.Subtitles.Clear();
            var subtitlesInView = SrtSubtitleLinesView.Where(l => !l.IsTextClip).ToList();
            foreach (var line in subtitlesInView)
            {
                SrtSubtitleLinesView.Remove(line);
            }
            await LoadSrtFile(asset.FilePath, addToTimelineAndProject: false);
            TranslateTab.IsChecked = true;
            RecalculateTotalDuration();
            UpdateTimelineScaleAndRender();
            _undoRedoService.AddState(CaptureEditorSnapshot());
            await SaveProjectCurrentAsync();
        }
        private async Task DeleteMediaAsset(MediaAsset assetToDelete)
        {
            if (assetToDelete == null)
            {
                return;
            }

            bool wasPlaying = _isTimelinePlaying;
            if (wasPlaying)
            {
                await PauseTimelinePlayback();
            }
            switch (assetToDelete.Type)
            {
                case AssetType.Video:
                case AssetType.Image:
                    VideoImageAssets.Remove(assetToDelete);
                    break;
                case AssetType.Audio:
                    AudioAssets.Remove(assetToDelete);
                    break;
                case AssetType.Subtitle:
                    SubtitleAssets.Remove(assetToDelete);
                    break;
            }
            var clipsToRemove = TimelineClips
                .Where(vm =>
                {
                    if (vm.SourceData is MediaAsset ma)
                    {
                        return ma.FilePath == assetToDelete.FilePath;
                    }
                    return false;
                })
                .ToList();
            if (assetToDelete.Type == AssetType.Subtitle)
            {
                var srtClipsOnTimeline = TimelineClips.Where(c => c.ClipType == TimelineClipType.Subtitle).ToList();
                clipsToRemove.AddRange(srtClipsOnTimeline);
                clipsToRemove = clipsToRemove.Distinct().ToList();
                var srtLinesToRemove = srtClipsOnTimeline
                    .Select(c => c.SourceData as SrtSubtitleLine)
                    .Where(line => line != null)
                    .ToList();
                foreach (var line in srtLinesToRemove)
                {
                    SrtSubtitleLinesView.Remove(line);
                    _currentProject.Subtitles.Remove(line);
                }
            }
            foreach (var clipVM in clipsToRemove)
            {
                TimelineClips.Remove(clipVM);
                if (clipVM.SourceData is MediaAsset ma)
                {
                    _currentProject.TimelineMediaClips.Remove(ma);
                }
            }
            if (ActiveMediaAsset == assetToDelete)
            {
                ActiveMediaAsset = null;
            }

            RecalculateTotalDuration();
            UpdateTimelineScaleAndRender();
            _undoRedoService.AddState(CaptureEditorSnapshot());
            await SaveProjectCurrentAsync();

            if (wasPlaying)
            {
                await StartTimelinePlayback();
            }
        }

        #endregion

    }
    public static class AssetTypeExtensions
    {
        public static TimelineClipType ToTimelineClipType(this AssetType assetType)
        {
            return assetType switch
            {
                AssetType.Video => TimelineClipType.Video,
                AssetType.Audio => TimelineClipType.Audio,
                AssetType.Image => TimelineClipType.Image,
                AssetType.Subtitle => TimelineClipType.Subtitle,
                _ => throw new ArgumentOutOfRangeException(nameof(assetType), $"Not expected asset type value: {assetType}"),
            };
        }
    }
    public class SegmentOverlayInfo
    {
        public string FilePath { get; set; }
        public double RelativeStartSeconds { get; set; } 
        public double RelativeEndSeconds { get; set; }   
        public double X { get; set; }
        public double Y { get; set; }
        public double ScaleX { get; set; }
        public double ScaleY { get; set; }
        public double Rotation { get; set; }
        public int Width { get; set; }
        public int Height { get; set; }
    }
}

